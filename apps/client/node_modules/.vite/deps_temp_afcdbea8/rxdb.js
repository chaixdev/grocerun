import {
  addRxPlugin
} from "./chunk-BUKA3TLL.js";
import {
  BROADCAST_CHANNEL_BY_TOKEN,
  addRxStorageMultiInstanceSupport,
  getBroadcastChannelReference,
  removeBroadcastChannelReference
} from "./chunk-KBUYXFCO.js";
import {
  INTERNAL_CONTEXT_COLLECTION,
  INTERNAL_CONTEXT_MIGRATION_STATUS,
  INTERNAL_CONTEXT_STORAGE_TOKEN,
  INTERNAL_STORE_SCHEMA,
  INTERNAL_STORE_SCHEMA_TITLE,
  META_INSTANCE_SCHEMA_TITLE,
  RxCollectionBase,
  RxDatabaseBase,
  RxSchema,
  STORAGE_TOKEN_DOCUMENT_ID,
  STORAGE_TOKEN_DOCUMENT_KEY,
  _collectionNamePrimary,
  addConnectedStorageToCollection,
  awaitRxStorageReplicationFirstInSync,
  awaitRxStorageReplicationIdle,
  awaitRxStorageReplicationInSync,
  basePrototype,
  beforeDocumentUpdateWrite,
  cancelRxStorageReplication,
  createNewRxDocument,
  createRxCollection,
  createRxCollectionStorageInstance,
  createRxDatabase,
  createRxDatabaseStorageInstance,
  createRxDocumentConstructor,
  createRxSchema,
  createWithConstructor,
  dbCount,
  defaultConflictHandler,
  docStateToWriteDoc,
  ensureNoStartupErrors,
  ensureRxCollectionIsNotDestroyed,
  ensureStorageTokenDocumentExists,
  fillObjectDataBeforeInsert,
  getAllCollectionDocuments,
  getAssumedMasterState,
  getCheckpointKey,
  getDocumentOrmPrototype,
  getDocumentPrototype,
  getIndexes,
  getLastCheckpointDoc,
  getMetaWriteRow,
  getPreviousVersions,
  getPrimaryKeyOfInternalDocument,
  getRxDocumentConstructor,
  getRxReplicationMetaInstanceSchema,
  getUnderlyingPersistentStorage,
  isDatabaseStateVersionCompatibleWithDatabaseCode,
  isRxCollection,
  isRxDatabase,
  isRxDatabaseFirstTimeInstantiated,
  isRxDocument,
  isRxSchema,
  removeCollectionStorages,
  removeConnectedStorageFromCollection,
  removeRxDatabase,
  replicateRxStorageInstance,
  resolveConflictError,
  rxStorageInstanceToReplicationHandler,
  setCheckpoint,
  startReplicationDownstream,
  startReplicationUpstream,
  stripAttachmentsDataFromMetaWriteRows,
  toTypedRxJsonSchema,
  writeDocToDocState
} from "./chunk-D572SGZR.js";
import {
  BehaviorSubject,
  COLLECTIONS_WITH_RUNNING_CLEANUP,
  DEFAULT_CHECKPOINT_SCHEMA,
  DEFAULT_TRY_TO_KEEP_MAX,
  DEFAULT_UNEXECUTED_LIFETIME,
  HOOKS,
  INDEX_MAX,
  INDEX_MIN,
  INTERNAL_STORAGE_NAME,
  LOGICAL_OPERATORS,
  LOWER_BOUND_LOGICAL_OPERATORS,
  PREMIUM_FLAG_HASH,
  PROMISE_RESOLVE_FALSE,
  PROMISE_RESOLVE_NULL,
  PROMISE_RESOLVE_TRUE,
  PROMISE_RESOLVE_VOID,
  QueryCache,
  RANDOM_STRING,
  REGEX_ALL_DOTS,
  REGEX_ALL_PIPES,
  RXDB_UTILS_GLOBAL,
  RXDB_VERSION,
  RXJS_SHARE_REPLAY_DEFAULTS,
  RX_DATABASE_LOCAL_DOCS_STORAGE_NAME,
  RX_META_LWT_MINIMUM,
  RX_META_SCHEMA,
  RxError,
  RxQueryBase,
  RxQuerySingleResult,
  RxTypeError,
  UPPER_BOUND_LOGICAL_OPERATORS,
  _clearHook,
  _getDefaultQuery,
  appendToArray,
  areRxDocumentArraysEqual,
  arrayBufferToBase64,
  arrayBufferToString,
  arrayFilterNotEmpty,
  asyncFilter,
  attachmentWriteDataToNormalData,
  b64DecodeUnicode,
  b64EncodeUnicode,
  base64ToArrayBuffer,
  batchArray,
  blobToBase64String,
  blobToString,
  canUseCryptoSubtle,
  categorizeBulkWriteRows,
  clone,
  countRxQuerySubscribers,
  countUntilNotMatching,
  createBlob,
  createBlobFromBase64,
  createQueryCache,
  createRevision,
  createRxQuery,
  deepEqual,
  deepFreeze,
  deepKeys,
  defaultCacheReplacementPolicy,
  defaultCacheReplacementPolicyMonad,
  defaultHashSha256,
  deleteProperty,
  ensureInteger,
  ensureNotFalsy,
  ensureRxStorageInstanceParamsAreCorrect,
  errorToPlainJson,
  errorUrlHint,
  fillObjectWithDefaults,
  fillPrimaryKey,
  fillWithDefaultSettings,
  filter,
  firstPropertyNameOfObject,
  firstPropertyValueOfObject,
  firstValueFrom,
  flatClone,
  flatCloneDocWithMeta,
  flattenEvents,
  flattenObject,
  getAttachmentSize,
  getBlobSize,
  getChangedDocumentsSince,
  getChangedDocumentsSinceQuery,
  getComposedPrimaryKeyOfDocumentData,
  getDefaultIndex,
  getDefaultRevision,
  getDefaultRxDocumentMeta,
  getDocumentDataOfRxChangeEvent,
  getErrorUrl,
  getFinalFields,
  getFromMapOrCreate,
  getFromMapOrThrow,
  getFromObjectOrThrow,
  getHeightOfRevision,
  getLengthOfPrimaryKey,
  getMatcherQueryOpts,
  getPrimaryFieldOfPrimaryKey,
  getProperty,
  getPseudoSchemaForVersion,
  getQueryMatcher,
  getQueryPlan,
  getSchemaByObjectPath,
  getSingleDocument,
  getSortComparator,
  getSortDocumentsByLastWriteTimeComparator,
  getWrappedStorageInstance,
  getWrittenDocumentsFromBulkWriteResponse,
  hasDeepProperty,
  hasEncryption,
  hasProperty,
  hashStringToNumber,
  isBulkWriteConflictError,
  isFindOneByIdQuery,
  isFolderPath,
  isMaybeReadonlyArray,
  isOneItemOfArrayInOtherArray,
  isPromise,
  isRxQuery,
  isSelectorSatisfiedByIndex,
  jsSha256,
  lastCharOfString,
  lastOfArray,
  maxOfNumbers,
  mergeMap,
  nameFunction,
  nativeSha256,
  newRxError,
  newRxTypeError,
  nextTick,
  normalizeMangoQuery,
  normalizeRxJsonSchema,
  normalizeString,
  now,
  objectPathMonad,
  observeSingle,
  overwritable,
  overwriteGetterForCaching,
  parseRevision,
  pluginMissing,
  prepareQuery,
  promiseSeries,
  promiseWait,
  queryCollection,
  randomCouchString,
  randomDelayStorage,
  randomOfArray,
  rateQueryPlan,
  removeOneFromArrayIfMatches,
  requestIdleCallbackIfAvailable,
  requestIdlePromise,
  requestIdlePromiseNoQueue,
  runAsyncPluginHooks,
  runPluginHooks,
  runQueryUpdateFunction,
  runXTimes,
  rxChangeEventToEventReduceChangeEvent,
  rxStorageWriteErrorToRxError,
  setProperty,
  shuffleArray,
  sortByObjectNumberProperty,
  sortDocumentsByLastWriteTime,
  sortObject,
  stackCheckpoints,
  stringToArrayBuffer,
  stripAttachmentsDataFromDocument,
  stripAttachmentsDataFromRow,
  stripMetaDataFromDocument,
  sumNumberArray,
  tap,
  throwIfIsStorageWriteError,
  toArray,
  toPromise,
  toWithDeleted,
  triggerCacheReplacement,
  trimDots,
  tunnelQueryCache,
  ucfirst,
  uncacheRxQuery,
  uniqueArray,
  writeSingle
} from "./chunk-VKSJYA3F.js";
import "./chunk-EQCVQC35.js";

// ../../node_modules/rxdb/dist/esm/custom-index.js
function getIndexMeta(schema, index) {
  var fieldNameProperties = index.map((fieldName) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    if (!schemaPart) {
      throw new Error("not in schema: " + fieldName);
    }
    var type = schemaPart.type;
    var parsedLengths;
    if (type === "number" || type === "integer") {
      parsedLengths = getStringLengthOfIndexNumber(schemaPart);
    }
    var getValue = objectPathMonad(fieldName);
    var maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;
    var getIndexStringPart;
    if (type === "string") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        if (!fieldValue) {
          fieldValue = "";
        }
        return fieldValue.padEnd(maxLength, " ");
      };
    } else if (type === "boolean") {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return fieldValue ? "1" : "0";
      };
    } else {
      getIndexStringPart = (docData) => {
        var fieldValue = getValue(docData);
        return getNumberIndexString(parsedLengths, fieldValue);
      };
    }
    var ret = {
      fieldName,
      schemaPart,
      parsedLengths,
      getValue,
      getIndexStringPart
    };
    return ret;
  });
  return fieldNameProperties;
}
function getIndexableStringMonad(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var fieldNamePropertiesAmount = fieldNameProperties.length;
  var indexPartsFunctions = fieldNameProperties.map((r) => r.getIndexStringPart);
  var ret = function(docData) {
    var str = "";
    for (var i = 0; i < fieldNamePropertiesAmount; ++i) {
      str += indexPartsFunctions[i](docData);
    }
    return str;
  };
  return ret;
}
function getStringLengthOfIndexNumber(schemaPart) {
  var minimum = Math.floor(schemaPart.minimum);
  var maximum = Math.ceil(schemaPart.maximum);
  var multipleOf = schemaPart.multipleOf;
  var valueSpan = maximum - minimum;
  var nonDecimals = valueSpan.toString().length;
  var multipleOfParts = multipleOf.toString().split(".");
  var decimals = 0;
  if (multipleOfParts.length > 1) {
    decimals = multipleOfParts[1].length;
  }
  return {
    minimum,
    maximum,
    nonDecimals,
    decimals,
    roundedMinimum: minimum
  };
}
function getIndexStringLength(schema, index) {
  var fieldNameProperties = getIndexMeta(schema, index);
  var length = 0;
  fieldNameProperties.forEach((props) => {
    var schemaPart = props.schemaPart;
    var type = schemaPart.type;
    if (type === "string") {
      length += schemaPart.maxLength;
    } else if (type === "boolean") {
      length += 1;
    } else {
      var parsedLengths = props.parsedLengths;
      length = length + parsedLengths.nonDecimals + parsedLengths.decimals;
    }
  });
  return length;
}
function getPrimaryKeyFromIndexableString(indexableString, primaryKeyLength) {
  var paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);
  var primaryKey = paddedPrimaryKey.trim();
  return primaryKey;
}
function getNumberIndexString(parsedLengths, fieldValue) {
  if (typeof fieldValue === "undefined") {
    fieldValue = 0;
  }
  if (fieldValue < parsedLengths.minimum) {
    fieldValue = parsedLengths.minimum;
  }
  if (fieldValue > parsedLengths.maximum) {
    fieldValue = parsedLengths.maximum;
  }
  var nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();
  var str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, "0");
  if (parsedLengths.decimals > 0) {
    var splitByDecimalPoint = fieldValue.toString().split(".");
    var decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : "0";
    str += decimalValueAsString.padEnd(parsedLengths.decimals, "0");
  }
  return str;
}
function getStartIndexStringFromLowerBound(schema, index, lowerBound) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    var bound = lowerBound[idx];
    var type = schemaPart.type;
    switch (type) {
      case "string":
        var maxLength = ensureNotFalsy(schemaPart.maxLength, "maxLength not set");
        if (typeof bound === "string") {
          str += bound.padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, " ");
        }
        break;
      case "boolean":
        if (bound === null) {
          str += "0";
        } else if (bound === INDEX_MIN) {
          str += "0";
        } else if (bound === INDEX_MAX) {
          str += "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === INDEX_MIN) {
          var fillChar = "0";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else if (bound === INDEX_MAX) {
          str += getNumberIndexString(parsedLengths, parsedLengths.maximum);
        } else {
          var add = getNumberIndexString(parsedLengths, bound);
          str += add;
        }
        break;
      default:
        throw new Error("unknown index type " + type);
    }
  });
  return str;
}
function getStartIndexStringFromUpperBound(schema, index, upperBound) {
  var str = "";
  index.forEach((fieldName, idx) => {
    var schemaPart = getSchemaByObjectPath(schema, fieldName);
    var bound = upperBound[idx];
    var type = schemaPart.type;
    switch (type) {
      case "string":
        var maxLength = ensureNotFalsy(schemaPart.maxLength, "maxLength not set");
        if (typeof bound === "string" && bound !== INDEX_MAX) {
          str += bound.padEnd(maxLength, " ");
        } else if (bound === INDEX_MIN) {
          str += "".padEnd(maxLength, " ");
        } else {
          str += "".padEnd(maxLength, INDEX_MAX);
        }
        break;
      case "boolean":
        if (bound === null) {
          str += "1";
        } else {
          var boolToStr = bound ? "1" : "0";
          str += boolToStr;
        }
        break;
      case "number":
      case "integer":
        var parsedLengths = getStringLengthOfIndexNumber(schemaPart);
        if (bound === null || bound === INDEX_MAX) {
          var fillChar = "9";
          str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else if (bound === INDEX_MIN) {
          var _fillChar = "0";
          str += _fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);
        } else {
          str += getNumberIndexString(parsedLengths, bound);
        }
        break;
      default:
        throw new Error("unknown index type " + type);
    }
  });
  return str;
}
function changeIndexableStringByOneQuantum(str, direction) {
  var lastChar = str.slice(-1);
  var charCode = lastChar.charCodeAt(0);
  charCode = charCode + direction;
  var withoutLastChar = str.slice(0, -1);
  return withoutLastChar + String.fromCharCode(charCode);
}

// ../../node_modules/rxdb/dist/esm/plugin-helpers.js
var VALIDATOR_CACHE_BY_VALIDATOR_KEY = /* @__PURE__ */ new Map();
function wrappedValidateStorageFactory(getValidator, validatorKey) {
  var VALIDATOR_CACHE = getFromMapOrCreate(VALIDATOR_CACHE_BY_VALIDATOR_KEY, validatorKey, () => /* @__PURE__ */ new Map());
  function initValidator(schema) {
    return getFromMapOrCreate(VALIDATOR_CACHE, JSON.stringify(schema), () => getValidator(schema));
  }
  return (args) => {
    return Object.assign({}, args.storage, {
      async createStorageInstance(params) {
        var instance = await args.storage.createStorageInstance(params);
        var primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);
        var validatorCached;
        requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));
        var oldBulkWrite = instance.bulkWrite.bind(instance);
        instance.bulkWrite = (documentWrites, context) => {
          if (!validatorCached) {
            validatorCached = initValidator(params.schema);
          }
          var errors = [];
          var continueWrites = [];
          documentWrites.forEach((row) => {
            var documentId = row.document[primaryPath];
            var validationErrors = validatorCached(row.document);
            if (validationErrors.length > 0) {
              errors.push({
                status: 422,
                isError: true,
                documentId,
                writeRow: row,
                validationErrors
              });
            } else {
              continueWrites.push(row);
            }
          });
          var writePromise = continueWrites.length > 0 ? oldBulkWrite(continueWrites, context) : Promise.resolve({
            error: [],
            success: []
          });
          return writePromise.then((writeResult) => {
            errors.forEach((validationError) => {
              writeResult.error.push(validationError);
            });
            return writeResult;
          });
        };
        return instance;
      }
    });
  };
}
function wrapRxStorageInstance(originalSchema, instance, modifyToStorage, modifyFromStorage, modifyAttachmentFromStorage = (v) => v) {
  async function toStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyToStorage(docData);
  }
  async function fromStorage(docData) {
    if (!docData) {
      return docData;
    }
    return await modifyFromStorage(docData);
  }
  async function errorFromStorage(error) {
    var ret = flatClone(error);
    ret.writeRow = flatClone(ret.writeRow);
    if (ret.documentInDb) {
      ret.documentInDb = await fromStorage(ret.documentInDb);
    }
    if (ret.writeRow.previous) {
      ret.writeRow.previous = await fromStorage(ret.writeRow.previous);
    }
    ret.writeRow.document = await fromStorage(ret.writeRow.document);
    return ret;
  }
  var processingChangesCount$ = new BehaviorSubject(0);
  var wrappedInstance = {
    databaseName: instance.databaseName,
    internals: instance.internals,
    cleanup: instance.cleanup.bind(instance),
    options: instance.options,
    close: instance.close.bind(instance),
    schema: originalSchema,
    collectionName: instance.collectionName,
    count: instance.count.bind(instance),
    remove: instance.remove.bind(instance),
    originalStorageInstance: instance,
    bulkWrite: async (documentWrites, context) => {
      var useRows = [];
      await Promise.all(documentWrites.map(async (row) => {
        var [previous, document] = await Promise.all([row.previous ? toStorage(row.previous) : void 0, toStorage(row.document)]);
        useRows.push({
          previous,
          document
        });
      }));
      var writeResult = await instance.bulkWrite(useRows, context);
      var ret = {
        error: []
      };
      var promises = [];
      writeResult.error.forEach((error) => {
        promises.push(errorFromStorage(error).then((err) => ret.error.push(err)));
      });
      await Promise.all(promises);
      await firstValueFrom(processingChangesCount$.pipe(filter((v) => v === 0)));
      return ret;
    },
    query: (preparedQuery) => {
      return instance.query(preparedQuery).then((queryResult) => {
        return Promise.all(queryResult.documents.map((doc) => fromStorage(doc)));
      }).then((documents) => ({
        documents
      }));
    },
    getAttachmentData: async (documentId, attachmentId, digest) => {
      var data = await instance.getAttachmentData(documentId, attachmentId, digest);
      data = await modifyAttachmentFromStorage(data);
      return data;
    },
    findDocumentsById: (ids, deleted) => {
      return instance.findDocumentsById(ids, deleted).then(async (findResult) => {
        var ret = [];
        await Promise.all(findResult.map(async (doc) => {
          ret.push(await fromStorage(doc));
        }));
        return ret;
      });
    },
    getChangedDocumentsSince: !instance.getChangedDocumentsSince ? void 0 : (limit, checkpoint) => {
      return instance.getChangedDocumentsSince(limit, checkpoint).then(async (result) => {
        return {
          checkpoint: result.checkpoint,
          documents: await Promise.all(result.documents.map((d) => fromStorage(d)))
        };
      });
    },
    changeStream: () => {
      return instance.changeStream().pipe(tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)), mergeMap(async (eventBulk) => {
        var useEvents = await Promise.all(eventBulk.events.map(async (event) => {
          var [documentData, previousDocumentData] = await Promise.all([fromStorage(event.documentData), fromStorage(event.previousDocumentData)]);
          var ev = {
            operation: event.operation,
            documentId: event.documentId,
            documentData,
            previousDocumentData,
            isLocal: false
          };
          return ev;
        }));
        var ret = {
          id: eventBulk.id,
          events: useEvents,
          checkpoint: eventBulk.checkpoint,
          context: eventBulk.context,
          startTime: eventBulk.startTime,
          endTime: eventBulk.endTime
        };
        return ret;
      }), tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1)));
    },
    conflictResultionTasks: () => {
      return instance.conflictResultionTasks().pipe(mergeMap(async (task) => {
        var assumedMasterState = await fromStorage(task.input.assumedMasterState);
        var newDocumentState = await fromStorage(task.input.newDocumentState);
        var realMasterState = await fromStorage(task.input.realMasterState);
        return {
          id: task.id,
          context: task.context,
          input: {
            assumedMasterState,
            realMasterState,
            newDocumentState
          }
        };
      }));
    },
    resolveConflictResultionTask: (taskSolution) => {
      if (taskSolution.output.isEqual) {
        return instance.resolveConflictResultionTask(taskSolution);
      }
      var useSolution = {
        id: taskSolution.id,
        output: {
          isEqual: false,
          documentData: taskSolution.output.documentData
        }
      };
      return instance.resolveConflictResultionTask(useSolution);
    }
  };
  return wrappedInstance;
}
export {
  BROADCAST_CHANNEL_BY_TOKEN,
  COLLECTIONS_WITH_RUNNING_CLEANUP,
  DEFAULT_CHECKPOINT_SCHEMA,
  DEFAULT_TRY_TO_KEEP_MAX,
  DEFAULT_UNEXECUTED_LIFETIME,
  HOOKS,
  INDEX_MAX,
  INDEX_MIN,
  INTERNAL_CONTEXT_COLLECTION,
  INTERNAL_CONTEXT_MIGRATION_STATUS,
  INTERNAL_CONTEXT_STORAGE_TOKEN,
  INTERNAL_STORAGE_NAME,
  INTERNAL_STORE_SCHEMA,
  INTERNAL_STORE_SCHEMA_TITLE,
  LOGICAL_OPERATORS,
  LOWER_BOUND_LOGICAL_OPERATORS,
  META_INSTANCE_SCHEMA_TITLE,
  PREMIUM_FLAG_HASH,
  PROMISE_RESOLVE_FALSE,
  PROMISE_RESOLVE_NULL,
  PROMISE_RESOLVE_TRUE,
  PROMISE_RESOLVE_VOID,
  QueryCache,
  RANDOM_STRING,
  REGEX_ALL_DOTS,
  REGEX_ALL_PIPES,
  RXDB_UTILS_GLOBAL,
  RXDB_VERSION,
  RXJS_SHARE_REPLAY_DEFAULTS,
  RX_DATABASE_LOCAL_DOCS_STORAGE_NAME,
  RX_META_LWT_MINIMUM,
  RX_META_SCHEMA,
  RxCollectionBase,
  RxDatabaseBase,
  RxError,
  RxQueryBase,
  RxQuerySingleResult,
  RxSchema,
  RxTypeError,
  STORAGE_TOKEN_DOCUMENT_ID,
  STORAGE_TOKEN_DOCUMENT_KEY,
  UPPER_BOUND_LOGICAL_OPERATORS,
  _clearHook,
  _collectionNamePrimary,
  _getDefaultQuery,
  addConnectedStorageToCollection,
  addRxPlugin,
  addRxStorageMultiInstanceSupport,
  appendToArray,
  areRxDocumentArraysEqual,
  arrayBufferToBase64,
  arrayBufferToString,
  arrayFilterNotEmpty,
  asyncFilter,
  attachmentWriteDataToNormalData,
  awaitRxStorageReplicationFirstInSync,
  awaitRxStorageReplicationIdle,
  awaitRxStorageReplicationInSync,
  b64DecodeUnicode,
  b64EncodeUnicode,
  base64ToArrayBuffer,
  basePrototype,
  batchArray,
  beforeDocumentUpdateWrite,
  blobToBase64String,
  blobToString,
  canUseCryptoSubtle,
  cancelRxStorageReplication,
  categorizeBulkWriteRows,
  changeIndexableStringByOneQuantum,
  clone,
  countRxQuerySubscribers,
  countUntilNotMatching,
  createBlob,
  createBlobFromBase64,
  createNewRxDocument,
  createQueryCache,
  createRevision,
  createRxCollection,
  createRxCollectionStorageInstance,
  createRxDatabase,
  createRxDatabaseStorageInstance,
  createRxDocumentConstructor,
  createRxQuery,
  createRxSchema,
  createWithConstructor,
  dbCount,
  deepEqual,
  deepFreeze,
  deepKeys,
  defaultCacheReplacementPolicy,
  defaultCacheReplacementPolicyMonad,
  defaultConflictHandler,
  defaultHashSha256,
  deleteProperty,
  docStateToWriteDoc,
  ensureInteger,
  ensureNoStartupErrors,
  ensureNotFalsy,
  ensureRxCollectionIsNotDestroyed,
  ensureRxStorageInstanceParamsAreCorrect,
  ensureStorageTokenDocumentExists,
  errorToPlainJson,
  errorUrlHint,
  fillObjectDataBeforeInsert,
  fillObjectWithDefaults,
  fillPrimaryKey,
  fillWithDefaultSettings,
  firstPropertyNameOfObject,
  firstPropertyValueOfObject,
  flatClone,
  flatCloneDocWithMeta,
  flattenEvents,
  flattenObject,
  getAllCollectionDocuments,
  getAssumedMasterState,
  getAttachmentSize,
  getBlobSize,
  getBroadcastChannelReference,
  getChangedDocumentsSince,
  getChangedDocumentsSinceQuery,
  getCheckpointKey,
  getComposedPrimaryKeyOfDocumentData,
  getDefaultIndex,
  getDefaultRevision,
  getDefaultRxDocumentMeta,
  getDocumentDataOfRxChangeEvent,
  getDocumentOrmPrototype,
  getDocumentPrototype,
  getErrorUrl,
  getFinalFields,
  getFromMapOrCreate,
  getFromMapOrThrow,
  getFromObjectOrThrow,
  getHeightOfRevision,
  getIndexMeta,
  getIndexStringLength,
  getIndexableStringMonad,
  getIndexes,
  getLastCheckpointDoc,
  getLengthOfPrimaryKey,
  getMatcherQueryOpts,
  getMetaWriteRow,
  getNumberIndexString,
  getPreviousVersions,
  getPrimaryFieldOfPrimaryKey,
  getPrimaryKeyFromIndexableString,
  getPrimaryKeyOfInternalDocument,
  getProperty,
  getPseudoSchemaForVersion,
  getQueryMatcher,
  getQueryPlan,
  getRxDocumentConstructor,
  getRxReplicationMetaInstanceSchema,
  getSchemaByObjectPath,
  getSingleDocument,
  getSortComparator,
  getSortDocumentsByLastWriteTimeComparator,
  getStartIndexStringFromLowerBound,
  getStartIndexStringFromUpperBound,
  getStringLengthOfIndexNumber,
  getUnderlyingPersistentStorage,
  getWrappedStorageInstance,
  getWrittenDocumentsFromBulkWriteResponse,
  hasDeepProperty,
  hasEncryption,
  hasProperty,
  hashStringToNumber,
  isBulkWriteConflictError,
  isDatabaseStateVersionCompatibleWithDatabaseCode,
  isFindOneByIdQuery,
  isFolderPath,
  isMaybeReadonlyArray,
  isOneItemOfArrayInOtherArray,
  isPromise,
  isRxCollection,
  isRxDatabase,
  isRxDatabaseFirstTimeInstantiated,
  isRxDocument,
  isRxQuery,
  isRxSchema,
  isSelectorSatisfiedByIndex,
  jsSha256,
  lastCharOfString,
  lastOfArray,
  maxOfNumbers,
  nameFunction,
  nativeSha256,
  newRxError,
  newRxTypeError,
  nextTick,
  normalizeMangoQuery,
  normalizeRxJsonSchema,
  normalizeString,
  now,
  objectPathMonad,
  observeSingle,
  overwritable,
  overwriteGetterForCaching,
  parseRevision,
  pluginMissing,
  prepareQuery,
  promiseSeries,
  promiseWait,
  queryCollection,
  randomCouchString,
  randomDelayStorage,
  randomOfArray,
  rateQueryPlan,
  removeBroadcastChannelReference,
  removeCollectionStorages,
  removeConnectedStorageFromCollection,
  removeOneFromArrayIfMatches,
  removeRxDatabase,
  replicateRxStorageInstance,
  requestIdleCallbackIfAvailable,
  requestIdlePromise,
  requestIdlePromiseNoQueue,
  resolveConflictError,
  runAsyncPluginHooks,
  runPluginHooks,
  runQueryUpdateFunction,
  runXTimes,
  rxChangeEventToEventReduceChangeEvent,
  rxStorageInstanceToReplicationHandler,
  rxStorageWriteErrorToRxError,
  setCheckpoint,
  setProperty,
  shuffleArray,
  sortByObjectNumberProperty,
  sortDocumentsByLastWriteTime,
  sortObject,
  stackCheckpoints,
  startReplicationDownstream,
  startReplicationUpstream,
  stringToArrayBuffer,
  stripAttachmentsDataFromDocument,
  stripAttachmentsDataFromMetaWriteRows,
  stripAttachmentsDataFromRow,
  stripMetaDataFromDocument,
  sumNumberArray,
  throwIfIsStorageWriteError,
  toArray,
  toPromise,
  toTypedRxJsonSchema,
  toWithDeleted,
  triggerCacheReplacement,
  trimDots,
  tunnelQueryCache,
  ucfirst,
  uncacheRxQuery,
  uniqueArray,
  wrapRxStorageInstance,
  wrappedValidateStorageFactory,
  writeDocToDocState,
  writeSingle
};
//# sourceMappingURL=rxdb.js.map
