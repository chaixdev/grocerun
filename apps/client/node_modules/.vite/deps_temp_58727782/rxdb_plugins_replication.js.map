{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/plugins/leader-election/index.ts", "../../../../../node_modules/rxdb/src/plugins/replication/replication-helper.ts", "../../../../../node_modules/rxdb/src/plugins/replication/index.ts"],
  "sourcesContent": ["/**\n * this plugin adds the leader-election-capabilities to rxdb\n */\n\nimport {\n    createLeaderElection,\n    LeaderElector,\n    BroadcastChannel\n} from 'broadcast-channel';\nimport {\n    getBroadcastChannelReference,\n    removeBroadcastChannelReference\n} from '../../rx-storage-multiinstance.ts';\n\nimport type {\n    RxDatabase,\n    RxPlugin\n} from '../../types/index.d.ts';\nimport { PROMISE_RESOLVE_TRUE, getFromMapOrCreate } from '../utils/index.ts';\n\nconst LEADER_ELECTORS_OF_DB: WeakMap<RxDatabase, LeaderElector> = new WeakMap();\nconst LEADER_ELECTOR_BY_BROADCAST_CHANNEL: WeakMap<BroadcastChannel, LeaderElector> = new WeakMap();\n\n\n/**\n * Returns the leader elector of a broadcast channel.\n * Used to ensure we reuse the same elector for the channel each time.\n */\nexport function getLeaderElectorByBroadcastChannel(broadcastChannel: BroadcastChannel): LeaderElector {\n    return getFromMapOrCreate(\n        LEADER_ELECTOR_BY_BROADCAST_CHANNEL,\n        broadcastChannel,\n        () => createLeaderElection(broadcastChannel)\n    );\n}\n\n/**\n * @overwrites RxDatabase().leaderElector for caching\n */\nexport function getForDatabase(this: RxDatabase): LeaderElector {\n    const broadcastChannel = getBroadcastChannelReference(\n        this.storage.name,\n        this.token,\n        this.name,\n        this\n    );\n\n    /**\n     * Clean up the reference on RxDatabase.destroy()\n     */\n    const oldDestroy = this.destroy.bind(this);\n    this.destroy = function () {\n        removeBroadcastChannelReference(this.token, this);\n        return oldDestroy();\n    };\n\n\n    let elector = getLeaderElectorByBroadcastChannel(broadcastChannel);\n    if (!elector) {\n        elector = getLeaderElectorByBroadcastChannel(broadcastChannel);\n        LEADER_ELECTORS_OF_DB.set(\n            this,\n            elector\n        );\n    }\n\n    /**\n     * Overwrite for caching\n     */\n    this.leaderElector = () => elector;\n\n    return elector;\n}\n\nexport function isLeader(this: RxDatabase): boolean {\n    if (!this.multiInstance) {\n        return true;\n    }\n    return this.leaderElector().isLeader;\n}\n\nexport function waitForLeadership(this: RxDatabase): Promise<boolean> {\n    if (!this.multiInstance) {\n        return PROMISE_RESOLVE_TRUE;\n    } else {\n        return this.leaderElector()\n            .awaitLeadership()\n            .then(() => true);\n    }\n}\n\n/**\n * runs when the database gets destroyed\n */\nexport function onDestroy(db: RxDatabase) {\n    const has = LEADER_ELECTORS_OF_DB.get(db);\n    if (has) {\n        has.die();\n    }\n}\n\nexport const rxdb = true;\nexport const prototypes = {\n    RxDatabase: (proto: any) => {\n        proto.leaderElector = getForDatabase;\n        proto.isLeader = isLeader;\n        proto.waitForLeadership = waitForLeadership;\n    }\n};\n\nexport const RxDBLeaderElectionPlugin: RxPlugin = {\n    name: 'leader-election',\n    rxdb,\n    prototypes,\n    hooks: {\n        preDestroyRxDatabase: {\n            after: onDestroy\n        }\n    }\n};\n", "import type {\n    RxCollection,\n    WithDeleted\n} from '../../types/index.d.ts';\nimport { flatClone } from '../../plugins/utils/index.ts';\nimport { getComposedPrimaryKeyOfDocumentData } from '../../rx-schema-helper.ts';\n\n// does nothing\nexport const DEFAULT_MODIFIER = (d: any) => Promise.resolve(d);\n\n\nexport function swapDefaultDeletedTodeletedField<RxDocType>(\n    deletedField: string,\n    doc: WithDeleted<RxDocType>\n): RxDocType {\n    if (deletedField === '_deleted') {\n        return doc;\n    } else {\n        doc = flatClone(doc);\n        const isDeleted = !!doc._deleted;\n        (doc as any)[deletedField] = isDeleted;\n        delete (doc as any)._deleted;\n        return doc;\n    }\n}\n\n/**\n * Must be run over all plain document data\n * that was pulled from the remote.\n * Used to fill up fields or modify the deleted field etc.\n */\nexport function handlePulledDocuments<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    deletedField: string,\n    docs: RxDocType[]\n): WithDeleted<RxDocType>[] {\n    return docs.map(doc => {\n        const useDoc: WithDeleted<RxDocType> = flatClone(doc) as any;\n\n        /**\n         * Swap out the deleted field\n         */\n        if (deletedField !== '_deleted') {\n            const isDeleted = !!(useDoc as any)[deletedField];\n            (useDoc as any)._deleted = isDeleted;\n            delete (useDoc as any)[deletedField];\n        } else {\n            // ensure we have a boolean.\n            useDoc._deleted = !!useDoc._deleted;\n        }\n\n        /**\n         * Fill up composed primary\n         */\n        const primaryPath = collection.schema.primaryPath;\n        (useDoc as any)[primaryPath] = getComposedPrimaryKeyOfDocumentData(\n            collection.schema.jsonSchema,\n            useDoc\n        );\n        return useDoc as any;\n    });\n}\n\n\n/**\n * Like normal promiseWait()\n * but will skip the wait time if the online-state changes.\n */\nexport function awaitRetry(\n    collection: RxCollection,\n    retryTime: number\n) {\n    if (\n        typeof window === 'undefined' ||\n        typeof window !== 'object' ||\n        typeof window.addEventListener === 'undefined' ||\n        navigator.onLine\n    ) {\n        return collection.promiseWait(retryTime);\n    }\n\n    let listener: any;\n    const onlineAgain = new Promise<void>(res => {\n        listener = () => {\n            window.removeEventListener('online', listener);\n            res();\n        };\n        window.addEventListener('online', listener);\n    });\n\n    return Promise.race([\n        onlineAgain,\n        collection.promiseWait(retryTime)\n    ]).then(() => {\n        window.removeEventListener('online', listener);\n    });\n}\n", "/**\n * This plugin contains the primitives to create\n * a RxDB client-server replication.\n * It is used in the other replication plugins\n * but also can be used as standalone with a custom replication handler.\n */\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    mergeMap,\n    Observable,\n    Subject,\n    Subscription\n} from 'rxjs';\nimport type {\n    ReplicationOptions,\n    ReplicationPullHandlerResult,\n    ReplicationPullOptions,\n    ReplicationPushOptions,\n    RxCollection,\n    RxDocumentData,\n    RxError,\n    RxJsonSchema,\n    RxReplicationPullStreamItem,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    RxTypeError,\n    WithDeleted\n} from '../../types/index.d.ts';\nimport { RxDBLeaderElectionPlugin } from '../leader-election/index.ts';\nimport {\n    arrayFilterNotEmpty,\n    ensureNotFalsy,\n    errorToPlainJson,\n    flatClone,\n    getFromMapOrCreate,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_TRUE,\n    toArray,\n    toPromise\n} from '../../plugins/utils/index.ts';\nimport {\n    awaitRxStorageReplicationFirstInSync,\n    awaitRxStorageReplicationInSync,\n    cancelRxStorageReplication,\n    getRxReplicationMetaInstanceSchema,\n    replicateRxStorageInstance\n} from '../../replication-protocol/index.ts';\nimport { newRxError } from '../../rx-error.ts';\nimport {\n    awaitRetry,\n    DEFAULT_MODIFIER,\n    swapDefaultDeletedTodeletedField,\n    handlePulledDocuments\n} from './replication-helper.ts';\nimport {\n    addConnectedStorageToCollection, removeConnectedStorageFromCollection\n} from '../../rx-database-internal-store.ts';\nimport { addRxPlugin } from '../../plugin.ts';\nimport { hasEncryption } from '../../rx-storage-helper.ts';\nimport { overwritable } from '../../overwritable.ts';\nimport {\n    runAsyncPluginHooks\n} from '../../hooks.ts';\n\n\nexport const REPLICATION_STATE_BY_COLLECTION: WeakMap<RxCollection, RxReplicationState<any, any>[]> = new WeakMap();\n\nexport class RxReplicationState<RxDocType, CheckpointType> {\n    public readonly subs: Subscription[] = [];\n    public readonly subjects = {\n        received: new Subject<RxDocumentData<RxDocType>>(), // all documents that are received from the endpoint\n        sent: new Subject<WithDeleted<RxDocType>>(), // all documents that are send to the endpoint\n        error: new Subject<RxError | RxTypeError>(), // all errors that are received from the endpoint, emits new Error() objects\n        canceled: new BehaviorSubject<boolean>(false), // true when the replication was canceled\n        active: new BehaviorSubject<boolean>(false) // true when something is running, false when not\n    };\n\n    readonly received$: Observable<RxDocumentData<RxDocType>> = this.subjects.received.asObservable();\n    readonly sent$: Observable<WithDeleted<RxDocType>> = this.subjects.sent.asObservable();\n    readonly error$: Observable<RxError | RxTypeError> = this.subjects.error.asObservable();\n    readonly canceled$: Observable<any> = this.subjects.canceled.asObservable();\n    readonly active$: Observable<boolean> = this.subjects.active.asObservable();\n\n    readonly metaInfoPromise: Promise<{ collectionName: string, schema: RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>> }>;\n\n    public startPromise: Promise<void>;\n\n    public onCancel: (() => void)[] = [];\n\n    constructor(\n        /**\n         * The identifier, used to flag revisions\n         * and to identify which documents state came from the remote.\n         */\n        public readonly replicationIdentifier: string,\n        public readonly collection: RxCollection<RxDocType>,\n        public readonly deletedField: string,\n        public readonly pull?: ReplicationPullOptions<RxDocType, CheckpointType>,\n        public readonly push?: ReplicationPushOptions<RxDocType>,\n        public readonly live?: boolean,\n        public retryTime?: number,\n        public autoStart?: boolean,\n    ) {\n        this.metaInfoPromise = (async () => {\n            const metaInstanceCollectionName = 'rx-replication-meta-' + await collection.database.hashFunction([\n                this.collection.name,\n                this.replicationIdentifier\n            ].join('-'));\n            const metaInstanceSchema = getRxReplicationMetaInstanceSchema(\n                this.collection.schema.jsonSchema,\n                hasEncryption(this.collection.schema.jsonSchema)\n            );\n            return {\n                collectionName: metaInstanceCollectionName,\n                schema: metaInstanceSchema\n            };\n        })();\n        const replicationStates = getFromMapOrCreate(\n            REPLICATION_STATE_BY_COLLECTION,\n            collection,\n            () => []\n        );\n        replicationStates.push(this);\n\n        // stop the replication when the collection gets destroyed\n        this.collection.onDestroy.push(() => this.cancel());\n\n        // create getters for the observables\n        Object.keys(this.subjects).forEach(key => {\n            Object.defineProperty(this, key + '$', {\n                get: function () {\n                    return this.subjects[key].asObservable();\n                }\n            });\n        });\n        const startPromise = new Promise<void>(res => {\n            this.callOnStart = res;\n        });\n        this.startPromise = startPromise;\n    }\n\n    private callOnStart: () => void = undefined as any;\n\n    public internalReplicationState?: RxStorageInstanceReplicationState<RxDocType>;\n    public metaInstance?: RxStorageInstance<RxStorageReplicationMeta<RxDocType, CheckpointType>, any, {}, any>;\n    public remoteEvents$: Subject<RxReplicationPullStreamItem<RxDocType, CheckpointType>> = new Subject();\n\n    public async start(): Promise<void> {\n        if (this.isStopped()) {\n            return;\n        }\n\n        // fill in defaults for pull & push\n        const pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;\n        const pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;\n\n        const database = this.collection.database;\n\n        const metaInfo = await this.metaInfoPromise;\n\n        const [metaInstance] = await Promise.all([\n            this.collection.database.storage.createStorageInstance<RxStorageReplicationMeta<RxDocType, CheckpointType>>({\n                databaseName: database.name,\n                collectionName: metaInfo.collectionName,\n                databaseInstanceToken: database.token,\n                multiInstance: database.multiInstance, // TODO is this always false?\n                options: {},\n                schema: metaInfo.schema,\n                password: database.password,\n                devMode: overwritable.isDevMode()\n            }),\n            addConnectedStorageToCollection(\n                this.collection,\n                metaInfo.collectionName,\n                metaInfo.schema\n            )\n        ]);\n        this.metaInstance = metaInstance;\n\n        this.internalReplicationState = replicateRxStorageInstance({\n            pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,\n            pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,\n            initialCheckpoint: {\n                upstream: this.push ? this.push.initialCheckpoint : undefined,\n                downstream: this.pull ? this.pull.initialCheckpoint : undefined\n            },\n            forkInstance: this.collection.storageInstance,\n            metaInstance: this.metaInstance,\n            hashFunction: database.hashFunction,\n            identifier: 'rxdbreplication' + this.replicationIdentifier,\n            conflictHandler: this.collection.conflictHandler,\n            replicationHandler: {\n                masterChangeStream$: this.remoteEvents$.asObservable().pipe(\n                    filter(_v => !!this.pull),\n                    mergeMap(async (ev) => {\n                        if (ev === 'RESYNC') {\n                            return ev;\n                        }\n                        const useEv = flatClone(ev);\n                        useEv.documents = handlePulledDocuments(this.collection, this.deletedField, useEv.documents);\n                        useEv.documents = await Promise.all(\n                            useEv.documents.map(d => pullModifier(d))\n                        );\n                        return useEv;\n                    })\n                ),\n                masterChangesSince: async (\n                    checkpoint: CheckpointType | undefined,\n                    batchSize: number\n                ) => {\n                    if (!this.pull) {\n                        return {\n                            checkpoint: null,\n                            documents: []\n                        };\n                    }\n                    /**\n                     * Retries must be done here in the replication primitives plugin,\n                     * because the replication protocol itself has no\n                     * error handling.\n                     */\n                    let done = false;\n                    let result: ReplicationPullHandlerResult<RxDocType, CheckpointType> = {} as any;\n                    while (!done && !this.isStopped()) {\n                        try {\n                            result = await this.pull.handler(\n                                checkpoint,\n                                batchSize\n                            );\n                            done = true;\n                        } catch (err: any | Error | Error[]) {\n                            const emitError = newRxError('RC_PULL', {\n                                checkpoint,\n                                errors: toArray(err).map(er => errorToPlainJson(er)),\n                                direction: 'pull'\n                            });\n                            this.subjects.error.next(emitError);\n                            await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n                        }\n                    }\n\n                    if (this.isStopped()) {\n                        return {\n                            checkpoint: null,\n                            documents: []\n                        };\n                    }\n\n                    const useResult = flatClone(result);\n                    useResult.documents = handlePulledDocuments(this.collection, this.deletedField, useResult.documents);\n                    useResult.documents = await Promise.all(\n                        useResult.documents.map(d => pullModifier(d))\n                    );\n                    return useResult;\n                },\n                masterWrite: async (\n                    rows: RxReplicationWriteToMasterRow<RxDocType>[]\n                ) => {\n                    if (!this.push) {\n                        return [];\n                    }\n                    let done = false;\n\n                    await runAsyncPluginHooks('preReplicationMasterWrite', {\n                        rows,\n                        collection: this.collection\n                    });\n\n                    const useRowsOrNull = await Promise.all(\n                        rows.map(async (row) => {\n                            row.newDocumentState = await pushModifier(row.newDocumentState);\n                            if (row.newDocumentState === null) {\n                                return null;\n                            }\n                            if (row.assumedMasterState) {\n                                row.assumedMasterState = await pushModifier(row.assumedMasterState);\n                            }\n                            if (this.deletedField !== '_deleted') {\n                                row.newDocumentState = swapDefaultDeletedTodeletedField(this.deletedField, row.newDocumentState) as any;\n                                if (row.assumedMasterState) {\n                                    row.assumedMasterState = swapDefaultDeletedTodeletedField(this.deletedField, row.assumedMasterState) as any;\n                                }\n                            }\n                            return row;\n                        })\n                    );\n                    const useRows: RxReplicationWriteToMasterRow<RxDocType>[] = useRowsOrNull.filter(arrayFilterNotEmpty);\n\n                    let result: WithDeleted<RxDocType>[] = null as any;\n\n                    // In case all the rows have been filtered and nothing has to be sent\n                    if (useRows.length === 0) {\n                        done = true;\n                        result = [];\n                    }\n\n                    while (!done && !this.isStopped()) {\n                        try {\n                            result = await this.push.handler(useRows);\n                            /**\n                             * It is a common problem that people have wrongly behaving backend\n                             * that do not return an array with the conflicts on push requests.\n                             * So we run this check here to make it easier to debug.\n                             * @link https://github.com/pubkey/rxdb/issues/4103\n                             */\n                            if (!Array.isArray(result)) {\n                                throw newRxError(\n                                    'RC_PUSH_NO_AR',\n                                    {\n                                        pushRows: rows,\n                                        direction: 'push',\n                                        args: { result }\n                                    }\n                                );\n                            }\n                            done = true;\n                        } catch (err: any | Error | Error[] | RxError) {\n                            const emitError = (err as RxError).rxdb ? err : newRxError('RC_PUSH', {\n                                pushRows: rows,\n                                errors: toArray(err).map(er => errorToPlainJson(er)),\n                                direction: 'push'\n                            });\n                            this.subjects.error.next(emitError);\n                            await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));\n                        }\n                    }\n                    if (this.isStopped()) {\n                        return [];\n                    }\n\n                    await runAsyncPluginHooks('preReplicationMasterWriteDocumentsHandle', {\n                        result,\n                        collection: this.collection\n                    });\n\n                    const conflicts = handlePulledDocuments(this.collection, this.deletedField, ensureNotFalsy(result));\n                    return conflicts;\n                }\n            }\n        });\n        this.subs.push(\n            this.internalReplicationState.events.error.subscribe(err => {\n                this.subjects.error.next(err);\n            }),\n            this.internalReplicationState.events.processed.down\n                .subscribe(row => this.subjects.received.next(row.document as any)),\n            this.internalReplicationState.events.processed.up\n                .subscribe(writeToMasterRow => {\n                    this.subjects.sent.next(writeToMasterRow.newDocumentState);\n                }),\n            combineLatest([\n                this.internalReplicationState.events.active.down,\n                this.internalReplicationState.events.active.up\n            ]).subscribe(([down, up]) => {\n                const isActive = down || up;\n                this.subjects.active.next(isActive);\n            })\n        );\n\n        if (\n            this.pull &&\n            this.pull.stream$ &&\n            this.live\n        ) {\n            this.subs.push(\n                this.pull.stream$.subscribe({\n                    next: ev => {\n                        this.remoteEvents$.next(ev);\n                    },\n                    error: err => {\n                        this.subjects.error.next(err);\n                    }\n                })\n            );\n        }\n\n        /**\n         * Non-live replications run once\n         * and then automatically get canceled.\n         */\n        if (!this.live) {\n            await awaitRxStorageReplicationFirstInSync(this.internalReplicationState);\n            await awaitRxStorageReplicationInSync(this.internalReplicationState);\n            await this.cancel();\n        }\n        this.callOnStart();\n    }\n\n    isStopped(): boolean {\n        if (this.subjects.canceled.getValue()) {\n            return true;\n        }\n        return false;\n    }\n\n    async awaitInitialReplication(): Promise<void> {\n        await this.startPromise;\n        return awaitRxStorageReplicationFirstInSync(\n            ensureNotFalsy(this.internalReplicationState)\n        );\n    }\n\n    /**\n     * Returns a promise that resolves when:\n     * - All local data is replicated with the remote\n     * - No replication cycle is running or in retry-state\n     *\n     * WARNING: USing this function directly in a multi-tab browser application\n     * is dangerous because only the leading instance will ever be replicated,\n     * so this promise will not resolve in the other tabs.\n     * For multi-tab support you should set and observe a flag in a local document.\n     */\n    async awaitInSync(): Promise<true> {\n        await this.startPromise;\n        await awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));\n\n        /**\n         * To reduce the amount of re-renders and make testing\n         * and to make the whole behavior more predictable,\n         * we await these things multiple times.\n         * For example the state might be in sync already and at the\n         * exact same time a pull.stream$ event comes in and we want to catch\n         * that in the same call to awaitInSync() instead of resolving\n         * while actually the state is not in sync.\n         */\n        let t = 2;\n        while (t > 0) {\n            t--;\n\n            /**\n             * Often awaitInSync() is called directly after a document write,\n             * like in the unit tests.\n             * So we first have to await the idleness to ensure that all RxChangeEvents\n             * are processed already.\n             */\n            await this.collection.database.requestIdlePromise();\n            await awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));\n        }\n\n        return true;\n    }\n\n    reSync() {\n        this.remoteEvents$.next('RESYNC');\n    }\n    emitEvent(ev: RxReplicationPullStreamItem<RxDocType, CheckpointType>) {\n        this.remoteEvents$.next(ev);\n    }\n\n    async cancel(): Promise<any> {\n        if (this.isStopped()) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        const promises: Promise<any>[] = this.onCancel.map(fn => toPromise(fn()));\n\n        if (this.internalReplicationState) {\n            await cancelRxStorageReplication(this.internalReplicationState);\n        }\n        if (this.metaInstance) {\n            promises.push(\n                ensureNotFalsy(this.internalReplicationState).checkpointQueue\n                    .then(() => ensureNotFalsy(this.metaInstance).close())\n            );\n        }\n\n        this.subs.forEach(sub => sub.unsubscribe());\n        this.subjects.canceled.next(true);\n\n        this.subjects.active.complete();\n        this.subjects.canceled.complete();\n        this.subjects.error.complete();\n        this.subjects.received.complete();\n        this.subjects.sent.complete();\n\n        return Promise.all(promises);\n    }\n\n    async remove() {\n        await ensureNotFalsy(this.metaInstance).remove();\n        const metaInfo = await this.metaInfoPromise;\n        await this.cancel();\n        await removeConnectedStorageFromCollection(\n            this.collection,\n            metaInfo.collectionName,\n            metaInfo.schema\n        );\n    }\n}\n\n\nexport function replicateRxCollection<RxDocType, CheckpointType>(\n    {\n        replicationIdentifier,\n        collection,\n        deletedField = '_deleted',\n        pull,\n        push,\n        live = true,\n        retryTime = 1000 * 5,\n        waitForLeadership = true,\n        autoStart = true,\n    }: ReplicationOptions<RxDocType, CheckpointType>\n): RxReplicationState<RxDocType, CheckpointType> {\n    addRxPlugin(RxDBLeaderElectionPlugin);\n\n    /**\n     * It is a common error to forget to add these config\n     * objects. So we check here because it makes no sense\n     * to start a replication with neither push nor pull.\n     */\n    if (!pull && !push) {\n        throw newRxError('UT3', {\n            collection: collection.name,\n            args: {\n                replicationIdentifier\n            }\n        });\n    }\n\n    const replicationState = new RxReplicationState<RxDocType, CheckpointType>(\n        replicationIdentifier,\n        collection,\n        deletedField,\n        pull,\n        push,\n        live,\n        retryTime,\n        autoStart\n    );\n\n\n    startReplicationOnLeaderShip(waitForLeadership, replicationState);\n    return replicationState as any;\n}\n\n\nexport function startReplicationOnLeaderShip(\n    waitForLeadership: boolean,\n    replicationState: RxReplicationState<any, any>\n) {\n    /**\n     * Always await this Promise to ensure that the current instance\n     * is leader when waitForLeadership=true\n     */\n    const mustWaitForLeadership = waitForLeadership && replicationState.collection.database.multiInstance;\n    const waitTillRun: Promise<any> = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;\n    return waitTillRun.then(() => {\n        if (replicationState.isStopped()) {\n            return;\n        }\n        if (replicationState.autoStart) {\n            replicationState.start();\n        }\n    });\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoBA,IAAMA,wBAA4D,oBAAIC,QAAQ;AAC9E,IAAMC,sCAAgF,oBAAID,QAAQ;AAO3F,SAASE,mCAAmCC,kBAAmD;AAClG,SAAOC,mBACHH,qCACAE,kBACA,MAAME,qBAAqBF,gBAAgB,CAC/C;AACJ;AAKO,SAASG,iBAAgD;AAC5D,MAAMH,mBAAmBI,6BACrB,KAAKC,QAAQC,MACb,KAAKC,OACL,KAAKD,MACL,IACJ;AAKA,MAAME,aAAa,KAAKC,QAAQC,KAAK,IAAI;AACzC,OAAKD,UAAU,WAAY;AACvBE,oCAAgC,KAAKJ,OAAO,IAAI;AAChD,WAAOC,WAAW;EACtB;AAGA,MAAII,UAAUb,mCAAmCC,gBAAgB;AACjE,MAAI,CAACY,SAAS;AACVA,cAAUb,mCAAmCC,gBAAgB;AAC7DJ,0BAAsBiB,IAClB,MACAD,OACJ;EACJ;AAKA,OAAKE,gBAAgB,MAAMF;AAE3B,SAAOA;AACX;AAEO,SAASG,WAAoC;AAChD,MAAI,CAAC,KAAKC,eAAe;AACrB,WAAO;EACX;AACA,SAAO,KAAKF,cAAc,EAAEC;AAChC;AAEO,SAASE,oBAAsD;AAClE,MAAI,CAAC,KAAKD,eAAe;AACrB,WAAOE;EACX,OAAO;AACH,WAAO,KAAKJ,cAAc,EACrBK,gBAAgB,EAChBC,KAAK,MAAM,IAAI;EACxB;AACJ;AAKO,SAASC,UAAUC,IAAgB;AACtC,MAAMC,MAAM3B,sBAAsB4B,IAAIF,EAAE;AACxC,MAAIC,KAAK;AACLA,QAAIE,IAAI;EACZ;AACJ;AAEO,IAAMC,OAAO;AACb,IAAMC,aAAa;EACtBC,YAAaC,WAAe;AACxBA,UAAMf,gBAAgBX;AACtB0B,UAAMd,WAAWA;AACjBc,UAAMZ,oBAAoBA;EAC9B;AACJ;AAEO,IAAMa,2BAAqC;EAC9CxB,MAAM;EACNoB;EACAC;EACAI,OAAO;IACHC,sBAAsB;MAClBC,OAAOZ;IACX;EACJ;AACJ;;;AC/GO,IAAMa,mBAAoBC,OAAWC,QAAQC,QAAQF,CAAC;AAGtD,SAASG,iCACZC,cACAC,KACS;AACT,MAAID,iBAAiB,YAAY;AAC7B,WAAOC;EACX,OAAO;AACHA,UAAMC,UAAUD,GAAG;AACnB,QAAME,YAAY,CAAC,CAACF,IAAIG;AACvBH,QAAYD,YAAY,IAAIG;AAC7B,WAAQF,IAAYG;AACpB,WAAOH;EACX;AACJ;AAOO,SAASI,sBACZC,YACAN,cACAO,MACwB;AACxB,SAAOA,KAAKC,IAAIP,SAAO;AACnB,QAAMQ,SAAiCP,UAAUD,GAAG;AAKpD,QAAID,iBAAiB,YAAY;AAC7B,UAAMG,YAAY,CAAC,CAAEM,OAAeT,YAAY;AAC/CS,aAAeL,WAAWD;AAC3B,aAAQM,OAAeT,YAAY;IACvC,OAAO;AAEHS,aAAOL,WAAW,CAAC,CAACK,OAAOL;IAC/B;AAKA,QAAMM,cAAcJ,WAAWK,OAAOD;AACrCD,WAAeC,WAAW,IAAIE,oCAC3BN,WAAWK,OAAOE,YAClBJ,MACJ;AACA,WAAOA;EACX,CAAC;AACL;AAOO,SAASK,WACZR,YACAS,WACF;AACE,MACI,OAAOC,WAAW,eAClB,OAAOA,WAAW,YAClB,OAAOA,OAAOC,qBAAqB,eACnCC,UAAUC,QACZ;AACE,WAAOb,WAAWc,YAAYL,SAAS;EAC3C;AAEA,MAAIM;AACJ,MAAMC,cAAc,IAAIzB,QAAc0B,SAAO;AACzCF,eAAWA,MAAM;AACbL,aAAOQ,oBAAoB,UAAUH,QAAQ;AAC7CE,UAAI;IACR;AACAP,WAAOC,iBAAiB,UAAUI,QAAQ;EAC9C,CAAC;AAED,SAAOxB,QAAQ4B,KAAK,CAChBH,aACAhB,WAAWc,YAAYL,SAAS,CAAC,CACpC,EAAEW,KAAK,MAAM;AACVV,WAAOQ,oBAAoB,UAAUH,QAAQ;EACjD,CAAC;AACL;;;AC1BO,IAAMM,kCAAyF,oBAAIC,QAAQ;AAElH,IAAaC,qBAAkB,WAAA;AAsB3B,WAAAA,oBAKoBC,uBACAC,YACAC,cACAC,MACAC,MACAC,MACTC,WACAC,WACT;AAAA,SAlCcC,OAAuB,CAAA;AAAE,SACzBC,WAAW;MACvBC,UAAU,IAAIC,QAAmC;;MACjDC,MAAM,IAAID,QAAgC;;MAC1CE,OAAO,IAAIF,QAA+B;;MAC1CG,UAAU,IAAIC,gBAAyB,KAAK;;MAC5CC,QAAQ,IAAID,gBAAyB,KAAK;;IAC9C;AAAC,SAEQE,YAAmD,KAAKR,SAASC,SAASQ,aAAa;AAAC,SACxFC,QAA4C,KAAKV,SAASG,KAAKM,aAAa;AAAC,SAC7EE,SAA4C,KAAKX,SAASI,MAAMK,aAAa;AAAC,SAC9EG,YAA6B,KAAKZ,SAASK,SAASI,aAAa;AAAC,SAClEI,UAA+B,KAAKb,SAASO,OAAOE,aAAa;AAAC,SAMpEK,WAA2B,CAAA;AAAE,SAsD5BC,cAA0BC;AAAS,SAIpCC,gBAAiF,IAAIf,QAAQ;AAAC,SAnDjFX,wBAAAA;AAA6B,SAC7BC,aAAAA;AAAmC,SACnCC,eAAAA;AAAoB,SACpBC,OAAAA;AAAwD,SACxDC,OAAAA;AAAwC,SACxCC,OAAAA;AAAc,SACvBC,YAAAA;AAAkB,SAClBC,YAAAA;AAEP,SAAKoB,mBAAmB,YAAY;AAChC,UAAMC,6BAA6B,yBAAyB,MAAM3B,WAAW4B,SAASC,aAAa,CAC/F,KAAK7B,WAAW8B,MAChB,KAAK/B,qBAAqB,EAC5BgC,KAAK,GAAG,CAAC;AACX,UAAMC,qBAAqBC,mCACvB,KAAKjC,WAAWkC,OAAOC,YACvBC,cAAc,KAAKpC,WAAWkC,OAAOC,UAAU,CACnD;AACA,aAAO;QACHE,gBAAgBV;QAChBO,QAAQF;MACZ;IACJ,GAAG;AACH,QAAMM,oBAAoBC,mBACtB3C,iCACAI,YACA,MAAM,CAAA,CACV;AACAsC,sBAAkBnC,KAAK,IAAI;AAG3B,SAAKH,WAAWwC,UAAUrC,KAAK,MAAM,KAAKsC,OAAO,CAAC;AAGlDC,WAAOC,KAAK,KAAKnC,QAAQ,EAAEoC,QAAQC,SAAO;AACtCH,aAAOI,eAAe,MAAMD,MAAM,KAAK;QACnCE,KAAK,WAAY;AACb,iBAAO,KAAKvC,SAASqC,GAAG,EAAE5B,aAAa;QAC3C;MACJ,CAAC;IACL,CAAC;AACD,QAAM+B,eAAe,IAAIC,QAAcC,SAAO;AAC1C,WAAK3B,cAAc2B;IACvB,CAAC;AACD,SAAKF,eAAeA;EACxB;AAAC,MAAAG,SAAArD,oBAAAsD;AAAAD,SAQYE,QAAb,eAAaA,QAAuB;AAChC,QAAI,KAAKC,UAAU,GAAG;AAClB;IACJ;AAGA,QAAMC,eAAe,KAAKrD,QAAQ,KAAKA,KAAKsD,WAAW,KAAKtD,KAAKsD,WAAWC;AAC5E,QAAMC,eAAe,KAAKvD,QAAQ,KAAKA,KAAKqD,WAAW,KAAKrD,KAAKqD,WAAWC;AAE5E,QAAM7B,WAAW,KAAK5B,WAAW4B;AAEjC,QAAM+B,WAAW,MAAM,KAAKjC;AAE5B,QAAM,CAACkC,YAAY,IAAI,MAAMX,QAAQY,IAAI,CACrC,KAAK7D,WAAW4B,SAASkC,QAAQC,sBAA2E;MACxGC,cAAcpC,SAASE;MACvBO,gBAAgBsB,SAAStB;MACzB4B,uBAAuBrC,SAASsC;MAChCC,eAAevC,SAASuC;;MACxBC,SAAS,CAAC;MACVlC,QAAQyB,SAASzB;MACjBmC,UAAUzC,SAASyC;MACnBC,SAASC,aAAaC,UAAU;IACpC,CAAC,GACDC,gCACI,KAAKzE,YACL2D,SAAStB,gBACTsB,SAASzB,MACb,CAAC,CACJ;AACD,SAAK0B,eAAeA;AAEpB,SAAKc,2BAA2BC,2BAA2B;MACvDC,eAAe,KAAKzE,QAAQ,KAAKA,KAAK0E,YAAY,KAAK1E,KAAK0E,YAAY;MACxEC,eAAe,KAAK5E,QAAQ,KAAKA,KAAK2E,YAAY,KAAK3E,KAAK2E,YAAY;MACxEE,mBAAmB;QACfC,UAAU,KAAK7E,OAAO,KAAKA,KAAK4E,oBAAoBvD;QACpDyD,YAAY,KAAK/E,OAAO,KAAKA,KAAK6E,oBAAoBvD;MAC1D;MACA0D,cAAc,KAAKlF,WAAWmF;MAC9BvB,cAAc,KAAKA;MACnB/B,cAAcD,SAASC;MACvBuD,YAAY,oBAAoB,KAAKrF;MACrCsF,iBAAiB,KAAKrF,WAAWqF;MACjCC,oBAAoB;QAChBC,qBAAqB,KAAK9D,cAAcR,aAAa,EAAEuE,KACnDC,OAAOC,QAAM,CAAC,CAAC,KAAKxF,IAAI,GACxByF,SAAS,OAAOC,OAAO;AACnB,cAAIA,OAAO,UAAU;AACjB,mBAAOA;UACX;AACA,cAAMC,QAAQC,UAAUF,EAAE;AAC1BC,gBAAME,YAAYC,sBAAsB,KAAKhG,YAAY,KAAKC,cAAc4F,MAAME,SAAS;AAC3FF,gBAAME,YAAY,MAAM9C,QAAQY,IAC5BgC,MAAME,UAAUE,IAAIC,OAAK3C,aAAa2C,CAAC,CAAC,CAC5C;AACA,iBAAOL;QACX,CAAC,CACL;QACAM,oBAAoB,OAChBC,YACAvB,cACC;AACD,cAAI,CAAC,KAAK3E,MAAM;AACZ,mBAAO;cACHkG,YAAY;cACZL,WAAW,CAAA;YACf;UACJ;AAMA,cAAIM,OAAO;AACX,cAAIC,SAAkE,CAAC;AACvE,iBAAO,CAACD,QAAQ,CAAC,KAAK/C,UAAU,GAAG;AAC/B,gBAAI;AACAgD,uBAAS,MAAM,KAAKpG,KAAKqG,QACrBH,YACAvB,SACJ;AACAwB,qBAAO;YACX,SAASG,KAA4B;AACjC,kBAAMC,YAAYC,WAAW,WAAW;gBACpCN;gBACAO,QAAQC,QAAQJ,GAAG,EAAEP,IAAIY,QAAMC,iBAAiBD,EAAE,CAAC;gBACnDE,WAAW;cACf,CAAC;AACD,mBAAKvG,SAASI,MAAMoG,KAAKP,SAAS;AAClC,oBAAMQ,WAAW,KAAKjH,YAAYkH,eAAe,KAAK7G,SAAS,CAAC;YACpE;UACJ;AAEA,cAAI,KAAKiD,UAAU,GAAG;AAClB,mBAAO;cACH8C,YAAY;cACZL,WAAW,CAAA;YACf;UACJ;AAEA,cAAMoB,YAAYrB,UAAUQ,MAAM;AAClCa,oBAAUpB,YAAYC,sBAAsB,KAAKhG,YAAY,KAAKC,cAAckH,UAAUpB,SAAS;AACnGoB,oBAAUpB,YAAY,MAAM9C,QAAQY,IAChCsD,UAAUpB,UAAUE,IAAIC,OAAK3C,aAAa2C,CAAC,CAAC,CAChD;AACA,iBAAOiB;QACX;QACAC,aAAa,OACTC,SACC;AACD,cAAI,CAAC,KAAKlH,MAAM;AACZ,mBAAO,CAAA;UACX;AACA,cAAIkG,OAAO;AAEX,gBAAMiB,oBAAoB,6BAA6B;YACnDD;YACArH,YAAY,KAAKA;UACrB,CAAC;AAED,cAAMuH,gBAAgB,MAAMtE,QAAQY,IAChCwD,KAAKpB,IAAI,OAAOuB,QAAQ;AACpBA,gBAAIC,mBAAmB,MAAM/D,aAAa8D,IAAIC,gBAAgB;AAC9D,gBAAID,IAAIC,qBAAqB,MAAM;AAC/B,qBAAO;YACX;AACA,gBAAID,IAAIE,oBAAoB;AACxBF,kBAAIE,qBAAqB,MAAMhE,aAAa8D,IAAIE,kBAAkB;YACtE;AACA,gBAAI,KAAKzH,iBAAiB,YAAY;AAClCuH,kBAAIC,mBAAmBE,iCAAiC,KAAK1H,cAAcuH,IAAIC,gBAAgB;AAC/F,kBAAID,IAAIE,oBAAoB;AACxBF,oBAAIE,qBAAqBC,iCAAiC,KAAK1H,cAAcuH,IAAIE,kBAAkB;cACvG;YACJ;AACA,mBAAOF;UACX,CAAC,CACL;AACA,cAAMI,UAAsDL,cAAc9B,OAAOoC,mBAAmB;AAEpG,cAAIvB,SAAmC;AAGvC,cAAIsB,QAAQE,WAAW,GAAG;AACtBzB,mBAAO;AACPC,qBAAS,CAAA;UACb;AAEA,iBAAO,CAACD,QAAQ,CAAC,KAAK/C,UAAU,GAAG;AAC/B,gBAAI;AACAgD,uBAAS,MAAM,KAAKnG,KAAKoG,QAAQqB,OAAO;AAOxC,kBAAI,CAACG,MAAMC,QAAQ1B,MAAM,GAAG;AACxB,sBAAMI,WACF,iBACA;kBACIuB,UAAUZ;kBACVN,WAAW;kBACXmB,MAAM;oBAAE5B;kBAAO;gBACnB,CACJ;cACJ;AACAD,qBAAO;YACX,SAASG,KAAsC;AAC3C,kBAAMC,YAAaD,IAAgB2B,OAAO3B,MAAME,WAAW,WAAW;gBAClEuB,UAAUZ;gBACVV,QAAQC,QAAQJ,GAAG,EAAEP,IAAIY,QAAMC,iBAAiBD,EAAE,CAAC;gBACnDE,WAAW;cACf,CAAC;AACD,mBAAKvG,SAASI,MAAMoG,KAAKP,SAAS;AAClC,oBAAMQ,WAAW,KAAKjH,YAAYkH,eAAe,KAAK7G,SAAS,CAAC;YACpE;UACJ;AACA,cAAI,KAAKiD,UAAU,GAAG;AAClB,mBAAO,CAAA;UACX;AAEA,gBAAMgE,oBAAoB,4CAA4C;YAClEhB;YACAtG,YAAY,KAAKA;UACrB,CAAC;AAED,cAAMoI,YAAYpC,sBAAsB,KAAKhG,YAAY,KAAKC,cAAciH,eAAeZ,MAAM,CAAC;AAClG,iBAAO8B;QACX;MACJ;IACJ,CAAC;AACD,SAAK7H,KAAKJ,KACN,KAAKuE,yBAAyB2D,OAAOzH,MAAM0H,UAAU9B,SAAO;AACxD,WAAKhG,SAASI,MAAMoG,KAAKR,GAAG;IAChC,CAAC,GACD,KAAK9B,yBAAyB2D,OAAOE,UAAUC,KAC1CF,UAAUd,SAAO,KAAKhH,SAASC,SAASuG,KAAKQ,IAAIiB,QAAe,CAAC,GACtE,KAAK/D,yBAAyB2D,OAAOE,UAAUG,GAC1CJ,UAAUK,sBAAoB;AAC3B,WAAKnI,SAASG,KAAKqG,KAAK2B,iBAAiBlB,gBAAgB;IAC7D,CAAC,GACLmB,cAAc,CACV,KAAKlE,yBAAyB2D,OAAOtH,OAAOyH,MAC5C,KAAK9D,yBAAyB2D,OAAOtH,OAAO2H,EAAE,CACjD,EAAEJ,UAAU,CAAC,CAACE,MAAME,EAAE,MAAM;AACzB,UAAMG,WAAWL,QAAQE;AACzB,WAAKlI,SAASO,OAAOiG,KAAK6B,QAAQ;IACtC,CAAC,CACL;AAEA,QACI,KAAK3I,QACL,KAAKA,KAAK4I,WACV,KAAK1I,MACP;AACE,WAAKG,KAAKJ,KACN,KAAKD,KAAK4I,QAAQR,UAAU;QACxBtB,MAAMpB,QAAM;AACR,eAAKnE,cAAcuF,KAAKpB,EAAE;QAC9B;QACAhF,OAAO4F,SAAO;AACV,eAAKhG,SAASI,MAAMoG,KAAKR,GAAG;QAChC;MACJ,CAAC,CACL;IACJ;AAMA,QAAI,CAAC,KAAKpG,MAAM;AACZ,YAAM2I,qCAAqC,KAAKrE,wBAAwB;AACxE,YAAMsE,gCAAgC,KAAKtE,wBAAwB;AACnE,YAAM,KAAKjC,OAAO;IACtB;AACA,SAAKlB,YAAY;EACrB;AAAC4B,SAEDG,YAAA,SAAAA,YAAqB;AACjB,QAAI,KAAK9C,SAASK,SAASoI,SAAS,GAAG;AACnC,aAAO;IACX;AACA,WAAO;EACX;AAAC9F,SAEK+F,0BAAN,eAAMA,0BAAyC;AAC3C,UAAM,KAAKlG;AACX,WAAO+F,qCACH7B,eAAe,KAAKxC,wBAAwB,CAChD;EACJ;AAEAvB,SAUMgG,cAAN,eAAMA,cAA6B;AAC/B,UAAM,KAAKnG;AACX,UAAM+F,qCAAqC7B,eAAe,KAAKxC,wBAAwB,CAAC;AAWxF,QAAI0E,IAAI;AACR,WAAOA,IAAI,GAAG;AACVA;AAQA,YAAM,KAAKpJ,WAAW4B,SAASyH,mBAAmB;AAClD,YAAML,gCAAgC9B,eAAe,KAAKxC,wBAAwB,CAAC;IACvF;AAEA,WAAO;EACX;AAACvB,SAEDmG,SAAA,SAAAA,SAAS;AACL,SAAK7H,cAAcuF,KAAK,QAAQ;EACpC;AAAC7D,SACDoG,YAAA,SAAAA,UAAU3D,IAA4D;AAClE,SAAKnE,cAAcuF,KAAKpB,EAAE;EAC9B;AAACzC,SAEKV,SAAN,eAAMA,SAAuB;AACzB,QAAI,KAAKa,UAAU,GAAG;AAClB,aAAOkG;IACX;AAEA,QAAMC,WAA2B,KAAKnI,SAAS2E,IAAIyD,QAAMC,UAAUD,GAAG,CAAC,CAAC;AAExE,QAAI,KAAKhF,0BAA0B;AAC/B,YAAMkF,2BAA2B,KAAKlF,wBAAwB;IAClE;AACA,QAAI,KAAKd,cAAc;AACnB6F,eAAStJ,KACL+G,eAAe,KAAKxC,wBAAwB,EAAEmF,gBACzCC,KAAK,MAAM5C,eAAe,KAAKtD,YAAY,EAAEmG,MAAM,CAAC,CAC7D;IACJ;AAEA,SAAKxJ,KAAKqC,QAAQoH,SAAOA,IAAIC,YAAY,CAAC;AAC1C,SAAKzJ,SAASK,SAASmG,KAAK,IAAI;AAEhC,SAAKxG,SAASO,OAAOmJ,SAAS;AAC9B,SAAK1J,SAASK,SAASqJ,SAAS;AAChC,SAAK1J,SAASI,MAAMsJ,SAAS;AAC7B,SAAK1J,SAASC,SAASyJ,SAAS;AAChC,SAAK1J,SAASG,KAAKuJ,SAAS;AAE5B,WAAOjH,QAAQY,IAAI4F,QAAQ;EAC/B;AAACtG,SAEKgH,SAAN,eAAMA,SAAS;AACX,UAAMjD,eAAe,KAAKtD,YAAY,EAAEuG,OAAO;AAC/C,QAAMxG,WAAW,MAAM,KAAKjC;AAC5B,UAAM,KAAKe,OAAO;AAClB,UAAM2H,qCACF,KAAKpK,YACL2D,SAAStB,gBACTsB,SAASzB,MACb;EACJ;AAAC,SAAApC;AAAA,EAAA;AAIE,SAASuK,sBACZ;EACItK;EACAC;EACAC,eAAe;EACfC;EACAC;EACAC,OAAO;EACPC,YAAY,MAAO;EACnBiK,mBAAAA,qBAAoB;EACpBhK,YAAY;AAC+B,GACF;AAC7CiK,cAAYC,wBAAwB;AAOpC,MAAI,CAACtK,QAAQ,CAACC,MAAM;AAChB,UAAMuG,WAAW,OAAO;MACpB1G,YAAYA,WAAW8B;MACvBoG,MAAM;QACFnI;MACJ;IACJ,CAAC;EACL;AAEA,MAAM0K,mBAAmB,IAAI3K,mBACzBC,uBACAC,YACAC,cACAC,MACAC,MACAC,MACAC,WACAC,SACJ;AAGAoK,+BAA6BJ,oBAAmBG,gBAAgB;AAChE,SAAOA;AACX;AAGO,SAASC,6BACZJ,oBACAG,kBACF;AAKE,MAAME,wBAAwBL,sBAAqBG,iBAAiBzK,WAAW4B,SAASuC;AACxF,MAAMyG,cAA4BD,wBAAwBF,iBAAiBzK,WAAW4B,SAAS0I,kBAAkB,IAAIO;AACrH,SAAOD,YAAYd,KAAK,MAAM;AAC1B,QAAIW,iBAAiBnH,UAAU,GAAG;AAC9B;IACJ;AACA,QAAImH,iBAAiBnK,WAAW;AAC5BmK,uBAAiBpH,MAAM;IAC3B;EACJ,CAAC;AACL;",
  "names": ["LEADER_ELECTORS_OF_DB", "WeakMap", "LEADER_ELECTOR_BY_BROADCAST_CHANNEL", "getLeaderElectorByBroadcastChannel", "broadcastChannel", "getFromMapOrCreate", "createLeaderElection", "getForDatabase", "getBroadcastChannelReference", "storage", "name", "token", "oldDestroy", "destroy", "bind", "removeBroadcastChannelReference", "elector", "set", "leaderElector", "isLeader", "multiInstance", "waitForLeadership", "PROMISE_RESOLVE_TRUE", "awaitLeadership", "then", "onDestroy", "db", "has", "get", "die", "rxdb", "prototypes", "RxDatabase", "proto", "RxDBLeaderElectionPlugin", "hooks", "preDestroyRxDatabase", "after", "DEFAULT_MODIFIER", "d", "Promise", "resolve", "swapDefaultDeletedTodeletedField", "deletedField", "doc", "flatClone", "isDeleted", "_deleted", "handlePulledDocuments", "collection", "docs", "map", "useDoc", "primaryPath", "schema", "getComposedPrimaryKeyOfDocumentData", "jsonSchema", "awaitRetry", "retryTime", "window", "addEventListener", "navigator", "onLine", "promiseWait", "listener", "onlineAgain", "res", "removeEventListener", "race", "then", "REPLICATION_STATE_BY_COLLECTION", "WeakMap", "RxReplicationState", "replicationIdentifier", "collection", "deletedField", "pull", "push", "live", "retryTime", "autoStart", "subs", "subjects", "received", "Subject", "sent", "error", "canceled", "BehaviorSubject", "active", "received$", "asObservable", "sent$", "error$", "canceled$", "active$", "onCancel", "callOnStart", "undefined", "remoteEvents$", "metaInfoPromise", "metaInstanceCollectionName", "database", "hashFunction", "name", "join", "metaInstanceSchema", "getRxReplicationMetaInstanceSchema", "schema", "jsonSchema", "hasEncryption", "collectionName", "replicationStates", "getFromMapOrCreate", "onDestroy", "cancel", "Object", "keys", "forEach", "key", "defineProperty", "get", "startPromise", "Promise", "res", "_proto", "prototype", "start", "isStopped", "pullModifier", "modifier", "DEFAULT_MODIFIER", "pushModifier", "metaInfo", "metaInstance", "all", "storage", "createStorageInstance", "databaseName", "databaseInstanceToken", "token", "multiInstance", "options", "password", "devMode", "overwritable", "isDevMode", "addConnectedStorageToCollection", "internalReplicationState", "replicateRxStorageInstance", "pushBatchSize", "batchSize", "pullBatchSize", "initialCheckpoint", "upstream", "downstream", "forkInstance", "storageInstance", "identifier", "conflictHandler", "replicationHandler", "masterChangeStream$", "pipe", "filter", "_v", "mergeMap", "ev", "useEv", "flatClone", "documents", "handlePulledDocuments", "map", "d", "masterChangesSince", "checkpoint", "done", "result", "handler", "err", "emitError", "newRxError", "errors", "toArray", "er", "errorToPlainJson", "direction", "next", "awaitRetry", "ensureNotFalsy", "useResult", "masterWrite", "rows", "runAsyncPluginHooks", "useRowsOrNull", "row", "newDocumentState", "assumedMasterState", "swapDefaultDeletedTodeletedField", "useRows", "arrayFilterNotEmpty", "length", "Array", "isArray", "pushRows", "args", "rxdb", "conflicts", "events", "subscribe", "processed", "down", "document", "up", "writeToMasterRow", "combineLatest", "isActive", "stream$", "awaitRxStorageReplicationFirstInSync", "awaitRxStorageReplicationInSync", "getValue", "awaitInitialReplication", "awaitInSync", "t", "requestIdlePromise", "reSync", "emitEvent", "PROMISE_RESOLVE_FALSE", "promises", "fn", "toPromise", "cancelRxStorageReplication", "checkpointQueue", "then", "close", "sub", "unsubscribe", "complete", "remove", "removeConnectedStorageFromCollection", "replicateRxCollection", "waitForLeadership", "addRxPlugin", "RxDBLeaderElectionPlugin", "replicationState", "startReplicationOnLeaderShip", "mustWaitForLeadership", "waitTillRun", "PROMISE_RESOLVE_TRUE"]
}
