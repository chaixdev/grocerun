{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/custom-index.ts", "../../../../../node_modules/rxdb/src/plugin-helpers.ts"],
  "sourcesContent": ["/**\n * For some RxStorage implementations,\n * we need to use our custom crafted indexes\n * so we can easily iterate over them. And sort plain arrays of document data.\n *\n * We really often have to craft an index string for a given document.\n * Performance of everything in this file is very important\n * which is why the code sometimes looks strange.\n * Run performance tests before and after you touch anything here!\n */\n\nimport {\n    getSchemaByObjectPath\n} from './rx-schema-helper.ts';\nimport type {\n    JsonSchema,\n    RxDocumentData,\n    RxJsonSchema\n} from './types/index.ts';\nimport {\n    ensureNotFalsy,\n    objectPathMonad,\n    ObjectPathMonadFunction\n} from './plugins/utils/index.ts';\nimport {\n    INDEX_MAX,\n    INDEX_MIN\n} from './query-planner.ts';\n\n\n/**\n * Prepare all relevant information\n * outside of the returned function\n * from getIndexableStringMonad()\n * to save performance when the returned\n * function is called many times.\n */\ntype IndexMetaField<RxDocType> = {\n    fieldName: string;\n    schemaPart: JsonSchema;\n    /*\n     * Only in number fields.\n     */\n    parsedLengths?: ParsedLengths;\n    getValue: ObjectPathMonadFunction<RxDocType>;\n    getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\n};\n\nexport function getIndexMeta<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): IndexMetaField<RxDocType>[] {\n    const fieldNameProperties: IndexMetaField<RxDocType>[] = index.map(fieldName => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        if (!schemaPart) {\n            throw new Error('not in schema: ' + fieldName);\n        }\n        const type = schemaPart.type;\n        let parsedLengths: ParsedLengths | undefined;\n        if (type === 'number' || type === 'integer') {\n            parsedLengths = getStringLengthOfIndexNumber(\n                schemaPart\n            );\n        }\n\n        const getValue = objectPathMonad(fieldName);\n        const maxLength = schemaPart.maxLength ? schemaPart.maxLength : 0;\n\n        let getIndexStringPart: (docData: RxDocumentData<RxDocType>) => string;\n        if (type === 'string') {\n            getIndexStringPart = docData => {\n                let fieldValue = getValue(docData);\n                if (!fieldValue) {\n                    fieldValue = '';\n                }\n                return fieldValue.padEnd(maxLength, ' ');\n            };\n        } else if (type === 'boolean') {\n            getIndexStringPart = docData => {\n                const fieldValue = getValue(docData);\n                return fieldValue ? '1' : '0';\n            };\n        } else { // number\n            getIndexStringPart = docData => {\n                const fieldValue = getValue(docData);\n                return getNumberIndexString(\n                    parsedLengths as any,\n                    fieldValue\n                );\n            };\n        }\n\n        const ret: IndexMetaField<RxDocType> = {\n            fieldName,\n            schemaPart,\n            parsedLengths,\n            getValue,\n            getIndexStringPart\n        };\n        return ret;\n    });\n    return fieldNameProperties;\n}\n\n\n/**\n * Crafts an indexable string that can be used\n * to check if a document would be sorted below or above\n * another documents, dependent on the index values.\n * @monad for better performance\n *\n * IMPORTANT: Performance is really important here\n * which is why we code so 'strange'.\n * Always run performance tests when you want to\n * change something in this method.\n */\nexport function getIndexableStringMonad<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): (docData: RxDocumentData<RxDocType>) => string {\n    const fieldNameProperties = getIndexMeta(schema, index);\n    const fieldNamePropertiesAmount = fieldNameProperties.length;\n    const indexPartsFunctions = fieldNameProperties.map(r => r.getIndexStringPart);\n\n\n    /**\n     * @hotPath Performance of this function is very critical!\n     */\n    const ret = function (docData: RxDocumentData<RxDocType>): string {\n        let str = '';\n        for (let i = 0; i < fieldNamePropertiesAmount; ++i) {\n            str += indexPartsFunctions[i](docData);\n        }\n        return str;\n    };\n    return ret;\n}\n\n\ndeclare type ParsedLengths = {\n    minimum: number;\n    maximum: number;\n    nonDecimals: number;\n    decimals: number;\n    roundedMinimum: number;\n};\nexport function getStringLengthOfIndexNumber(\n    schemaPart: JsonSchema\n): ParsedLengths {\n    const minimum = Math.floor(schemaPart.minimum as number);\n    const maximum = Math.ceil(schemaPart.maximum as number);\n    const multipleOf: number = schemaPart.multipleOf as number;\n\n    const valueSpan = maximum - minimum;\n    const nonDecimals = valueSpan.toString().length;\n\n    const multipleOfParts = multipleOf.toString().split('.');\n    let decimals = 0;\n    if (multipleOfParts.length > 1) {\n        decimals = multipleOfParts[1].length;\n    }\n    return {\n        minimum,\n        maximum,\n        nonDecimals,\n        decimals,\n        roundedMinimum: minimum\n    };\n}\n\nexport function getIndexStringLength<RxDocType>(\n    schema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    index: string[]\n): number {\n    const fieldNameProperties = getIndexMeta(schema, index);\n    let length = 0;\n    fieldNameProperties.forEach(props => {\n        const schemaPart = props.schemaPart;\n        const type = schemaPart.type;\n\n        if (type === 'string') {\n            length += schemaPart.maxLength as number;\n        } else if (type === 'boolean') {\n            length += 1;\n        } else {\n            const parsedLengths = props.parsedLengths as ParsedLengths;\n            length = length + parsedLengths.nonDecimals + parsedLengths.decimals;\n        }\n\n    });\n    return length;\n}\n\n\nexport function getPrimaryKeyFromIndexableString(\n    indexableString: string,\n    primaryKeyLength: number\n): string {\n    const paddedPrimaryKey = indexableString.slice(primaryKeyLength * -1);\n    // we can safely trim here because the primary key is not allowed to start or end with a space char.\n    const primaryKey = paddedPrimaryKey.trim();\n    return primaryKey;\n}\n\n\nexport function getNumberIndexString(\n    parsedLengths: ParsedLengths,\n    fieldValue: number\n): string {\n    /**\n     * Ensure that the given value is in the boundaries\n     * of the schema, otherwise it would create a broken index string.\n     * This can happen for example if you have a minimum of 0\n     * and run a query like\n     * selector {\n     *  numField: { $gt: -1000 }\n     * }\n     */\n    if (typeof fieldValue === 'undefined') {\n        fieldValue = 0;\n    }\n    if (fieldValue < parsedLengths.minimum) {\n        fieldValue = parsedLengths.minimum;\n    }\n    if (fieldValue > parsedLengths.maximum) {\n        fieldValue = parsedLengths.maximum;\n    }\n\n    const nonDecimalsValueAsString = (Math.floor(fieldValue) - parsedLengths.roundedMinimum).toString();\n    let str = nonDecimalsValueAsString.padStart(parsedLengths.nonDecimals, '0');\n\n    if (parsedLengths.decimals > 0) {\n        const splitByDecimalPoint = fieldValue.toString().split('.');\n        const decimalValueAsString = splitByDecimalPoint.length > 1 ? splitByDecimalPoint[1] : '0';\n        str += decimalValueAsString.padEnd(parsedLengths.decimals, '0');\n    }\n    return str;\n}\n\nexport function getStartIndexStringFromLowerBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    lowerBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = lowerBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n                if (typeof bound === 'string') {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else {\n                    // str += ''.padStart(maxLength, inclusiveStart ? ' ' : INDEX_MAX);\n                    str += ''.padEnd(maxLength, ' ');\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '0';\n                } else if (bound === INDEX_MIN) {\n                    str += '0';\n                } else if (bound === INDEX_MAX) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MIN) {\n                    const fillChar = '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else if (bound === INDEX_MAX) {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        parsedLengths.maximum\n                    );\n                } else {\n                    const add = getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                    str += add;\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n\nexport function getStartIndexStringFromUpperBound(\n    schema: RxJsonSchema<any>,\n    index: string[],\n    upperBound: (string | boolean | number | null | undefined)[]\n): string {\n    let str = '';\n    index.forEach((fieldName, idx) => {\n        const schemaPart = getSchemaByObjectPath(\n            schema,\n            fieldName\n        );\n        const bound = upperBound[idx];\n        const type = schemaPart.type;\n\n        switch (type) {\n            case 'string':\n                const maxLength = ensureNotFalsy(schemaPart.maxLength, 'maxLength not set');\n                if (typeof bound === 'string' && bound !== INDEX_MAX) {\n                    str += (bound as string).padEnd(maxLength, ' ');\n                } else if (bound === INDEX_MIN) {\n                    str += ''.padEnd(maxLength, ' ');\n                } else {\n                    str += ''.padEnd(maxLength, INDEX_MAX);\n                }\n                break;\n            case 'boolean':\n                if (bound === null) {\n                    str += '1';\n                } else {\n                    const boolToStr = bound ? '1' : '0';\n                    str += boolToStr;\n                }\n                break;\n            case 'number':\n            case 'integer':\n                const parsedLengths = getStringLengthOfIndexNumber(\n                    schemaPart\n                );\n                if (bound === null || bound === INDEX_MAX) {\n                    const fillChar = '9';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else if (bound === INDEX_MIN) {\n                    const fillChar = '0';\n                    str += fillChar.repeat(parsedLengths.nonDecimals + parsedLengths.decimals);\n                } else {\n                    str += getNumberIndexString(\n                        parsedLengths,\n                        bound as number\n                    );\n                }\n                break;\n            default:\n                throw new Error('unknown index type ' + type);\n        }\n    });\n    return str;\n}\n\n/**\n * Used in storages where it is not possible\n * to define inclusiveEnd/inclusiveStart\n */\nexport function changeIndexableStringByOneQuantum(str: string, direction: 1 | -1): string {\n    const lastChar = str.slice(-1);\n    let charCode = lastChar.charCodeAt(0);\n    charCode = charCode + direction;\n    const withoutLastChar = str.slice(0, -1);\n    return withoutLastChar + String.fromCharCode(charCode);\n}\n", "import { filter, mergeMap, tap } from 'rxjs/operators';\nimport { getPrimaryFieldOfPrimaryKey } from './rx-schema-helper.ts';\nimport { WrappedRxStorageInstance } from './rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    EventBulk,\n    RxChangeEvent,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageWriteError,\n    RxStorageBulkWriteResponse,\n    RxStorageChangeEvent,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams,\n    RxValidationError,\n    RxStorageWriteErrorConflict,\n    MaybePromise\n} from './types/index.d.ts';\nimport {\n    flatClone,\n    getFromMapOrCreate,\n    requestIdleCallbackIfAvailable\n} from './plugins/utils/index.ts';\nimport { BehaviorSubject, firstValueFrom } from 'rxjs';\n\n\ntype WrappedStorageFunction = <Internals, InstanceCreationOptions>(\n    args: {\n        storage: RxStorage<Internals, InstanceCreationOptions>;\n    }\n) => RxStorage<Internals, InstanceCreationOptions>;\n\n/**\n * Returns the validation errors.\n * If document is fully valid, returns an empty array.\n */\ntype ValidatorFunction = (docData: RxDocumentData<any>) => RxValidationError[];\n\n/**\n * cache the validators by the schema string\n * so we can reuse them when multiple collections have the same schema\n *\n * Notice: to make it easier and not dependent on a hash function,\n * we use the plain json string.\n */\nconst VALIDATOR_CACHE_BY_VALIDATOR_KEY: Map<string, Map<string, ValidatorFunction>> = new Map();\n\n/**\n * This factory is used in the validation plugins\n * so that we can reuse the basic storage wrapping code.\n */\nexport function wrappedValidateStorageFactory(\n    /**\n     * Returns a method that can be used to validate\n     * documents and throws when the document is not valid.\n     */\n    getValidator: (schema: RxJsonSchema<any>) => ValidatorFunction,\n    /**\n     * A string to identify the validation library.\n     */\n    validatorKey: string\n): WrappedStorageFunction {\n    const VALIDATOR_CACHE = getFromMapOrCreate(\n        VALIDATOR_CACHE_BY_VALIDATOR_KEY,\n        validatorKey,\n        () => new Map()\n    );\n\n    function initValidator(\n        schema: RxJsonSchema<any>\n    ): ValidatorFunction {\n        return getFromMapOrCreate(\n            VALIDATOR_CACHE,\n            JSON.stringify(schema),\n            () => getValidator(schema)\n        );\n    }\n\n    return (args) => {\n        return Object.assign(\n            {},\n            args.storage,\n            {\n                async createStorageInstance<RxDocType>(\n                    params: RxStorageInstanceCreationParams<RxDocType, any>\n                ) {\n                    const instance = await args.storage.createStorageInstance(params);\n                    const primaryPath = getPrimaryFieldOfPrimaryKey(params.schema.primaryKey);\n\n                    /**\n                     * Lazy initialize the validator\n                     * to save initial page load performance.\n                     * Some libraries take really long to initialize the validator\n                     * from the schema.\n                     */\n                    let validatorCached: ValidatorFunction;\n                    requestIdleCallbackIfAvailable(() => validatorCached = initValidator(params.schema));\n\n                    const oldBulkWrite = instance.bulkWrite.bind(instance);\n                    instance.bulkWrite = (\n                        documentWrites: BulkWriteRow<RxDocType>[],\n                        context: string\n                    ) => {\n                        if (!validatorCached) {\n                            validatorCached = initValidator(params.schema);\n                        }\n                        const errors: RxStorageWriteError<RxDocType>[] = [];\n                        const continueWrites: typeof documentWrites = [];\n                        documentWrites.forEach(row => {\n                            const documentId: string = row.document[primaryPath] as any;\n                            const validationErrors = validatorCached(row.document);\n                            if (validationErrors.length > 0) {\n                                errors.push({\n                                    status: 422,\n                                    isError: true,\n                                    documentId,\n                                    writeRow: row,\n                                    validationErrors\n                                });\n                            } else {\n                                continueWrites.push(row);\n                            }\n                        });\n                        const writePromise: Promise<RxStorageBulkWriteResponse<RxDocType>> = continueWrites.length > 0 ?\n                            oldBulkWrite(continueWrites, context) :\n                            Promise.resolve({ error: [], success: [] });\n                        return writePromise.then(writeResult => {\n                            errors.forEach(validationError => {\n                                writeResult.error.push(validationError);\n                            });\n                            return writeResult;\n                        });\n                    };\n\n                    return instance;\n                }\n            }\n        );\n    };\n\n}\n\n\n\n/**\n * Used in plugins to easily modify all in- and outgoing\n * data of that storage instance.\n */\nexport function wrapRxStorageInstance<RxDocType>(\n    originalSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    instance: RxStorageInstance<RxDocType, any, any>,\n    modifyToStorage: (docData: RxDocumentWriteData<RxDocType>) => MaybePromise<RxDocumentData<any>>,\n    modifyFromStorage: (docData: RxDocumentData<any>) => MaybePromise<RxDocumentData<RxDocType>>,\n    modifyAttachmentFromStorage: (attachmentData: string) => MaybePromise<string> = (v) => v\n): WrappedRxStorageInstance<RxDocType, any, any> {\n    async function toStorage(docData: RxDocumentWriteData<RxDocType>): Promise<RxDocumentData<any>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyToStorage(docData);\n    }\n    async function fromStorage(docData: RxDocumentData<any> | null): Promise<RxDocumentData<RxDocType>> {\n        if (!docData) {\n            return docData;\n        }\n        return await modifyFromStorage(docData);\n    }\n    async function errorFromStorage(\n        error: RxStorageWriteError<any>\n    ): Promise<RxStorageWriteError<RxDocType>> {\n        const ret = flatClone(error);\n        ret.writeRow = flatClone(ret.writeRow);\n        if ((ret as RxStorageWriteErrorConflict<any>).documentInDb) {\n            (ret as RxStorageWriteErrorConflict<any>).documentInDb = await fromStorage((ret as RxStorageWriteErrorConflict<any>).documentInDb);\n        }\n        if (ret.writeRow.previous) {\n            ret.writeRow.previous = await fromStorage(ret.writeRow.previous);\n        }\n        ret.writeRow.document = await fromStorage(ret.writeRow.document);\n        return ret;\n    }\n\n\n    const processingChangesCount$ = new BehaviorSubject(0);\n\n    const wrappedInstance: WrappedRxStorageInstance<RxDocType, any, any> = {\n        databaseName: instance.databaseName,\n        internals: instance.internals,\n        cleanup: instance.cleanup.bind(instance),\n        options: instance.options,\n        close: instance.close.bind(instance),\n        schema: originalSchema,\n        collectionName: instance.collectionName,\n        count: instance.count.bind(instance),\n        remove: instance.remove.bind(instance),\n        originalStorageInstance: instance,\n        bulkWrite: async (\n            documentWrites: BulkWriteRow<RxDocType>[],\n            context: string\n        ) => {\n            const useRows: BulkWriteRow<any>[] = [];\n            await Promise.all(\n                documentWrites.map(async (row) => {\n                    const [previous, document] = await Promise.all([\n                        row.previous ? toStorage(row.previous) : undefined,\n                        toStorage(row.document)\n                    ]);\n                    useRows.push({ previous, document });\n                })\n            );\n\n            const writeResult = await instance.bulkWrite(useRows, context);\n            const ret: RxStorageBulkWriteResponse<RxDocType> = {\n                error: []\n            };\n            const promises: Promise<any>[] = [];\n            writeResult.error.forEach(error => {\n                promises.push(\n                    errorFromStorage(error).then(err => ret.error.push(err))\n                );\n            });\n            await Promise.all(promises);\n\n            /**\n             * By definition, all change events must be emitted\n             * BEFORE the write call resolves.\n             * To ensure that even when the modifiers are async,\n             * we wait here until the processing queue is empty.\n             */\n            await firstValueFrom(\n                processingChangesCount$.pipe(\n                    filter(v => v === 0)\n                )\n            );\n            return ret;\n        },\n        query: (preparedQuery) => {\n            return instance.query(preparedQuery)\n                .then(queryResult => {\n                    return Promise.all(queryResult.documents.map(doc => fromStorage(doc)));\n                })\n                .then(documents => ({ documents: documents as any }));\n        },\n        getAttachmentData: async (\n            documentId: string,\n            attachmentId: string,\n            digest: string\n        ) => {\n            let data = await instance.getAttachmentData(documentId, attachmentId, digest);\n            data = await modifyAttachmentFromStorage(data);\n            return data;\n        },\n        findDocumentsById: (ids, deleted) => {\n            return instance.findDocumentsById(ids, deleted)\n                .then(async (findResult) => {\n                    const ret: RxDocumentData<RxDocType>[] = [];\n                    await Promise.all(\n                        findResult\n                            .map(async (doc) => {\n                                ret.push(await fromStorage(doc));\n                            })\n                    );\n                    return ret;\n                });\n        },\n        getChangedDocumentsSince: !instance.getChangedDocumentsSince ? undefined : (limit, checkpoint) => {\n            return ((instance as any).getChangedDocumentsSince)(limit, checkpoint)\n                .then(async (result: any) => {\n                    return {\n                        checkpoint: result.checkpoint,\n                        documents: await Promise.all(\n                            result.documents.map((d: any) => fromStorage(d))\n                        )\n                    };\n                });\n        },\n        changeStream: () => {\n            return instance.changeStream().pipe(\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() + 1)),\n                mergeMap(async (eventBulk) => {\n                    const useEvents = await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            const [\n                                documentData,\n                                previousDocumentData\n                            ] = await Promise.all([\n                                fromStorage(event.documentData),\n                                fromStorage(event.previousDocumentData)\n                            ]);\n                            const ev: RxChangeEvent<RxDocType> = {\n                                operation: event.operation,\n                                documentId: event.documentId,\n                                documentData: documentData as any,\n                                previousDocumentData: previousDocumentData as any,\n                                isLocal: false\n                            };\n                            return ev;\n                        })\n                    );\n                    const ret: EventBulk<RxStorageChangeEvent<RxDocumentData<RxDocType>>, any> = {\n                        id: eventBulk.id,\n                        events: useEvents,\n                        checkpoint: eventBulk.checkpoint,\n                        context: eventBulk.context,\n                        startTime: eventBulk.startTime,\n                        endTime: eventBulk.endTime\n                    };\n                    return ret;\n                }),\n                tap(() => processingChangesCount$.next(processingChangesCount$.getValue() - 1))\n            );\n        },\n        conflictResultionTasks: () => {\n            return instance.conflictResultionTasks().pipe(\n                mergeMap(async (task) => {\n                    const assumedMasterState = await fromStorage(task.input.assumedMasterState);\n                    const newDocumentState = await fromStorage(task.input.newDocumentState);\n                    const realMasterState = await fromStorage(task.input.realMasterState);\n                    return {\n                        id: task.id,\n                        context: task.context,\n                        input: {\n                            assumedMasterState,\n                            realMasterState,\n                            newDocumentState\n                        }\n                    };\n                })\n            );\n        },\n        resolveConflictResultionTask: (taskSolution) => {\n            if (taskSolution.output.isEqual) {\n                return instance.resolveConflictResultionTask(taskSolution);\n            }\n            const useSolution = {\n                id: taskSolution.id,\n                output: {\n                    isEqual: false,\n                    documentData: taskSolution.output.documentData\n                }\n            };\n            return instance.resolveConflictResultionTask(useSolution);\n        }\n    };\n\n    return wrappedInstance;\n}\n"],
  "mappings": "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",
  "names": ["getIndexMeta", "schema", "index", "fieldNameProperties", "map", "fieldName", "schemaPart", "getSchemaByObjectPath", "Error", "type", "parsedLengths", "getStringLengthOfIndexNumber", "getValue", "objectPathMonad", "maxLength", "getIndexStringPart", "docData", "fieldValue", "padEnd", "getNumberIndexString", "ret", "getIndexableStringMonad", "fieldNamePropertiesAmount", "length", "indexPartsFunctions", "r", "str", "i", "minimum", "Math", "floor", "maximum", "ceil", "multipleOf", "valueSpan", "nonDecimals", "toString", "multipleOfParts", "split", "decimals", "roundedMinimum", "getIndexStringLength", "forEach", "props", "getPrimaryKeyFromIndexableString", "indexableString", "primaryKeyLength", "paddedPrimaryKey", "slice", "primaryKey", "trim", "nonDecimalsValueAsString", "padStart", "splitByDecimalPoint", "decimalValueAsString", "getStartIndexStringFromLowerBound", "lowerBound", "idx", "bound", "ensureNotFalsy", "INDEX_MIN", "INDEX_MAX", "boolToStr", "fillChar", "repeat", "add", "getStartIndexStringFromUpperBound", "upperBound", "changeIndexableStringByOneQuantum", "direction", "lastChar", "charCode", "charCodeAt", "withoutLastChar", "String", "fromCharCode", "VALIDATOR_CACHE_BY_VALIDATOR_KEY", "Map", "wrappedValidateStorageFactory", "getValidator", "validatorKey", "VALIDATOR_CACHE", "getFromMapOrCreate", "initValidator", "schema", "JSON", "stringify", "args", "Object", "assign", "storage", "createStorageInstance", "params", "instance", "primaryPath", "getPrimaryFieldOfPrimaryKey", "primaryKey", "validatorCached", "requestIdleCallbackIfAvailable", "oldBulkWrite", "bulkWrite", "bind", "documentWrites", "context", "errors", "continueWrites", "forEach", "row", "documentId", "document", "validationErrors", "length", "push", "status", "isError", "writeRow", "writePromise", "Promise", "resolve", "error", "success", "then", "writeResult", "validationError", "wrapRxStorageInstance", "originalSchema", "modifyToStorage", "modifyFromStorage", "modifyAttachmentFromStorage", "v", "toStorage", "docData", "fromStorage", "errorFromStorage", "ret", "flatClone", "documentInDb", "previous", "processingChangesCount$", "BehaviorSubject", "wrappedInstance", "databaseName", "internals", "cleanup", "options", "close", "collectionName", "count", "remove", "originalStorageInstance", "useRows", "all", "map", "undefined", "promises", "err", "firstValueFrom", "pipe", "filter", "query", "preparedQuery", "queryResult", "documents", "doc", "getAttachmentData", "attachmentId", "digest", "data", "findDocumentsById", "ids", "deleted", "findResult", "getChangedDocumentsSince", "limit", "checkpoint", "result", "d", "changeStream", "tap", "next", "getValue", "mergeMap", "eventBulk", "useEvents", "events", "event", "documentData", "previousDocumentData", "ev", "operation", "isLocal", "id", "startTime", "endTime", "conflictResultionTasks", "task", "assumedMasterState", "input", "newDocumentState", "realMasterState", "resolveConflictResultionTask", "taskSolution", "output", "isEqual", "useSolution"]
}
