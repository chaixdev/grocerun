{
  "version": 3,
  "sources": ["../../../../../node_modules/rxdb/src/rx-database-internal-store.ts", "../../../../../node_modules/rxdb/src/rx-collection-helper.ts", "../../../../../node_modules/rxdb/src/incremental-write.ts", "../../../../../node_modules/rxdb/src/rx-document.ts", "../../../../../node_modules/rxdb/src/rx-document-prototype-merge.ts", "../../../../../node_modules/rxdb/src/replication-protocol/checkpoint.ts", "../../../../../node_modules/rxdb/src/replication-protocol/helper.ts", "../../../../../node_modules/rxdb/src/replication-protocol/meta-instance.ts", "../../../../../node_modules/rxdb/src/replication-protocol/downstream.ts", "../../../../../node_modules/rxdb/src/replication-protocol/conflicts.ts", "../../../../../node_modules/rxdb/src/plugins/attachments/attachments-utils.ts", "../../../../../node_modules/rxdb/src/plugins/attachments/index.ts", "../../../../../node_modules/rxdb/src/replication-protocol/upstream.ts", "../../../../../node_modules/rxdb/src/replication-protocol/index.ts", "../../../../../node_modules/rxdb/src/change-event-buffer.ts", "../../../../../node_modules/rxdb/src/rx-collection.ts", "../../../../../node_modules/rxdb/src/rx-schema.ts", "../../../../../node_modules/custom-idle-queue/dist/es/index.js", "../../../../../node_modules/rxdb/src/rx-database.ts"],
  "sourcesContent": ["import {\n    isBulkWriteConflictError,\n    newRxError\n} from './rx-error.ts';\nimport {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData\n} from './rx-schema-helper.ts';\nimport { getSingleDocument, getWrittenDocumentsFromBulkWriteResponse, writeSingle } from './rx-storage-helper.ts';\nimport type {\n    CollectionsOfDatabase,\n    InternalStoreCollectionDocType,\n    InternalStoreDocType,\n    InternalStoreStorageTokenDocType,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageInstance,\n    RxStorageWriteErrorConflict\n} from './types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    randomCouchString\n} from './plugins/utils/index.ts';\nimport { prepareQuery } from './rx-query.ts';\n\nexport const INTERNAL_CONTEXT_COLLECTION = 'collection';\nexport const INTERNAL_CONTEXT_STORAGE_TOKEN = 'storage-token';\nexport const INTERNAL_CONTEXT_MIGRATION_STATUS = 'rx-migration-status';\n\n/**\n * Do not change the title,\n * we have to flag the internal schema so that\n * some RxStorage implementations are able\n * to detect if the created RxStorageInstance\n * is from the internals or not,\n * to do some optimizations in some cases.\n */\nexport const INTERNAL_STORE_SCHEMA_TITLE = 'RxInternalDocument';\n\nexport const INTERNAL_STORE_SCHEMA: RxJsonSchema<RxDocumentData<InternalStoreDocType<any>>> = fillWithDefaultSettings({\n    version: 0,\n    title: INTERNAL_STORE_SCHEMA_TITLE,\n    primaryKey: {\n        key: 'id',\n        fields: [\n            'context',\n            'key'\n        ],\n        separator: '|'\n    },\n    type: 'object',\n    properties: {\n        id: {\n            type: 'string',\n            maxLength: 200\n        },\n        key: {\n            type: 'string'\n        },\n        context: {\n            type: 'string',\n            enum: [\n                INTERNAL_CONTEXT_COLLECTION,\n                INTERNAL_CONTEXT_STORAGE_TOKEN,\n                INTERNAL_CONTEXT_MIGRATION_STATUS,\n                'OTHER'\n            ]\n        },\n        data: {\n            type: 'object',\n            additionalProperties: true\n        }\n    },\n    indexes: [],\n    required: [\n        'key',\n        'context',\n        'data'\n    ],\n    additionalProperties: false,\n    /**\n     * If the sharding plugin is used,\n     * it must not shard on the internal RxStorageInstance\n     * because that one anyway has only a small amount of documents\n     * and also its creation is in the hot path of the initial page load,\n     * so we should spend less time creating multiple RxStorageInstances.\n     */\n    sharding: {\n        shards: 1,\n        mode: 'collection'\n    }\n});\n\n\nexport function getPrimaryKeyOfInternalDocument(\n    key: string,\n    context: string\n): string {\n    return getComposedPrimaryKeyOfDocumentData<InternalStoreDocType>(\n        INTERNAL_STORE_SCHEMA,\n        {\n            key,\n            context\n        }\n    );\n}\n\n/**\n * Returns all internal documents\n * with context 'collection'\n */\nexport async function getAllCollectionDocuments(\n    storageInstance: RxStorageInstance<InternalStoreDocType<any>, any, any>\n): Promise<RxDocumentData<InternalStoreCollectionDocType>[]> {\n    const getAllQueryPrepared = prepareQuery<InternalStoreDocType<any>>(\n        storageInstance.schema,\n        {\n            selector: {\n                context: INTERNAL_CONTEXT_COLLECTION,\n                _deleted: {\n                    $eq: false\n                }\n            },\n            sort: [{ id: 'asc' }],\n            skip: 0\n        }\n    );\n    const queryResult = await storageInstance.query(getAllQueryPrepared);\n    const allDocs = queryResult.documents;\n    return allDocs;\n}\n\n/**\n * to not confuse multiInstance-messages with other databases that have the same\n * name and adapter, but do not share state with this one (for example in-memory-instances),\n * we set a storage-token and use it in the broadcast-channel\n */\nexport const STORAGE_TOKEN_DOCUMENT_KEY = 'storageToken';\n\nexport const STORAGE_TOKEN_DOCUMENT_ID = getPrimaryKeyOfInternalDocument(\n    STORAGE_TOKEN_DOCUMENT_KEY,\n    INTERNAL_CONTEXT_STORAGE_TOKEN\n);\n\nexport async function ensureStorageTokenDocumentExists<Collections extends CollectionsOfDatabase = any>(\n    rxDatabase: RxDatabase<Collections>\n): Promise<RxDocumentData<InternalStoreStorageTokenDocType>> {\n\n    /**\n     * To have less read-write cycles,\n     * we just try to insert a new document\n     * and only fetch the existing one if a conflict happened.\n     */\n    const storageToken = randomCouchString(10);\n\n    const passwordHash = rxDatabase.password ?\n        await rxDatabase.hashFunction(JSON.stringify(rxDatabase.password)) :\n        undefined;\n\n    const docData: RxDocumentData<InternalStoreStorageTokenDocType> = {\n        id: STORAGE_TOKEN_DOCUMENT_ID,\n        context: INTERNAL_CONTEXT_STORAGE_TOKEN,\n        key: STORAGE_TOKEN_DOCUMENT_KEY,\n        data: {\n            rxdbVersion: rxDatabase.rxdbVersion,\n            token: storageToken,\n            /**\n             * We add the instance token here\n             * to be able to detect if a given RxDatabase instance\n             * is the first instance that was ever created\n             * or if databases have existed earlier on that storage\n             * with the same database name.\n             */\n            instanceToken: rxDatabase.token,\n            passwordHash\n        },\n        _deleted: false,\n        _meta: getDefaultRxDocumentMeta(),\n        _rev: getDefaultRevision(),\n        _attachments: {}\n    };\n\n    const writeRows = [{ document: docData }];\n    const writeResult = await rxDatabase.internalStore.bulkWrite(\n        writeRows,\n        'internal-add-storage-token'\n    );\n    if (!writeResult.error[0]) {\n        return getWrittenDocumentsFromBulkWriteResponse(\n            'id',\n            writeRows,\n            writeResult\n        )[0];\n    }\n\n    /**\n     * If we get a 409 error,\n     * it means another instance already inserted the storage token.\n     * So we get that token from the database and return that one.\n     */\n    const error = ensureNotFalsy(writeResult.error[0]);\n    if (\n        error.isError &&\n        isBulkWriteConflictError(error)\n    ) {\n        const conflictError = (error as RxStorageWriteErrorConflict<InternalStoreStorageTokenDocType>);\n\n        if (\n            !isDatabaseStateVersionCompatibleWithDatabaseCode(\n                conflictError.documentInDb.data.rxdbVersion,\n                rxDatabase.rxdbVersion\n            )\n        ) {\n            throw newRxError('DM5', {\n                args: {\n                    database: rxDatabase.name,\n                    databaseStateVersion: conflictError.documentInDb.data.rxdbVersion,\n                    codeVersion: rxDatabase.rxdbVersion\n                }\n            });\n        }\n\n        if (\n            passwordHash &&\n            passwordHash !== conflictError.documentInDb.data.passwordHash\n        ) {\n            throw newRxError('DB1', {\n                passwordHash,\n                existingPasswordHash: conflictError.documentInDb.data.passwordHash\n            });\n        }\n\n        const storageTokenDocInDb = conflictError.documentInDb;\n        return ensureNotFalsy(storageTokenDocInDb);\n    }\n    throw error;\n}\n\n\nexport function isDatabaseStateVersionCompatibleWithDatabaseCode(\n    databaseStateVersion: string,\n    codeVersion: string\n): boolean {\n    if (!databaseStateVersion) {\n        return false;\n    }\n\n    if (\n        codeVersion.includes('beta') &&\n        codeVersion !== databaseStateVersion\n    ) {\n        return false;\n    }\n\n    const stateMajor = databaseStateVersion.split('.')[0];\n    const codeMajor = codeVersion.split('.')[0];\n    if (stateMajor !== codeMajor) {\n        return false;\n    }\n    return true;\n}\n\n\n\n\n\nexport async function addConnectedStorageToCollection(\n    collection: RxCollection<any>,\n    storageCollectionName: string,\n    schema: RxJsonSchema<any>\n) {\n\n    if (collection.schema.version !== schema.version) {\n        throw newRxError('SNH', {\n            schema,\n            version: collection.schema.version,\n            name: collection.name,\n            collection,\n            args: {\n                storageCollectionName\n            }\n        });\n    }\n\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\n        collectionNameWithVersion,\n        INTERNAL_CONTEXT_COLLECTION\n    );\n\n    while (true) {\n        const collectionDoc = await getSingleDocument(\n            collection.database.internalStore,\n            collectionDocId\n        );\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\n\n        // do nothing if already in array\n        const alreadyThere = saveData.data.connectedStorages\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n        if (alreadyThere) {\n            return;\n        }\n\n        // otherwise add to array and save\n        saveData.data.connectedStorages.push({\n            collectionName: storageCollectionName,\n            schema\n        });\n        try {\n            await writeSingle(\n                collection.database.internalStore,\n                {\n                    previous: ensureNotFalsy(collectionDoc),\n                    document: saveData\n                },\n                'add-connected-storage-to-collection'\n            );\n        } catch (err) {\n            if (!isBulkWriteConflictError(err)) {\n                throw err;\n            }\n            // retry on conflict\n        }\n    }\n}\n\nexport async function removeConnectedStorageFromCollection(\n    collection: RxCollection<any>,\n    storageCollectionName: string,\n    schema: RxJsonSchema<any>\n) {\n    if (collection.schema.version !== schema.version) {\n        throw newRxError('SNH', {\n            schema,\n            version: collection.schema.version,\n            name: collection.name,\n            collection,\n            args: {\n                storageCollectionName\n            }\n        });\n    }\n\n    const collectionNameWithVersion = _collectionNamePrimary(collection.name, collection.schema.jsonSchema);\n    const collectionDocId = getPrimaryKeyOfInternalDocument(\n        collectionNameWithVersion,\n        INTERNAL_CONTEXT_COLLECTION\n    );\n\n    while (true) {\n        const collectionDoc = await getSingleDocument(\n            collection.database.internalStore,\n            collectionDocId\n        );\n        const saveData: RxDocumentData<InternalStoreCollectionDocType> = clone(ensureNotFalsy(collectionDoc));\n\n        // do nothing if not there\n        const isThere = saveData.data.connectedStorages\n            .find(row => row.collectionName === storageCollectionName && row.schema.version === schema.version);\n        if (!isThere) {\n            return;\n        }\n\n        // otherwise remove from array and save\n        saveData.data.connectedStorages = saveData.data.connectedStorages.filter(item => item.collectionName !== storageCollectionName);\n        try {\n            await writeSingle(\n                collection.database.internalStore,\n                {\n                    previous: ensureNotFalsy(collectionDoc),\n                    document: saveData\n                },\n                'remove-connected-storage-from-collection'\n            );\n        } catch (err) {\n            if (!isBulkWriteConflictError(err)) {\n                throw err;\n            }\n            // retry on conflict\n        }\n    }\n}\n\n\n\n/**\n * returns the primary for a given collection-data\n * used in the internal store of a RxDatabase\n */\nexport function _collectionNamePrimary(name: string, schema: RxJsonSchema<any>) {\n    return name + '-' + schema.version;\n}\n", "import type {\n    HashFunction,\n    InternalStoreDocType,\n    RxCollection,\n    RxDatabase,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorage,\n    RxStorageInstance,\n    RxStorageInstanceCreationParams\n} from './types/index.d.ts';\nimport {\n    createRevision,\n    flatClone,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    now\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectWithDefaults,\n    fillPrimaryKey\n} from './rx-schema-helper.ts';\nimport type { RxSchema } from './rx-schema.ts';\nimport { runAsyncPluginHooks } from './hooks.ts';\nimport { getAllCollectionDocuments } from './rx-database-internal-store.ts';\nimport { flatCloneDocWithMeta } from './rx-storage-helper.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxCollectionBase } from './rx-collection.ts';\nimport { newRxError } from './rx-error.ts';\n\n/**\n * fills in the default data.\n * This also clones the data.\n */\nexport function fillObjectDataBeforeInsert<RxDocType>(\n    schema: RxSchema<RxDocType>,\n    data: Partial<RxDocumentData<RxDocType>> | any\n): RxDocumentData<RxDocType> {\n    data = flatClone(data);\n    data = fillObjectWithDefaults(schema, data);\n    if (typeof schema.jsonSchema.primaryKey !== 'string') {\n        data = fillPrimaryKey(\n            schema.primaryPath,\n            schema.jsonSchema,\n            data\n        );\n    }\n    data._meta = getDefaultRxDocumentMeta();\n    if (!Object.prototype.hasOwnProperty.call(data, '_deleted')) {\n        data._deleted = false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(data, '_attachments')) {\n        data._attachments = {};\n    }\n    if (!Object.prototype.hasOwnProperty.call(data, '_rev')) {\n        data._rev = getDefaultRevision();\n    }\n    return data;\n}\n\n/**\n * Creates the storage instances that are used internally in the collection\n */\nexport async function createRxCollectionStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>(\n    rxDatabase: RxDatabase<{}, Internals, InstanceCreationOptions>,\n    storageInstanceCreationParams: RxStorageInstanceCreationParams<RxDocumentType, InstanceCreationOptions>\n): Promise<RxStorageInstance<RxDocumentType, Internals, InstanceCreationOptions>> {\n    storageInstanceCreationParams.multiInstance = rxDatabase.multiInstance;\n    const storageInstance = await rxDatabase.storage.createStorageInstance<RxDocumentType>(\n        storageInstanceCreationParams\n    );\n    return storageInstance;\n}\n\n/**\n * Removes the main storage of the collection\n * and all connected storages like the ones from the replication meta etc.\n */\nexport async function removeCollectionStorages(\n    storage: RxStorage<any, any>,\n    databaseInternalStorage: RxStorageInstance<InternalStoreDocType<any>, any, any>,\n    databaseInstanceToken: string,\n    databaseName: string,\n    collectionName: string,\n    password?: string,\n    /**\n     * If no hash function is provided,\n     * we assume that the whole internal store is removed anyway\n     * so we do not have to delete the meta documents.\n     */\n    hashFunction?: HashFunction,\n) {\n    const allCollectionMetaDocs = await getAllCollectionDocuments(\n        databaseInternalStorage\n    );\n    const relevantCollectionMetaDocs = allCollectionMetaDocs\n        .filter(metaDoc => metaDoc.data.name === collectionName);\n    let removeStorages: {\n        collectionName: string;\n        schema: RxJsonSchema<any>;\n        isCollection: boolean;\n    }[] = [];\n    relevantCollectionMetaDocs.forEach(metaDoc => {\n        removeStorages.push({\n            collectionName: metaDoc.data.name,\n            schema: metaDoc.data.schema,\n            isCollection: true\n        });\n        metaDoc.data.connectedStorages.forEach(row => removeStorages.push({\n            collectionName: row.collectionName,\n            isCollection: false,\n            schema: row.schema\n        }));\n    });\n\n    // ensure uniqueness\n    const alreadyAdded = new Set<string>();\n    removeStorages = removeStorages.filter(row => {\n        const key = row.collectionName + '||' + row.schema.version;\n        if (alreadyAdded.has(key)) {\n            return false;\n        } else {\n            alreadyAdded.add(key);\n            return true;\n        }\n    });\n\n    // remove all the storages\n    await Promise.all(\n        removeStorages\n            .map(async (row) => {\n                const storageInstance = await storage.createStorageInstance<any>({\n                    collectionName: row.collectionName,\n                    databaseInstanceToken,\n                    databaseName,\n                    multiInstance: false,\n                    options: {},\n                    schema: row.schema,\n                    password,\n                    devMode: overwritable.isDevMode()\n                });\n                await storageInstance.remove();\n                if (row.isCollection) {\n                    await runAsyncPluginHooks('postRemoveRxCollection', {\n                        storage,\n                        databaseName: databaseName,\n                        collectionName\n                    });\n                }\n            })\n    );\n\n    // remove the meta documents\n    if (hashFunction) {\n        const writeRows = relevantCollectionMetaDocs.map(doc => {\n            const writeDoc = flatCloneDocWithMeta(doc);\n            writeDoc._deleted = true;\n            writeDoc._meta.lwt = now();\n            writeDoc._rev = createRevision(\n                databaseInstanceToken,\n                doc\n            );\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        await databaseInternalStorage.bulkWrite(\n            writeRows,\n            'rx-database-remove-collection-all'\n        );\n    }\n}\n\n\nexport function ensureRxCollectionIsNotDestroyed(\n    collection: RxCollection | RxCollectionBase<any, any, any, any, any>\n) {\n    if (collection.destroyed) {\n        throw newRxError(\n            'COL21',\n            {\n                collection: collection.name,\n                version: collection.schema.version\n            }\n        );\n    }\n}\n", "import {\n    isBulkWriteConflictError,\n    rxStorageWriteErrorToRxError\n} from './rx-error.ts';\nimport type {\n    ModifyFunction,\n    BulkWriteRow,\n    MaybePromise,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxError,\n    RxStorageBulkWriteResponse,\n    RxStorageInstance,\n    StringKeys,\n    WithDeleted\n} from './types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    getFromMapOrCreate,\n    getFromMapOrThrow,\n    getHeightOfRevision,\n    stripMetaDataFromDocument\n} from './plugins/utils/index.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse } from './rx-storage-helper.ts';\n\n\n\nexport type IncrementalWriteModifier<RxDocType> = (\n    doc: RxDocumentData<RxDocType>\n) => MaybePromise<RxDocumentData<RxDocType>> | MaybePromise<RxDocumentWriteData<RxDocType>>;\n\n\ntype IncrementalWriteQueueItem<RxDocType> = {\n    lastKnownDocumentState: RxDocumentData<RxDocType>;\n    modifier: IncrementalWriteModifier<RxDocType>;\n    resolve: (d: RxDocumentData<RxDocType>) => void;\n    reject: (error: RxError) => void;\n};\n\n/**\n * The incremental write queue\n * batches up all incremental writes to a collection\n * so that performance can be improved by:\n * - Running only one write even when there are multiple modifications to the same document.\n * - Run all writes ins a single bulkWrite() call even when there are writes to many documents.\n */\nexport class IncrementalWriteQueue<RxDocType> {\n    public queueByDocId = new Map<string, IncrementalWriteQueueItem<RxDocType>[]>();\n    public isRunning: boolean = false;\n\n    constructor(\n        public readonly storageInstance: RxStorageInstance<RxDocType, any, any>,\n        public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>,\n        // can be used to run hooks etc.\n        public readonly preWrite: (newData: RxDocumentData<RxDocType>, oldData: RxDocumentData<RxDocType>) => MaybePromise<void>,\n        public readonly postWrite: (docData: RxDocumentData<RxDocType>) => void\n\n    ) { }\n\n    addWrite(\n        lastKnownDocumentState: RxDocumentData<RxDocType>,\n        modifier: IncrementalWriteModifier<RxDocType>\n    ): Promise<RxDocumentData<RxDocType>> {\n        const docId: string = lastKnownDocumentState[this.primaryPath] as any;\n        const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n        const ret = new Promise<RxDocumentData<RxDocType>>((resolve, reject) => {\n            const item: IncrementalWriteQueueItem<RxDocType> = {\n                lastKnownDocumentState,\n                modifier,\n                resolve,\n                reject\n            };\n            ensureNotFalsy(ar).push(item);\n            this.triggerRun();\n        });\n        return ret;\n    }\n\n    async triggerRun(): Promise<void> {\n        if (\n            this.isRunning === true ||\n            this.queueByDocId.size === 0\n        ) {\n            // already running\n            return;\n        }\n        this.isRunning = true;\n        const writeRows: BulkWriteRow<RxDocType>[] = [];\n\n        /**\n         * 'take over' so that while the async functions runs,\n         * new incremental updates could be added from the outside.\n         */\n        const itemsById = this.queueByDocId;\n        this.queueByDocId = new Map();\n        await Promise.all(\n            Array.from(itemsById.entries())\n                .map(async ([_docId, items]) => {\n                    const oldData = findNewestOfDocumentStates(\n                        items.map(i => i.lastKnownDocumentState)\n                    );\n                    let newData = oldData;\n                    for (const item of items) {\n                        try {\n                            newData = await item.modifier(\n                                /**\n                                 * We have to clone() each time because the modifier\n                                 * might throw while it already changed some properties\n                                 * of the document.\n                                 */\n                                clone(newData)\n                            ) as any;\n                        } catch (err: any) {\n                            item.reject(err);\n                            item.reject = () => { };\n                            item.resolve = () => { };\n                        }\n                    }\n\n                    try {\n                        await this.preWrite(newData, oldData);\n                    } catch (err: any) {\n                        /**\n                         * If the before-hooks fail,\n                         * we reject all of the writes because it is\n                         * not possible to determine which one is to blame.\n                         */\n                        items.forEach(item => item.reject(err));\n                        return;\n                    }\n                    writeRows.push({\n                        previous: oldData,\n                        document: newData\n                    });\n                })\n        );\n        const writeResult: RxStorageBulkWriteResponse<RxDocType> = writeRows.length > 0 ?\n            await this.storageInstance.bulkWrite(writeRows, 'incremental-write') :\n            { error: [] };\n\n        // process success\n        await Promise.all(\n            getWrittenDocumentsFromBulkWriteResponse(this.primaryPath, writeRows, writeResult).map(result => {\n                const docId = result[this.primaryPath] as string;\n                this.postWrite(result);\n                const items = getFromMapOrThrow(itemsById, docId);\n                items.forEach(item => item.resolve(result));\n            })\n        );\n\n        // process errors\n        writeResult.error\n            .forEach(error => {\n                const docId = error.documentId;\n                const items = getFromMapOrThrow(itemsById, docId);\n                const isConflict = isBulkWriteConflictError<RxDocType>(error);\n                if (isConflict) {\n                    // had conflict -> retry afterwards\n                    const ar = getFromMapOrCreate(this.queueByDocId, docId, () => []);\n                    /**\n                     * Add the items back to this.queueByDocId\n                     * by maintaining the original order.\n                     */\n                    items\n                        .reverse()\n                        .forEach(item => {\n                            item.lastKnownDocumentState = ensureNotFalsy(isConflict.documentInDb);\n                            ensureNotFalsy(ar).unshift(item);\n                        });\n                } else {\n                    // other error -> must be thrown\n                    const rxError = rxStorageWriteErrorToRxError(error);\n                    items.forEach(item => item.reject(rxError));\n                }\n            });\n        this.isRunning = false;\n\n        /**\n         * Always trigger another run\n         * because in between there might be new items\n         * been added to the queue.\n         */\n        return this.triggerRun();\n    }\n}\n\n\nexport function modifierFromPublicToInternal<RxDocType>(\n    publicModifier: ModifyFunction<RxDocType>\n): IncrementalWriteModifier<RxDocType> {\n    const ret = async (docData: RxDocumentData<RxDocType>) => {\n        const withoutMeta: WithDeleted<RxDocType> = stripMetaDataFromDocument(docData) as any;\n        withoutMeta._deleted = docData._deleted;\n        const modified = await publicModifier(withoutMeta);\n        const reattachedMeta: RxDocumentData<RxDocType> = Object.assign({}, modified, {\n            _meta: docData._meta,\n            _attachments: docData._attachments,\n            _rev: docData._rev,\n            _deleted: typeof (modified as WithDeleted<RxDocType>)._deleted !== 'undefined' ?\n                (modified as WithDeleted<RxDocType>)._deleted :\n                docData._deleted\n        });\n        if (typeof reattachedMeta._deleted === 'undefined') {\n            reattachedMeta._deleted = false;\n        }\n        return reattachedMeta;\n    };\n    return ret;\n}\n\n\nexport function findNewestOfDocumentStates<RxDocType>(\n    docs: RxDocumentData<RxDocType>[]\n): RxDocumentData<RxDocType> {\n\n    let newest = docs[0];\n    let newestRevisionHeight = getHeightOfRevision(newest._rev);\n    docs.forEach(doc => {\n        const height = getHeightOfRevision(doc._rev);\n        if (height > newestRevisionHeight) {\n            newest = doc;\n            newestRevisionHeight = height;\n        }\n    });\n    return newest;\n}\n", "import {\n    Observable\n} from 'rxjs';\nimport {\n    distinctUntilChanged,\n    filter,\n    map,\n    shareReplay,\n    startWith\n} from 'rxjs/operators';\nimport {\n    clone,\n    trimDots,\n    pluginMissing,\n    flatClone,\n    PROMISE_RESOLVE_NULL,\n    RXJS_SHARE_REPLAY_DEFAULTS,\n    getProperty,\n    getFromMapOrCreate\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\n\nimport type {\n    RxDocument,\n    RxCollection,\n    RxDocumentData,\n    RxDocumentWriteData,\n    UpdateQuery,\n    CRDTEntry,\n    ModifyFunction\n} from './types/index.d.ts';\nimport { getDocumentDataOfRxChangeEvent } from './rx-change-event.ts';\nimport { overwritable } from './overwritable.ts';\nimport { getSchemaByObjectPath } from './rx-schema-helper.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, throwIfIsStorageWriteError } from './rx-storage-helper.ts';\nimport { modifierFromPublicToInternal } from './incremental-write.ts';\n\nexport const basePrototype = {\n    get primaryPath() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this.collection.schema.primaryPath;\n    },\n    get primary() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return (_this._data as any)[_this.primaryPath];\n    },\n    get revision() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this._data._rev;\n    },\n    get deleted$() {\n        const _this: RxDocument<any> = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this.$.pipe(\n            map((d: any) => d._data._deleted)\n        );\n    },\n    get deleted$$() {\n        const _this: RxDocument = this as any;\n        const reactivity = _this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            _this.deleted$,\n            _this.getLatest().deleted,\n            _this.collection.database\n        );\n    },\n    get deleted() {\n        const _this: RxDocument = this as any;\n        if (!_this.isInstanceOfRxDocument) {\n            return undefined;\n        }\n        return _this._data._deleted;\n    },\n\n    getLatest(this: RxDocument): RxDocument {\n        const latestDocData = this.collection._docCache.getLatestDocumentData(this.primary);\n        return this.collection._docCache.getCachedRxDocument(latestDocData);\n    },\n\n    /**\n     * returns the observable which emits the plain-data of this document\n     */\n    get $(): Observable<RxDocumentData<any>> {\n        const _this: RxDocument<{}, {}, {}> = this as any;\n        return _this.collection.$.pipe(\n            filter(changeEvent => !changeEvent.isLocal),\n            filter(changeEvent => changeEvent.documentId === this.primary),\n            map(changeEvent => getDocumentDataOfRxChangeEvent(changeEvent)),\n            startWith(_this.collection._docCache.getLatestDocumentData(this.primary)),\n            distinctUntilChanged((prev, curr) => prev._rev === curr._rev),\n            map(docData => (this as RxDocument<any>).collection._docCache.getCachedRxDocument(docData)),\n            shareReplay(RXJS_SHARE_REPLAY_DEFAULTS)\n        );\n    },\n    get $$(): any {\n        const _this: RxDocument = this as any;\n        const reactivity = _this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            _this.$,\n            _this.getLatest()._data,\n            _this.collection.database\n        );\n    },\n\n    /**\n     * returns observable of the value of the given path\n     */\n    get$(this: RxDocument, path: string): Observable<any> {\n        if (overwritable.isDevMode()) {\n            if (path.includes('.item.')) {\n                throw newRxError('DOC1', {\n                    path\n                });\n            }\n\n            if (path === this.primaryPath) {\n                throw newRxError('DOC2');\n            }\n\n            // final fields cannot be modified and so also not observed\n            if (this.collection.schema.finalFields.includes(path)) {\n                throw newRxError('DOC3', {\n                    path\n                });\n            }\n\n            const schemaObj = getSchemaByObjectPath(\n                this.collection.schema.jsonSchema,\n                path\n            );\n\n            if (!schemaObj) {\n                throw newRxError('DOC4', {\n                    path\n                });\n            }\n        }\n\n        return this.$\n            .pipe(\n                map(data => getProperty(data, path)),\n                distinctUntilChanged()\n            );\n    },\n    get$$(this: RxDocument, path: string) {\n        const obs = this.get$(path);\n        const reactivity = this.collection.database.getReactivityFactory();\n        return reactivity.fromObservable(\n            obs,\n            this.getLatest().get(path),\n            this.collection.database\n        );\n    },\n\n    /**\n     * populate the given path\n     */\n    populate(this: RxDocument, path: string): Promise<RxDocument | null> {\n        const schemaObj = getSchemaByObjectPath(\n            this.collection.schema.jsonSchema,\n            path\n        );\n        const value = this.get(path);\n        if (!value) {\n            return PROMISE_RESOLVE_NULL;\n        }\n        if (!schemaObj) {\n            throw newRxError('DOC5', {\n                path\n            });\n        }\n        if (!schemaObj.ref) {\n            throw newRxError('DOC6', {\n                path,\n                schemaObj\n            });\n        }\n\n        const refCollection: RxCollection = this.collection.database.collections[schemaObj.ref];\n        if (!refCollection) {\n            throw newRxError('DOC7', {\n                ref: schemaObj.ref,\n                path,\n                schemaObj\n            });\n        }\n\n        if (schemaObj.type === 'array') {\n            return refCollection.findByIds(value).exec().then(res => {\n                const valuesIterator = res.values();\n                return Array.from(valuesIterator) as any;\n            });\n        } else {\n            return refCollection.findOne(value).exec();\n        }\n    },\n    /**\n     * get data by objectPath\n     * @hotPath Performance here is really important,\n     * run some tests before changing anything.\n     */\n    get(this: RxDocument, objPath: string): any | null {\n        return getDocumentProperty(this, objPath);\n    },\n\n    toJSON(this: RxDocument, withMetaFields = false) {\n        if (!withMetaFields) {\n            const data = flatClone(this._data);\n            delete (data as any)._rev;\n            delete (data as any)._attachments;\n            delete (data as any)._deleted;\n            delete (data as any)._meta;\n            return overwritable.deepFreezeWhenDevMode(data);\n        } else {\n            return overwritable.deepFreezeWhenDevMode(this._data);\n        }\n    },\n    toMutableJSON(this: RxDocument, withMetaFields = false) {\n        return clone(this.toJSON(withMetaFields as any));\n    },\n\n    /**\n     * updates document\n     * @overwritten by plugin (optional)\n     * @param updateObj mongodb-like syntax\n     */\n    update(_updateObj: UpdateQuery<any>) {\n        throw pluginMissing('update');\n    },\n    incrementalUpdate(_updateObj: UpdateQuery<any>) {\n        throw pluginMissing('update');\n    },\n    updateCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]) {\n        throw pluginMissing('crdt');\n    },\n    putAttachment() {\n        throw pluginMissing('attachments');\n    },\n    getAttachment() {\n        throw pluginMissing('attachments');\n    },\n    allAttachments() {\n        throw pluginMissing('attachments');\n    },\n    get allAttachments$() {\n        throw pluginMissing('attachments');\n    },\n\n    async modify<RxDocType>(\n        this: RxDocument<RxDocType>,\n        mutationFunction: ModifyFunction<RxDocType>,\n        // used by some plugins that wrap the method\n        _context?: string\n    ): Promise<RxDocument> {\n        const oldData = this._data;\n        const newData: RxDocumentData<RxDocType> = await modifierFromPublicToInternal<RxDocType>(mutationFunction)(oldData) as any;\n        return this._saveData(newData, oldData) as any;\n    },\n\n    /**\n     * runs an incremental update over the document\n     * @param function that takes the document-data and returns a new data-object\n     */\n    incrementalModify(\n        this: RxDocument,\n        mutationFunction: ModifyFunction<any>,\n        // used by some plugins that wrap the method\n        _context?: string\n    ): Promise<RxDocument> {\n        return this.collection.incrementalWriteQueue.addWrite(\n            this._data,\n            modifierFromPublicToInternal(mutationFunction)\n        ).then(result => this.collection._docCache.getCachedRxDocument(result));\n    },\n\n    patch<RxDocType>(\n        this: RxDocument<RxDocType>,\n        patch: Partial<RxDocType>\n    ) {\n        const oldData = this._data;\n        const newData = clone(oldData);\n        Object\n            .entries(patch)\n            .forEach(([k, v]) => {\n                (newData as any)[k] = v;\n            });\n        return this._saveData(newData, oldData);\n    },\n\n    /**\n     * patches the given properties\n     */\n    incrementalPatch<RxDocumentType = any>(\n        this: RxDocument<RxDocumentType>,\n        patch: Partial<RxDocumentType>\n    ): Promise<RxDocument<RxDocumentType>> {\n        return this.incrementalModify((docData) => {\n            Object\n                .entries(patch)\n                .forEach(([k, v]) => {\n                    (docData as any)[k] = v;\n                });\n            return docData;\n        });\n    },\n\n    /**\n     * saves the new document-data\n     * and handles the events\n     */\n    async _saveData<RxDocType>(\n        this: RxDocument<RxDocType>,\n        newData: RxDocumentWriteData<RxDocType>,\n        oldData: RxDocumentData<RxDocType>\n    ): Promise<RxDocument<RxDocType>> {\n        newData = flatClone(newData);\n\n        // deleted documents cannot be changed\n        if (this._data._deleted) {\n            throw newRxError('DOC11', {\n                id: this.primary,\n                document: this\n            });\n        }\n        await beforeDocumentUpdateWrite(this.collection, newData, oldData);\n        const writeRows = [{\n            previous: oldData,\n            document: newData\n        }];\n        const writeResult = await this.collection.storageInstance.bulkWrite(writeRows, 'rx-document-save-data');\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this.collection, this.primary, newData, isError);\n\n        await this.collection._runHooks('post', 'save', newData, this);\n        return this.collection._docCache.getCachedRxDocument(\n            getWrittenDocumentsFromBulkWriteResponse(\n                this.collection.schema.primaryPath,\n                writeRows,\n                writeResult\n            )[0]\n        );\n    },\n\n    /**\n     * Remove the document.\n     * Notice that there is no hard delete,\n     * instead deleted documents get flagged with _deleted=true.\n     */\n    remove(this: RxDocument): Promise<RxDocument> {\n        const collection = this.collection;\n        if (this.deleted) {\n            return Promise.reject(newRxError('DOC13', {\n                document: this,\n                id: this.primary\n            }));\n        }\n\n        const deletedData = flatClone(this._data);\n        let removedDocData: RxDocumentData<any>;\n        return collection._runHooks('pre', 'remove', deletedData, this)\n            .then(async () => {\n                deletedData._deleted = true;\n                const writeRows = [{\n                    previous: this._data,\n                    document: deletedData\n                }];\n                const writeResult = await collection.storageInstance.bulkWrite(writeRows, 'rx-document-remove');\n                const isError = writeResult.error[0];\n                throwIfIsStorageWriteError(collection, this.primary, deletedData, isError);\n                return getWrittenDocumentsFromBulkWriteResponse(\n                    this.collection.schema.primaryPath,\n                    writeRows,\n                    writeResult\n                )[0];\n            })\n            .then((removed) => {\n                removedDocData = removed;\n                return this.collection._runHooks('post', 'remove', deletedData, this);\n            })\n            .then(() => {\n                return this.collection._docCache.getCachedRxDocument(removedDocData);\n            });\n    },\n    incrementalRemove(this: RxDocument): Promise<RxDocument> {\n        return this.incrementalModify(async (docData) => {\n            await this.collection._runHooks('pre', 'remove', docData, this);\n            docData._deleted = true;\n            return docData;\n        }).then(async (newDoc) => {\n            await this.collection._runHooks('post', 'remove', newDoc._data, newDoc);\n            return newDoc;\n        });\n    },\n    destroy() {\n        throw newRxError('DOC14');\n    }\n};\n\nexport function createRxDocumentConstructor(proto = basePrototype) {\n    const constructor = function RxDocumentConstructor(\n        this: RxDocument,\n        collection: RxCollection,\n        docData: RxDocumentData<any>\n    ) {\n        this.collection = collection;\n\n        // assume that this is always equal to the doc-data in the database\n        this._data = docData;\n        this._propertyCache = new Map<string, any>();\n\n        /**\n         * because of the prototype-merge,\n         * we can not use the native instanceof operator\n         */\n        this.isInstanceOfRxDocument = true;\n    };\n    constructor.prototype = proto;\n    return constructor;\n}\n\nexport function createWithConstructor<RxDocType>(\n    constructor: any,\n    collection: RxCollection<RxDocType>,\n    jsonData: RxDocumentData<RxDocType>\n): RxDocument<RxDocType> | null {\n    const doc = new constructor(collection, jsonData);\n    runPluginHooks('createRxDocument', doc);\n    return doc;\n}\n\nexport function isRxDocument(obj: any): boolean {\n    return typeof obj === 'object' && obj !== null && 'isInstanceOfRxDocument' in obj;\n}\n\n\nexport function beforeDocumentUpdateWrite<RxDocType>(\n    collection: RxCollection<RxDocType>,\n    newData: RxDocumentWriteData<RxDocType>,\n    oldData: RxDocumentData<RxDocType>\n): Promise<any> {\n    /**\n     * Meta values must always be merged\n     * instead of overwritten.\n     * This ensures that different plugins do not overwrite\n     * each others meta properties.\n     */\n    newData._meta = Object.assign(\n        {},\n        oldData._meta,\n        newData._meta\n    );\n\n    // ensure modifications are ok\n    if (overwritable.isDevMode()) {\n        collection.schema.validateChange(oldData, newData);\n    }\n    return collection._runHooks('pre', 'save', newData, oldData);\n}\n\n\n\n\nfunction getDocumentProperty(doc: RxDocument, objPath: string): any | null {\n    return getFromMapOrCreate(\n        doc._propertyCache,\n        objPath,\n        () => {\n            const valueObj = getProperty(doc._data, objPath);\n\n            // direct return if array or non-object\n            if (\n                typeof valueObj !== 'object' ||\n                valueObj === null ||\n                Array.isArray(valueObj)\n            ) {\n                return overwritable.deepFreezeWhenDevMode(valueObj);\n            }\n            const proxy = new Proxy(\n                /**\n                 * In dev-mode, the _data is deep-frozen\n                 * so we have to flat clone here so that\n                 * the proxy can work.\n                 */\n                flatClone(valueObj),\n                {\n                    /**\n                     * @performance is really important here\n                     * because people access nested properties very often\n                     * and might not be aware that this is internally using a Proxy\n                     */\n                    get(target, property: any) {\n                        if (typeof property !== 'string') {\n                            return target[property];\n                        }\n\n\n                        const lastChar = property.charAt(property.length - 1);\n                        if (lastChar === '$') {\n                            if (property.endsWith('$$')) {\n                                const key = property.slice(0, -2);\n                                return doc.get$$(trimDots(objPath + '.' + key));\n                            } else {\n                                const key = property.slice(0, -1);\n                                return doc.get$(trimDots(objPath + '.' + key));\n                            }\n                        } else if (lastChar === '_') {\n                            const key = property.slice(0, -1);\n                            return doc.populate(trimDots(objPath + '.' + key));\n                        } else {\n\n                            /**\n                             * Performance shortcut\n                             * In most cases access to nested properties\n                             * will only access simple values which can be directly returned\n                             * without creating a new Proxy or utilizing the cache.\n                             */\n                            const plainValue = target[property];\n                            if (\n                                typeof plainValue === 'number' ||\n                                typeof plainValue === 'string' ||\n                                typeof plainValue === 'boolean'\n                            ) {\n                                return plainValue;\n                            }\n\n                            return getDocumentProperty(doc, trimDots(objPath + '.' + property));\n                        }\n                    }\n                });\n            return proxy;\n        }\n    );\n};\n", "/**\n * For the ORM capabilities,\n * we have to merge the document prototype\n * with the ORM functions and the data\n * We do this iterating over the properties and\n * adding them to a new object.\n * In the future we should do this by chaining the __proto__ objects\n */\n\nimport type {\n    RxCollection,\n    RxDocument,\n    RxDocumentData\n} from './types/index.d.ts';\nimport {\n    createRxDocumentConstructor,\n    basePrototype,\n    createWithConstructor as createRxDocumentWithConstructor\n} from './rx-document.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\nimport { overwritable } from './overwritable.ts';\nimport { getFromMapOrCreate } from './plugins/utils/index.ts';\n\nconst constructorForCollection = new WeakMap();\n\nexport function getDocumentPrototype(\n    rxCollection: RxCollection\n): any {\n    const schemaProto = rxCollection.schema.getDocumentPrototype();\n    const ormProto = getDocumentOrmPrototype(rxCollection);\n    const baseProto = basePrototype;\n    const proto = {};\n    [\n        schemaProto,\n        ormProto,\n        baseProto\n    ].forEach(obj => {\n        const props = Object.getOwnPropertyNames(obj);\n        props.forEach(key => {\n            const desc: any = Object.getOwnPropertyDescriptor(obj, key);\n            /**\n             * When enumerable is true, it will show on console dir(instance)\n             * To not pollute the output, only getters and methods are enumerable\n             */\n            let enumerable = true;\n            if (\n                key.startsWith('_') ||\n                key.endsWith('_') ||\n                key.startsWith('$') ||\n                key.endsWith('$')\n            ) enumerable = false;\n\n            if (typeof desc.value === 'function') {\n                // when getting a function, we automatically do a .bind(this)\n                Object.defineProperty(proto, key, {\n                    get() {\n                        return desc.value.bind(this);\n                    },\n                    enumerable,\n                    configurable: false\n                });\n\n            } else {\n                desc.enumerable = enumerable;\n                desc.configurable = false;\n                if (desc.writable)\n                    desc.writable = false;\n                Object.defineProperty(proto, key, desc);\n            }\n        });\n    });\n    return proto;\n}\n\nexport function getRxDocumentConstructor<RxDocType, ORM>(\n    rxCollection: RxCollection<RxDocType, ORM>\n) {\n    return getFromMapOrCreate(\n        constructorForCollection,\n        rxCollection,\n        () => createRxDocumentConstructor(\n            getDocumentPrototype(rxCollection as any)\n        )\n    );\n}\n\n/**\n * Create a RxDocument-instance from the jsonData\n * and the prototype merge.\n * You should never call this method directly,\n * instead you should get the document from collection._docCache.getCachedRxDocument().\n */\nexport function createNewRxDocument<RxDocType, ORM, Reactivity>(\n    rxCollection: RxCollection<RxDocType, ORM, {}, {}, Reactivity>,\n    documentConstructor: any,\n    docData: RxDocumentData<RxDocType>\n): RxDocument<RxDocType, ORM, Reactivity> {\n    const doc = createRxDocumentWithConstructor(\n        documentConstructor,\n        rxCollection as any,\n        overwritable.deepFreezeWhenDevMode(docData as any)\n    );\n    rxCollection._runHooksSync('post', 'create', docData, doc);\n    runPluginHooks('postCreateRxDocument', doc);\n    return doc as any;\n}\n\n\n/**\n * returns the prototype-object\n * that contains the orm-methods,\n * used in the proto-merge\n */\nexport function getDocumentOrmPrototype(rxCollection: RxCollection): any {\n    const proto: any = {};\n    Object\n        .entries(rxCollection.methods)\n        .forEach(([k, v]) => {\n            proto[k] = v;\n        });\n    return proto;\n}\n", "import { getComposedPrimaryKeyOfDocumentData } from '../rx-schema-helper.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\nimport type {\n    RxDocumentData,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationDirection,\n    RxStorageReplicationMeta\n} from '../types/index.d.ts';\nimport {\n    createRevision,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    now\n} from '../plugins/utils/index.ts';\n\nexport async function getLastCheckpointDoc<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection\n): Promise<undefined | CheckpointType> {\n    const checkpointDocId = getComposedPrimaryKeyOfDocumentData(\n        state.input.metaInstance.schema,\n        {\n            isCheckpoint: '1',\n            itemId: direction\n        }\n    );\n    const checkpointResult = await state.input.metaInstance.findDocumentsById(\n        [\n            checkpointDocId\n        ],\n        false\n    );\n\n    const checkpointDoc = checkpointResult[0];\n    state.lastCheckpointDoc[direction] = checkpointDoc;\n    if (checkpointDoc) {\n        return checkpointDoc.checkpointData;\n    } else {\n        return undefined;\n    }\n}\n\n\n/**\n * Sets the checkpoint,\n * automatically resolves conflicts that appear.\n */\nexport async function setCheckpoint<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    direction: RxStorageReplicationDirection,\n    checkpoint: CheckpointType\n) {\n    state.checkpointQueue = state.checkpointQueue.then(async () => {\n        let previousCheckpointDoc = state.lastCheckpointDoc[direction];\n        if (\n            checkpoint &&\n            /**\n             * If the replication is already canceled,\n             * we do not write a checkpoint\n             * because that could mean we write a checkpoint\n             * for data that has been fetched from the master\n             * but not been written to the child.\n             */\n            !state.events.canceled.getValue() &&\n            /**\n             * Only write checkpoint if it is different from before\n             * to have less writes to the storage.\n             */\n            (\n                !previousCheckpointDoc ||\n                JSON.stringify(previousCheckpointDoc.checkpointData) !== JSON.stringify(checkpoint)\n            )\n        ) {\n            const newDoc: RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {\n                id: '',\n                isCheckpoint: '1',\n                itemId: direction,\n                _deleted: false,\n                _attachments: {},\n                checkpointData: checkpoint,\n                _meta: getDefaultRxDocumentMeta(),\n                _rev: getDefaultRevision()\n            };\n            newDoc.id = getComposedPrimaryKeyOfDocumentData(\n                state.input.metaInstance.schema,\n                newDoc\n            );\n            while (!state.events.canceled.getValue()) {\n                /**\n                 * Instead of just storing the new checkpoint,\n                 * we have to stack up the checkpoint with the previous one.\n                 * This is required for plugins like the sharding RxStorage\n                 * where the changeStream events only contain a Partial of the\n                 * checkpoint.\n                 */\n                if (previousCheckpointDoc) {\n                    newDoc.checkpointData = stackCheckpoints([\n                        previousCheckpointDoc.checkpointData,\n                        newDoc.checkpointData\n                    ]);\n                }\n                newDoc._meta.lwt = now();\n                newDoc._rev = createRevision(\n                    await state.checkpointKey,\n                    previousCheckpointDoc\n                );\n\n                if (state.events.canceled.getValue()) {\n                    return;\n                }\n\n                const writeRows = [{\n                    previous: previousCheckpointDoc,\n                    document: newDoc\n                }];\n                const result = await state.input.metaInstance.bulkWrite(writeRows, 'replication-set-checkpoint');\n                const successDoc = getWrittenDocumentsFromBulkWriteResponse(\n                    state.primaryPath,\n                    writeRows,\n                    result\n                )[0];\n                if (successDoc) {\n                    state.lastCheckpointDoc[direction] = successDoc;\n                    return;\n                } else {\n                    const error = result.error[0];\n                    if (error.status !== 409) {\n                        throw error;\n                    } else {\n                        previousCheckpointDoc = ensureNotFalsy(error.documentInDb);\n                        newDoc._rev = createRevision(\n                            await state.checkpointKey,\n                            previousCheckpointDoc\n                        );\n                    }\n                }\n            }\n        }\n    });\n    await state.checkpointQueue;\n}\n\nexport async function getCheckpointKey<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): Promise<string> {\n    const hash = await input.hashFunction([\n        input.identifier,\n        input.forkInstance.databaseName,\n        input.forkInstance.collectionName\n    ].join('||'));\n    return 'rx_storage_replication_' + hash;\n}\n", "import type {\n    BulkWriteRow,\n    RxDocumentData,\n    RxDocumentWriteData,\n    RxStorageInstance,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeletedAndAttachments\n} from '../types/index.d.ts';\nimport {\n    clone,\n    createRevision,\n    flatClone,\n    getDefaultRevision,\n    now\n} from '../plugins/utils/index.ts';\nimport { stripAttachmentsDataFromDocument } from '../rx-storage-helper.ts';\n\nexport function docStateToWriteDoc<RxDocType>(\n    databaseInstanceToken: string,\n    hasAttachments: boolean,\n    keepMeta: boolean,\n    docState: WithDeletedAndAttachments<RxDocType>,\n    previous?: RxDocumentData<RxDocType>\n): RxDocumentWriteData<RxDocType> {\n    const docData: RxDocumentWriteData<RxDocType> = Object.assign(\n        {},\n        docState,\n        {\n            _attachments: hasAttachments && docState._attachments ? docState._attachments : {},\n            _meta: keepMeta ? (docState as any)._meta : Object.assign(\n                {},\n                previous ? previous._meta : {},\n                {\n                    lwt: now()\n                }\n            ),\n            _rev: keepMeta ? (docState as any)._rev : getDefaultRevision()\n        }\n    );\n    if (!docData._rev) {\n        docData._rev = createRevision(\n            databaseInstanceToken,\n            previous\n        );\n    }\n\n    return docData;\n}\n\nexport function writeDocToDocState<RxDocType>(\n    writeDoc: RxDocumentData<RxDocType>,\n    keepAttachments: boolean,\n    keepMeta: boolean\n): WithDeletedAndAttachments<RxDocType> {\n    const ret = flatClone(writeDoc);\n\n    if (!keepAttachments) {\n        delete (ret as any)._attachments;\n    }\n    if (!keepMeta) {\n        delete (ret as any)._meta;\n        delete (ret as any)._rev;\n    }\n    return ret;\n}\n\n\nexport function stripAttachmentsDataFromMetaWriteRows<RxDocType>(\n    state: RxStorageInstanceReplicationState<any>,\n    rows: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[]\n): BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] {\n    if (!state.hasAttachments) {\n        return rows;\n    }\n    return rows.map(row => {\n        const document = clone(row.document);\n        document.docData = stripAttachmentsDataFromDocument(document.docData);\n        return {\n            document,\n            previous: row.previous\n        };\n    });\n}\n\nexport function getUnderlyingPersistentStorage<RxDocType>(\n    instance: RxStorageInstance<RxDocType, any, any, any>\n): RxStorageInstance<RxDocType, any, any, any> {\n    while (true) {\n        if (instance.underlyingPersistentStorage) {\n            instance = instance.underlyingPersistentStorage;\n        } else {\n            return instance;\n        }\n    }\n}\n", "import {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData,\n    getLengthOfPrimaryKey\n} from '../rx-schema-helper.ts';\nimport { flatCloneDocWithMeta } from '../rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    ById,\n    RxDocumentData,\n    RxJsonSchema,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    getDefaultRevision,\n    createRevision,\n    now\n} from '../plugins/utils/index.ts';\n\n\nexport const META_INSTANCE_SCHEMA_TITLE = 'RxReplicationProtocolMetaData';\n\nexport function getRxReplicationMetaInstanceSchema<RxDocType, CheckpointType>(\n    replicatedDocumentsSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n    encrypted: boolean\n): RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>>> {\n    const parentPrimaryKeyLength = getLengthOfPrimaryKey(replicatedDocumentsSchema);\n\n    const baseSchema: RxJsonSchema<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {\n        title: META_INSTANCE_SCHEMA_TITLE,\n        primaryKey: {\n            key: 'id',\n            fields: [\n                'itemId',\n                'isCheckpoint'\n            ],\n            separator: '|'\n        },\n        type: 'object',\n        version: replicatedDocumentsSchema.version,\n        additionalProperties: false,\n        properties: {\n            id: {\n                type: 'string',\n                minLength: 1,\n                // add +1 for the '|' and +1 for the 'isCheckpoint' flag\n                maxLength: parentPrimaryKeyLength + 2\n            },\n            isCheckpoint: {\n                type: 'string',\n                enum: [\n                    '0',\n                    '1'\n                ],\n                minLength: 1,\n                maxLength: 1\n            },\n            itemId: {\n                type: 'string',\n                /**\n                 * ensure that all values of RxStorageReplicationDirection ('DOWN' has 4 chars) fit into it\n                 * because checkpoints use the itemId field for that.\n                 */\n                maxLength: parentPrimaryKeyLength > 4 ? parentPrimaryKeyLength : 4\n            },\n            checkpointData: {\n                type: 'object',\n                additionalProperties: true\n            },\n            docData: {\n                type: 'object',\n                properties: replicatedDocumentsSchema.properties\n            },\n            isResolvedConflict: {\n                type: 'string'\n            }\n        },\n        keyCompression: replicatedDocumentsSchema.keyCompression,\n        required: [\n            'id',\n            'isCheckpoint',\n            'itemId'\n        ]\n    };\n    if (encrypted) {\n        baseSchema.encrypted = ['docData'];\n    }\n    const metaInstanceSchema: RxJsonSchema<RxDocumentData<RxStorageReplicationMeta<RxDocType, CheckpointType>>> = fillWithDefaultSettings(baseSchema);\n    return metaInstanceSchema;\n}\n\n\n\n/**\n * Returns the document states of what the fork instance\n * assumes to be the latest state on the master instance.\n */\nexport function getAssumedMasterState<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    docIds: string[]\n): Promise<ById<{\n    docData: WithDeleted<RxDocType>;\n    metaDocument: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\n}>> {\n    return state.input.metaInstance.findDocumentsById(\n        docIds.map(docId => {\n            const useId = getComposedPrimaryKeyOfDocumentData(\n                state.input.metaInstance.schema,\n                {\n                    itemId: docId,\n                    isCheckpoint: '0'\n                }\n            );\n            return useId;\n        }),\n        true\n    ).then(metaDocs => {\n        const ret: {\n            [docId: string]: {\n                docData: RxDocumentData<RxDocType>;\n                metaDocument: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>;\n            };\n        } = {};\n        Object\n            .values(metaDocs)\n            .forEach((metaDoc) => {\n                ret[metaDoc.itemId] = {\n                    docData: metaDoc.docData,\n                    metaDocument: metaDoc\n                };\n            });\n\n        return ret;\n    });\n}\n\n\nexport async function getMetaWriteRow<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    newMasterDocState: WithDeleted<RxDocType>,\n    previous?: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>>,\n    isResolvedConflict?: string\n): Promise<BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>> {\n    const docId: string = (newMasterDocState as any)[state.primaryPath];\n    const newMeta: RxDocumentData<RxStorageReplicationMeta<RxDocType, any>> = previous ? flatCloneDocWithMeta(\n        previous\n    ) : {\n        id: '',\n        isCheckpoint: '0',\n        itemId: docId,\n        docData: newMasterDocState,\n        _attachments: {},\n        _deleted: false,\n        _rev: getDefaultRevision(),\n        _meta: {\n            lwt: 0\n        }\n    };\n    newMeta.docData = newMasterDocState;\n\n    /**\n     * Sending isResolvedConflict with the value undefined\n     * will throw a schema validation error because it must be either\n     * not set or have a string.\n     */\n    if (isResolvedConflict) {\n        newMeta.isResolvedConflict = isResolvedConflict;\n    }\n\n    newMeta._meta.lwt = now();\n    newMeta.id = getComposedPrimaryKeyOfDocumentData(\n        state.input.metaInstance.schema,\n        newMeta\n    );\n    newMeta._rev = createRevision(\n        await state.checkpointKey,\n        previous\n    );\n\n    const ret = {\n        previous,\n        document: newMeta\n    };\n\n    return ret;\n}\n", "import {\n    firstValueFrom,\n    filter,\n    mergeMap\n} from 'rxjs';\nimport { newRxError } from '../rx-error.ts';\nimport { getWrittenDocumentsFromBulkWriteResponse, stackCheckpoints } from '../rx-storage-helper.ts';\nimport type {\n    RxStorageInstanceReplicationState,\n    BulkWriteRow,\n    BulkWriteRowById,\n    RxStorageReplicationMeta,\n    RxDocumentData,\n    ById,\n    WithDeleted,\n    DocumentsWithCheckpoint,\n    WithDeletedAndAttachments\n} from '../types/index.d.ts';\nimport {\n    appendToArray,\n    createRevision,\n    ensureNotFalsy,\n    flatClone,\n    getDefaultRevision,\n    getHeightOfRevision,\n    now,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint.ts';\nimport {\n    stripAttachmentsDataFromMetaWriteRows,\n    writeDocToDocState\n} from './helper.ts';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance.ts';\n\n/**\n * Writes all documents from the master to the fork.\n * The downstream has two operation modes\n * - Sync by iterating over the checkpoints via downstreamResyncOnce()\n * - Sync by listening to the changestream via downstreamProcessChanges()\n * We need this to be able to do initial syncs\n * and still can have fast event based sync when the client is not offline.\n */\nexport async function startReplicationDownstream<RxDocType, CheckpointType = any>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    if (\n        state.input.initialCheckpoint &&\n        state.input.initialCheckpoint.downstream\n    ) {\n        const checkpointDoc = await getLastCheckpointDoc(state, 'down');\n        if (!checkpointDoc) {\n            await setCheckpoint(\n                state,\n                'down',\n                state.input.initialCheckpoint.downstream\n            );\n        }\n    }\n\n    const identifierHash = await state.input.hashFunction(state.input.identifier);\n    const replicationHandler = state.input.replicationHandler;\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n\n\n    type Task = DocumentsWithCheckpoint<RxDocType, any> | 'RESYNC';\n    type TaskWithTime = {\n        time: number;\n        task: Task;\n    };\n    const openTasks: TaskWithTime[] = [];\n\n\n    function addNewTask(task: Task): void {\n        state.stats.down.addNewTask = state.stats.down.addNewTask + 1;\n        const taskWithTime = {\n            time: timer++,\n            task\n        };\n        openTasks.push(taskWithTime);\n        state.streamQueue.down = state.streamQueue.down\n            .then(() => {\n                const useTasks: Task[] = [];\n                while (openTasks.length > 0) {\n                    state.events.active.down.next(true);\n                    const innerTaskWithTime = ensureNotFalsy(openTasks.shift());\n\n                    /**\n                     * If the task came in before the last time we started the pull\n                     * from the master, then we can drop the task.\n                     */\n                    if (innerTaskWithTime.time < lastTimeMasterChangesRequested) {\n                        continue;\n                    }\n\n                    if (innerTaskWithTime.task === 'RESYNC') {\n                        if (useTasks.length === 0) {\n                            useTasks.push(innerTaskWithTime.task);\n                            break;\n                        } else {\n                            break;\n                        }\n                    }\n\n                    useTasks.push(innerTaskWithTime.task);\n                }\n                if (useTasks.length === 0) {\n                    return;\n                }\n\n                if (useTasks[0] === 'RESYNC') {\n                    return downstreamResyncOnce();\n                } else {\n                    return downstreamProcessChanges(useTasks);\n                }\n            }).then(() => {\n                state.events.active.down.next(false);\n                if (\n                    !state.firstSyncDone.down.getValue() &&\n                    !state.events.canceled.getValue()\n                ) {\n                    state.firstSyncDone.down.next(true);\n                }\n            });\n    }\n    addNewTask('RESYNC');\n\n    /**\n     * If a write on the master happens, we have to trigger the downstream.\n     * Only do this if not canceled yet, otherwise firstValueFrom errors\n     * when running on a completed observable.\n     */\n    if (!state.events.canceled.getValue()) {\n        const sub = replicationHandler\n            .masterChangeStream$\n            .pipe(\n                mergeMap(async (ev) => {\n                    /**\n                     * While a push is running, we have to delay all incoming\n                     * events from the server to not mix up the replication state.\n                     */\n                    await firstValueFrom(\n                        state.events.active.up.pipe(filter(s => !s))\n                    );\n                    return ev;\n                })\n            )\n            .subscribe((task: Task) => {\n                state.stats.down.masterChangeStreamEmit = state.stats.down.masterChangeStreamEmit + 1;\n                addNewTask(task);\n            });\n        firstValueFrom(\n            state.events.canceled.pipe(\n                filter(canceled => !!canceled)\n            )\n        ).then(() => sub.unsubscribe());\n    }\n\n\n    /**\n     * For faster performance, we directly start each write\n     * and then await all writes at the end.\n     */\n    let lastTimeMasterChangesRequested: number = -1;\n    async function downstreamResyncOnce() {\n        state.stats.down.downstreamResyncOnce = state.stats.down.downstreamResyncOnce + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'down'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n\n        const promises: Promise<any>[] = [];\n        while (!state.events.canceled.getValue()) {\n            lastTimeMasterChangesRequested = timer++;\n            const downResult = await replicationHandler.masterChangesSince(\n                lastCheckpoint,\n                state.input.pullBatchSize\n            );\n\n            if (downResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, downResult.checkpoint]);\n\n            promises.push(\n                persistFromMaster(\n                    downResult.documents,\n                    lastCheckpoint\n                )\n            );\n\n            /**\n             * By definition we stop pull when the pulled documents\n             * do not fill up the pullBatchSize because we\n             * can assume that the remote has no more documents.\n             */\n            if (downResult.documents.length < state.input.pullBatchSize) {\n                break;\n            }\n\n        }\n        await Promise.all(promises);\n    }\n\n\n    function downstreamProcessChanges(tasks: Task[]) {\n        state.stats.down.downstreamProcessChanges = state.stats.down.downstreamProcessChanges + 1;\n        const docsOfAllTasks: WithDeleted<RxDocType>[] = [];\n        let lastCheckpoint: CheckpointType | undefined = null as any;\n\n        tasks.forEach(task => {\n            if (task === 'RESYNC') {\n                throw new Error('SNH');\n            }\n            appendToArray(docsOfAllTasks, task.documents);\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, task.checkpoint]);\n        });\n        return persistFromMaster(\n            docsOfAllTasks,\n            ensureNotFalsy(lastCheckpoint)\n        );\n    }\n\n\n    /**\n     * It can happen that the calls to masterChangesSince() or the changeStream()\n     * are way faster then how fast the documents can be persisted.\n     * Therefore we merge all incoming downResults into the nonPersistedFromMaster object\n     * and process them together if possible.\n     * This often bundles up single writes and improves performance\n     * by processing the documents in bulks.\n     */\n    let persistenceQueue = PROMISE_RESOLVE_VOID;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<WithDeleted<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    function persistFromMaster(\n        docs: WithDeleted<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<void> {\n        const primaryPath = state.primaryPath;\n        state.stats.down.persistFromMaster = state.stats.down.persistFromMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistent list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n        /**\n         * Run in the queue\n         * with all open documents from nonPersistedFromMaster.\n         */\n        persistenceQueue = persistenceQueue.then(() => {\n\n            const downDocsById: ById<WithDeletedAndAttachments<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(downDocsById);\n\n            if (\n                state.events.canceled.getValue() ||\n                docIds.length === 0\n            ) {\n                return PROMISE_RESOLVE_VOID;\n            }\n\n            const writeRowsToFork: BulkWriteRow<RxDocType>[] = [];\n            const writeRowsToForkById: ById<BulkWriteRow<RxDocType>> = {};\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, CheckpointType>> = {};\n            const useMetaWriteRows: BulkWriteRow<RxStorageReplicationMeta<RxDocType, CheckpointType>>[] = [];\n\n            return Promise.all([\n                state.input.forkInstance.findDocumentsById(docIds, true),\n                getAssumedMasterState(\n                    state,\n                    docIds\n                )\n            ]).then(([\n                currentForkStateList,\n                assumedMasterState\n            ]) => {\n                const currentForkState = new Map<string, RxDocumentData<RxDocType>>();\n                currentForkStateList.forEach(doc => currentForkState.set((doc as any)[primaryPath], doc));\n                return Promise.all(\n                    docIds.map(async (docId) => {\n                        const forkStateFullDoc: RxDocumentData<RxDocType> | undefined = currentForkState.get(docId);\n                        const forkStateDocData: WithDeletedAndAttachments<RxDocType> | undefined = forkStateFullDoc\n                            ? writeDocToDocState(forkStateFullDoc, state.hasAttachments, false)\n                            : undefined\n                            ;\n                        const masterState = downDocsById[docId];\n                        const assumedMaster = assumedMasterState[docId];\n\n                        if (\n                            assumedMaster &&\n                            forkStateFullDoc &&\n                            assumedMaster.metaDocument.isResolvedConflict === forkStateFullDoc._rev\n                        ) {\n                            /**\n                             * The current fork state represents a resolved conflict\n                             * that first must be send to the master in the upstream.\n                             * All conflicts are resolved by the upstream.\n                             */\n                            // return PROMISE_RESOLVE_VOID;\n                            await state.streamQueue.up;\n                        }\n\n                        let isAssumedMasterEqualToForkState = !assumedMaster || !forkStateDocData ?\n                            false :\n                            await state.input.conflictHandler({\n                                realMasterState: assumedMaster.docData,\n                                newDocumentState: forkStateDocData\n                            }, 'downstream-check-if-equal-0').then(r => r.isEqual);\n                        if (\n                            !isAssumedMasterEqualToForkState &&\n                            (\n                                assumedMaster &&\n                                (assumedMaster.docData as any)._rev &&\n                                forkStateFullDoc &&\n                                forkStateFullDoc._meta[state.input.identifier] &&\n                                getHeightOfRevision(forkStateFullDoc._rev) === forkStateFullDoc._meta[state.input.identifier]\n                            )\n                        ) {\n                            isAssumedMasterEqualToForkState = true;\n                        }\n                        if (\n                            (\n                                forkStateFullDoc &&\n                                assumedMaster &&\n                                isAssumedMasterEqualToForkState === false\n                            ) ||\n                            (\n                                forkStateFullDoc && !assumedMaster\n                            )\n                        ) {\n                            /**\n                             * We have a non-upstream-replicated\n                             * local write to the fork.\n                             * This means we ignore the downstream of this document\n                             * because anyway the upstream will first resolve the conflict.\n                             */\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        const areStatesExactlyEqual = !forkStateDocData\n                            ? false\n                            : await state.input.conflictHandler(\n                                {\n                                    realMasterState: masterState,\n                                    newDocumentState: forkStateDocData\n                                },\n                                'downstream-check-if-equal-1'\n                            ).then(r => r.isEqual);\n                        if (\n                            forkStateDocData &&\n                            areStatesExactlyEqual\n                        ) {\n                            /**\n                             * Document states are exactly equal.\n                             * This can happen when the replication is shut down\n                             * unexpected like when the user goes offline.\n                             *\n                             * Only when the assumedMaster is different from the forkState,\n                             * we have to patch the document in the meta instance.\n                             */\n                            if (\n                                !assumedMaster ||\n                                isAssumedMasterEqualToForkState === false\n                            ) {\n                                useMetaWriteRows.push(\n                                    await getMetaWriteRow(\n                                        state,\n                                        forkStateDocData,\n                                        assumedMaster ? assumedMaster.metaDocument : undefined\n                                    )\n                                );\n                            }\n                            return PROMISE_RESOLVE_VOID;\n                        }\n\n                        /**\n                         * All other master states need to be written to the forkInstance\n                         * and metaInstance.\n                         */\n                        const newForkState = Object.assign(\n                            {},\n                            masterState,\n                            forkStateFullDoc ? {\n                                _meta: flatClone(forkStateFullDoc._meta),\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {},\n                                _rev: getDefaultRevision()\n                            } : {\n                                _meta: {\n                                    lwt: now()\n                                },\n                                _rev: getDefaultRevision(),\n                                _attachments: state.hasAttachments && masterState._attachments ? masterState._attachments : {}\n                            }\n                        );\n                        /**\n                         * If the remote works with revisions,\n                         * we store the height of the next fork-state revision\n                         * inside of the documents meta data.\n                         * By doing so we can filter it out in the upstream\n                         * and detect the document as being equal to master or not.\n                         * This is used for example in the CouchDB replication plugin.\n                         */\n                        if ((masterState as any)._rev) {\n                            const nextRevisionHeight = !forkStateFullDoc ? 1 : getHeightOfRevision(forkStateFullDoc._rev) + 1;\n                            newForkState._meta[state.input.identifier] = nextRevisionHeight;\n                            if (state.input.keepMeta) {\n                                newForkState._rev = (masterState as any)._rev;\n                            }\n                        }\n                        if (\n                            state.input.keepMeta &&\n                            (masterState as any)._meta\n                        ) {\n                            newForkState._meta = (masterState as any)._meta;\n                        }\n\n                        const forkWriteRow = {\n                            previous: forkStateFullDoc,\n                            document: newForkState\n                        };\n\n                        forkWriteRow.document._rev = forkWriteRow.document._rev ? forkWriteRow.document._rev : createRevision(\n                            identifierHash,\n                            forkWriteRow.previous\n                        );\n                        writeRowsToFork.push(forkWriteRow);\n                        writeRowsToForkById[docId] = forkWriteRow;\n                        writeRowsToMeta[docId] = await getMetaWriteRow(\n                            state,\n                            masterState,\n                            assumedMaster ? assumedMaster.metaDocument : undefined\n                        );\n                    })\n                );\n            }).then(async () => {\n                if (writeRowsToFork.length > 0) {\n                    return state.input.forkInstance.bulkWrite(\n                        writeRowsToFork,\n                        await state.downstreamBulkWriteFlag\n                    ).then((forkWriteResult) => {\n                        const success = getWrittenDocumentsFromBulkWriteResponse(\n                            state.primaryPath,\n                            writeRowsToFork,\n                            forkWriteResult\n                        );\n                        success.forEach(doc => {\n                            const docId = (doc as any)[primaryPath];\n                            state.events.processed.down.next(writeRowsToForkById[docId]);\n                            useMetaWriteRows.push(writeRowsToMeta[docId]);\n                        });\n                        forkWriteResult.error.forEach(error => {\n                            /**\n                             * We do not have to care about downstream conflict errors here\n                             * because on conflict, it will be solved locally and result in another write.\n                             */\n                            if (error.status === 409) {\n                                return;\n                            }\n                            // other non-conflict errors must be handled\n                            state.events.error.next(newRxError('RC_PULL', {\n                                writeError: error\n                            }));\n                        });\n                    });\n                }\n            }).then(() => {\n                if (useMetaWriteRows.length > 0) {\n                    return state.input.metaInstance.bulkWrite(\n                        stripAttachmentsDataFromMetaWriteRows(state, useMetaWriteRows),\n                        'replication-down-write-meta'\n                    ).then(metaWriteResult => {\n                        metaWriteResult.error\n                            .forEach(writeError => {\n                                state.events.error.next(newRxError('RC_PULL', {\n                                    id: writeError.documentId,\n                                    writeError\n                                }));\n                            });\n                    });\n                }\n            }).then(() => {\n                /**\n                 * For better performance we do not await checkpoint writes,\n                 * but to ensure order on parallel checkpoint writes,\n                 * we have to use a queue.\n                 */\n                setCheckpoint(\n                    state,\n                    'down',\n                    useCheckpoint\n                );\n            });\n        }).catch(unhandledError => state.events.error.next(unhandledError));\n        return persistenceQueue;\n    }\n}\n", "import type {\n    RxConflictHandler,\n    RxConflictHandlerInput,\n    RxConflictHandlerOutput,\n    RxDocumentData,\n    RxStorageInstanceReplicationState\n} from '../types/index.d.ts';\nimport {\n    getDefaultRevision,\n    createRevision,\n    now,\n    flatClone,\n    deepEqual\n} from '../plugins/utils/index.ts';\nimport { stripAttachmentsDataFromDocument } from '../rx-storage-helper.ts';\n\nexport const defaultConflictHandler: RxConflictHandler<any> = function (\n    i: RxConflictHandlerInput<any>,\n    _context: string\n): Promise<RxConflictHandlerOutput<any>> {\n    const newDocumentState = stripAttachmentsDataFromDocument(i.newDocumentState);\n    const realMasterState = stripAttachmentsDataFromDocument(i.realMasterState);\n\n    /**\n     * If the documents are deep equal,\n     * we have no conflict.\n     * On your custom conflict handler you might only\n     * check some properties, like the updatedAt time,\n     * for better performance, because deepEqual is expensive.\n     */\n    if (deepEqual(\n        newDocumentState,\n        realMasterState\n    )) {\n        return Promise.resolve({\n            isEqual: true\n        });\n    }\n\n    /**\n     * The default conflict handler will always\n     * drop the fork state and use the master state instead.\n     */\n    return Promise.resolve({\n        isEqual: false,\n        documentData: i.realMasterState\n    });\n};\n\n\n/**\n * Resolves a conflict error or determines that the given document states are equal.\n * Returns the resolved document that must be written to the fork.\n * Then the new document state can be pushed upstream.\n * If document is not in conflict, returns undefined.\n * If error is non-409, it throws an error.\n * Conflicts are only solved in the upstream, never in the downstream.\n */\nexport async function resolveConflictError<RxDocType>(\n    state: RxStorageInstanceReplicationState<RxDocType>,\n    input: RxConflictHandlerInput<RxDocType>,\n    forkState: RxDocumentData<RxDocType>\n): Promise<{\n    resolvedDoc: RxDocumentData<RxDocType>;\n    output: RxConflictHandlerOutput<RxDocType>;\n} | undefined> {\n    const conflictHandler: RxConflictHandler<RxDocType> = state.input.conflictHandler;\n    const conflictHandlerOutput = await conflictHandler(input, 'replication-resolve-conflict');\n\n    if (conflictHandlerOutput.isEqual) {\n        /**\n         * Documents are equal,\n         * so this is not a conflict -> do nothing.\n         */\n        return undefined;\n    } else {\n        /**\n         * We have a resolved conflict,\n         * use the resolved document data.\n         */\n        const resolvedDoc: RxDocumentData<RxDocType> = Object.assign(\n            {},\n            conflictHandlerOutput.documentData,\n            {\n                /**\n                 * Because the resolved conflict is written to the fork,\n                 * we have to keep/update the forks _meta data, not the masters.\n                 */\n                _meta: flatClone(forkState._meta),\n                _rev: getDefaultRevision(),\n                _attachments: flatClone(forkState._attachments)\n            }\n        ) as any;\n        resolvedDoc._meta.lwt = now();\n        resolvedDoc._rev = createRevision(\n            await state.checkpointKey,\n            forkState\n        );\n        return {\n            resolvedDoc,\n            output: conflictHandlerOutput\n        };\n    }\n}\n", "import { newRxError } from '../../rx-error.ts';\nimport type {\n    RxAttachmentWriteData,\n    RxStorageInstance,\n    WithDeletedAndAttachments\n} from '../../types/index.d.ts';\nimport { ensureNotFalsy } from '../utils/index.ts';\n\nexport function ensureSchemaSupportsAttachments(doc: any) {\n    const schemaJson = doc.collection.schema.jsonSchema;\n    if (!schemaJson.attachments) {\n        throw newRxError('AT1', {\n            link: 'https://pubkey.github.io/rxdb/rx-attachment.html'\n        });\n    }\n}\n\nexport function assignMethodsToAttachment(attachment: any) {\n    Object\n        .entries(attachment.doc.collection.attachments)\n        .forEach(([funName, fun]) => {\n            Object.defineProperty(attachment, funName, {\n                get: () => (fun as any).bind(attachment)\n            });\n        });\n}\n\n/**\n * Fill up the missing attachment.data of the newDocument\n * so that the new document can be send to somewhere else\n * which could then receive all required attachments data\n * that it did not have before.\n */\nexport async function fillWriteDataForAttachmentsChange<RxDocType>(\n    primaryPath: string,\n    storageInstance: RxStorageInstance<RxDocType, any, any, any>,\n    newDocument: WithDeletedAndAttachments<RxDocType>,\n    originalDocument?: WithDeletedAndAttachments<RxDocType>\n): Promise<WithDeletedAndAttachments<RxDocType>> {\n\n    if (\n        !newDocument._attachments ||\n        (\n            originalDocument &&\n            !originalDocument._attachments\n        )\n    ) {\n        throw new Error('_attachments missing');\n    }\n\n    const docId: string = (newDocument as any)[primaryPath];\n    const originalAttachmentsIds = new Set(\n        originalDocument && originalDocument._attachments\n            ? Object.keys(originalDocument._attachments)\n            : []\n    );\n    await Promise.all(\n        Object\n            .entries(newDocument._attachments)\n            .map(async ([key, value]) => {\n                if (\n                    (\n                        !originalAttachmentsIds.has(key) ||\n                        (\n                            originalDocument &&\n                            ensureNotFalsy(originalDocument._attachments)[key].digest !== value.digest\n                        )\n                    ) &&\n                    !(value as RxAttachmentWriteData).data\n                ) {\n                    const attachmentDataString = await storageInstance.getAttachmentData(\n                        docId,\n                        key,\n                        value.digest\n                    );\n                    (value as RxAttachmentWriteData).data = attachmentDataString;\n                }\n            })\n    );\n\n    return newDocument;\n}\n", "import {\n    map\n} from 'rxjs';\n\nimport {\n    blobToBase64String,\n    blobToString,\n    createBlobFromBase64,\n    flatClone,\n    getBlobSize,\n    PROMISE_RESOLVE_VOID\n} from '../../plugins/utils/index.ts';\nimport type {\n    RxDocument,\n    RxPlugin,\n    RxDocumentWriteData,\n    RxAttachmentData,\n    RxDocumentData,\n    RxAttachmentCreator,\n    RxAttachmentWriteData\n} from '../../types/index.ts';\nimport {\n    assignMethodsToAttachment,\n    ensureSchemaSupportsAttachments\n} from './attachments-utils.ts';\n\n\n\n/**\n * an RxAttachment is basically just the attachment-stub\n * wrapped so that you can access the attachment-data\n */\nexport class RxAttachment {\n    public doc: RxDocument;\n    public id: string;\n    public type: string;\n    public length: number;\n    public digest: string;\n    constructor({\n        doc,\n        id,\n        type,\n        length,\n        digest\n    }: any) {\n        this.doc = doc;\n        this.id = id;\n        this.type = type;\n        this.length = length;\n        this.digest = digest;\n\n        assignMethodsToAttachment(this);\n    }\n\n    remove(): Promise<void> {\n        return this.doc.collection.incrementalWriteQueue.addWrite(\n            this.doc._data,\n            docWriteData => {\n                delete docWriteData._attachments[this.id];\n                return docWriteData;\n            }\n        ).then(() => { });\n    }\n\n    /**\n     * returns the data for the attachment\n     */\n    async getData(): Promise<Blob> {\n        const plainDataBase64 = await this.doc.collection.storageInstance.getAttachmentData(\n            this.doc.primary,\n            this.id,\n            this.digest\n        );\n        const ret = await createBlobFromBase64(\n            plainDataBase64,\n            this.type as any\n        );\n        return ret;\n    }\n\n    async getStringData(): Promise<string> {\n        const data = await this.getData();\n        const asString = await blobToString(data);\n        return asString;\n    }\n}\n\nexport function fromStorageInstanceResult<RxDocType>(\n    id: string,\n    attachmentData: RxAttachmentData,\n    rxDocument: RxDocument<RxDocType>\n) {\n    return new RxAttachment({\n        doc: rxDocument,\n        id,\n        type: attachmentData.type,\n        length: attachmentData.length,\n        digest: attachmentData.digest\n    });\n}\n\n\n\nexport async function putAttachment<RxDocType>(\n    this: RxDocument<RxDocType>,\n    attachmentData: RxAttachmentCreator\n): Promise<RxAttachment> {\n    ensureSchemaSupportsAttachments(this);\n\n    const dataSize = getBlobSize(attachmentData.data);\n    const dataString = await blobToBase64String(attachmentData.data);\n    const digest = await this.collection.database.hashFunction(dataString);\n\n    const id = attachmentData.id;\n    const type = attachmentData.type;\n    const data = dataString;\n\n    return this.collection.incrementalWriteQueue.addWrite(\n        this._data,\n        (docWriteData: RxDocumentWriteData<RxDocType>) => {\n            docWriteData = flatClone(docWriteData);\n            docWriteData._attachments = flatClone(docWriteData._attachments);\n            docWriteData._attachments[id] = {\n                length: dataSize,\n                type,\n                data,\n                digest\n            };\n            return docWriteData;\n        }).then(writeResult => {\n            const newDocument = this.collection._docCache.getCachedRxDocument(writeResult);\n            const attachmentDataOfId = writeResult._attachments[id];\n            const attachment = fromStorageInstanceResult(\n                id,\n                attachmentDataOfId,\n                newDocument\n            );\n            return attachment;\n        });\n}\n\n/**\n * get an attachment of the document by its id\n */\nexport function getAttachment(\n    this: RxDocument,\n    id: string\n): RxAttachment | null {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._data;\n    if (!docData._attachments || !docData._attachments[id])\n        return null;\n\n    const attachmentData = docData._attachments[id];\n    const attachment = fromStorageInstanceResult(\n        id,\n        attachmentData,\n        this\n    );\n    return attachment;\n}\n\n/**\n * returns all attachments of the document\n */\nexport function allAttachments(\n    this: RxDocument\n): RxAttachment[] {\n    ensureSchemaSupportsAttachments(this);\n    const docData: any = this._data;\n\n    // if there are no attachments, the field is missing\n    if (!docData._attachments) {\n        return [];\n    }\n    return Object.keys(docData._attachments)\n        .map(id => {\n            return fromStorageInstanceResult(\n                id,\n                docData._attachments[id],\n                this\n            );\n        });\n}\n\nexport async function preMigrateDocument<RxDocType>(\n    data: {\n        docData: RxDocumentData<RxDocType>;\n        oldCollection: any; // TODO\n    }\n): Promise<void> {\n    const attachments = data.docData._attachments;\n    if (attachments) {\n        const newAttachments: { [attachmentId: string]: RxAttachmentWriteData; } = {};\n        await Promise.all(\n            Object.keys(attachments).map(async (attachmentId) => {\n                const attachment: RxAttachmentData = attachments[attachmentId];\n                const docPrimary: string = (data.docData as any)[data.oldCollection.schema.primaryPath];\n                const rawAttachmentData = await data.oldCollection.storageInstance.getAttachmentData(\n                    docPrimary,\n                    attachmentId,\n                    attachment.digest\n                );\n                const digest = await data.oldCollection.database.hashFunction(rawAttachmentData);\n                newAttachments[attachmentId] = {\n                    length: attachment.length,\n                    type: attachment.type,\n                    data: rawAttachmentData,\n                    digest\n                };\n            })\n        );\n\n        /**\n         * Hooks mutate the input\n         * instead of returning stuff\n         */\n        (data.docData as RxDocumentWriteData<RxDocType>)._attachments = newAttachments;\n    }\n}\n\nexport function postMigrateDocument(_action: any): Promise<void> {\n    /**\n     * No longer needed because\n     * we store the attachments data buffers directly in the document.\n     */\n    return PROMISE_RESOLVE_VOID;\n}\n\nexport const RxDBAttachmentsPlugin: RxPlugin = {\n    name: 'attachments',\n    rxdb: true,\n    prototypes: {\n        RxDocument: (proto: any) => {\n            proto.putAttachment = putAttachment;\n            proto.getAttachment = getAttachment;\n            proto.allAttachments = allAttachments;\n            Object.defineProperty(proto, 'allAttachments$', {\n                get: function allAttachments$(this: RxDocument) {\n                    return this.$\n                        .pipe(\n                            map(rxDocument => Object.entries(\n                                rxDocument.toJSON(true)._attachments\n                            )),\n                            map(entries => {\n                                return (entries as any)\n                                    .map(([id, attachmentData]: any) => {\n                                        return fromStorageInstanceResult(\n                                            id,\n                                            attachmentData,\n                                            this\n                                        );\n                                    });\n                            })\n                        );\n                }\n            });\n        }\n    },\n    overwritable: {},\n    hooks: {\n        preMigrateDocument: {\n            after: preMigrateDocument\n        },\n        postMigrateDocument: {\n            after: postMigrateDocument\n        }\n    }\n};\n\n\nexport * from './attachments-utils.ts';\n", "import { firstValueFrom, filter } from 'rxjs';\nimport {\n    getChangedDocumentsSince,\n    getWrittenDocumentsFromBulkWriteResponse,\n    stackCheckpoints\n} from '../rx-storage-helper.ts';\nimport type {\n    BulkWriteRow,\n    BulkWriteRowById,\n    ById,\n    EventBulk,\n    RxDocumentData,\n    RxReplicationWriteToMasterRow,\n    RxStorageChangeEvent,\n    RxStorageInstanceReplicationState,\n    RxStorageReplicationMeta,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    appendToArray,\n    batchArray,\n    clone,\n    ensureNotFalsy,\n    getHeightOfRevision,\n    PROMISE_RESOLVE_FALSE\n} from '../plugins/utils/index.ts';\nimport {\n    getLastCheckpointDoc,\n    setCheckpoint\n} from './checkpoint.ts';\nimport {\n    resolveConflictError\n} from './conflicts.ts';\nimport {\n    stripAttachmentsDataFromMetaWriteRows,\n    writeDocToDocState\n} from './helper.ts';\nimport {\n    getAssumedMasterState,\n    getMetaWriteRow\n} from './meta-instance.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\n\n/**\n * Writes all document changes from the fork to the master.\n * The upstream runs on two modes:\n * - For initial replication, a checkpoint-iteration is used\n * - For ongoing local writes, we just subscribe to the changeStream of the fork.\n *   In contrast to the master, the fork can be assumed to never loose connection,\n *   so we do not have to prepare for missed out events.\n */\nexport async function startReplicationUpstream<RxDocType, CheckpointType>(\n    state: RxStorageInstanceReplicationState<RxDocType>\n) {\n    if (\n        state.input.initialCheckpoint &&\n        state.input.initialCheckpoint.upstream\n    ) {\n        const checkpointDoc = await getLastCheckpointDoc(state, 'up');\n        if (!checkpointDoc) {\n            await setCheckpoint(\n                state,\n                'up',\n                state.input.initialCheckpoint.upstream\n            );\n        }\n    }\n\n    const replicationHandler = state.input.replicationHandler;\n    state.streamQueue.up = state.streamQueue.up.then(() => {\n        return upstreamInitialSync().then(() => {\n            processTasks();\n        });\n    });\n\n    // used to detect which tasks etc can in it at which order.\n    let timer = 0;\n    let initialSyncStartTime = -1;\n\n    type Task = EventBulk<RxStorageChangeEvent<RxDocType>, any>;\n    type TaskWithTime = {\n        task: Task;\n        time: number;\n    };\n    const openTasks: TaskWithTime[] = [];\n    let persistenceQueue: Promise<boolean> = PROMISE_RESOLVE_FALSE;\n    const nonPersistedFromMaster: {\n        checkpoint?: CheckpointType;\n        docs: ById<RxDocumentData<RxDocType>>;\n    } = {\n        docs: {}\n    };\n\n    const sub = state.input.forkInstance.changeStream()\n        .subscribe(async (eventBulk) => {\n            // ignore writes that came from the downstream\n            if (eventBulk.context === await state.downstreamBulkWriteFlag) {\n                return;\n            }\n\n            state.stats.up.forkChangeStreamEmit = state.stats.up.forkChangeStreamEmit + 1;\n            openTasks.push({\n                task: eventBulk,\n                time: timer++\n            });\n            if (!state.events.active.up.getValue()) {\n                state.events.active.up.next(true);\n            }\n            if (state.input.waitBeforePersist) {\n                return state.input.waitBeforePersist()\n                    .then(() => processTasks());\n            } else {\n                return processTasks();\n            }\n        });\n    firstValueFrom(\n        state.events.canceled.pipe(\n            filter(canceled => !!canceled)\n        )\n    ).then(() => sub.unsubscribe());\n\n\n    async function upstreamInitialSync() {\n        state.stats.up.upstreamInitialSync = state.stats.up.upstreamInitialSync + 1;\n        if (state.events.canceled.getValue()) {\n            return;\n        }\n\n        state.checkpointQueue = state.checkpointQueue.then(() => getLastCheckpointDoc(state, 'up'));\n        let lastCheckpoint: CheckpointType = await state.checkpointQueue;\n\n        const promises: Set<Promise<any>> = new Set();\n\n        while (!state.events.canceled.getValue()) {\n            initialSyncStartTime = timer++;\n\n            /**\n             * Throttle the calls to\n             * forkInstance.getChangedDocumentsSince() so that\n             * if the pushing to the remote is slower compared to the\n             * pulling out of forkInstance, we do not block the UI too much\n             * and have a big memory spike with all forkInstance documents.\n             */\n            if (promises.size > 3) {\n                await Promise.race(Array.from(promises));\n            }\n\n            const upResult = await getChangedDocumentsSince(\n                state.input.forkInstance,\n                state.input.pushBatchSize,\n                lastCheckpoint\n            );\n            if (upResult.documents.length === 0) {\n                break;\n            }\n\n            lastCheckpoint = stackCheckpoints([lastCheckpoint, upResult.checkpoint]);\n\n            const promise = persistToMaster(\n                upResult.documents,\n                ensureNotFalsy(lastCheckpoint)\n            );\n            promises.add(promise);\n            promise.catch().then(() => promises.delete(promise));\n        }\n\n        /**\n         * If we had conflicts during the initial sync,\n         * it means that we likely have new writes to the fork\n         * and so we have to run the initial sync again to upstream these new writes.\n         */\n        const resolvedPromises = await Promise.all(promises);\n        const hadConflicts = resolvedPromises.find(r => !!r);\n        if (hadConflicts) {\n            await upstreamInitialSync();\n        } else if (\n            !state.firstSyncDone.up.getValue() &&\n            !state.events.canceled.getValue()\n        ) {\n            state.firstSyncDone.up.next(true);\n        }\n    }\n\n\n    /**\n     * Takes all open tasks an processes them at once.\n     */\n    function processTasks() {\n        if (\n            state.events.canceled.getValue() ||\n            openTasks.length === 0\n        ) {\n            state.events.active.up.next(false);\n            return;\n        }\n        state.stats.up.processTasks = state.stats.up.processTasks + 1;\n        state.events.active.up.next(true);\n        state.streamQueue.up = state.streamQueue.up.then(() => {\n            /**\n             * Merge/filter all open tasks\n             */\n            const docs: RxDocumentData<RxDocType>[] = [];\n            let checkpoint: CheckpointType = {} as any;\n            while (openTasks.length > 0) {\n                const taskWithTime = ensureNotFalsy(openTasks.shift());\n                /**\n                 * If the task came in before the last time the initial sync fetching\n                 * has run, we can ignore the task because the initial sync already processed\n                 * these documents.\n                 */\n                if (taskWithTime.time < initialSyncStartTime) {\n                    continue;\n                }\n                appendToArray(\n                    docs,\n                    taskWithTime.task.events.map(r => {\n                        return r.documentData as any;\n                    })\n                );\n                checkpoint = stackCheckpoints([checkpoint, taskWithTime.task.checkpoint]);\n            }\n\n            const promise = docs.length === 0 ? PROMISE_RESOLVE_FALSE : persistToMaster(\n                docs,\n                checkpoint\n            );\n            return promise.then(() => {\n                if (openTasks.length === 0) {\n                    state.events.active.up.next(false);\n                } else {\n                    processTasks();\n                }\n            });\n        });\n    }\n\n    /**\n     * Returns true if had conflicts,\n     * false if not.\n     */\n    function persistToMaster(\n        docs: RxDocumentData<RxDocType>[],\n        checkpoint: CheckpointType\n    ): Promise<boolean> {\n        state.stats.up.persistToMaster = state.stats.up.persistToMaster + 1;\n\n        /**\n         * Add the new docs to the non-persistent list\n         */\n        docs.forEach(docData => {\n            const docId: string = (docData as any)[state.primaryPath];\n            nonPersistedFromMaster.docs[docId] = docData;\n        });\n        nonPersistedFromMaster.checkpoint = checkpoint;\n\n        persistenceQueue = persistenceQueue.then(async () => {\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            const upDocsById: ById<RxDocumentData<RxDocType>> = nonPersistedFromMaster.docs;\n            nonPersistedFromMaster.docs = {};\n            const useCheckpoint = nonPersistedFromMaster.checkpoint;\n            const docIds = Object.keys(upDocsById);\n            if (docIds.length === 0) {\n                return false;\n            }\n\n            const assumedMasterState = await getAssumedMasterState(\n                state,\n                docIds\n            );\n\n            const writeRowsToMaster: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            const writeRowsToMasterIds: string[] = [];\n            const writeRowsToMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n            const forkStateById: ById<RxDocumentData<RxDocType>> = {};\n\n            await Promise.all(\n                docIds.map(async (docId) => {\n                    const fullDocData: RxDocumentData<RxDocType> = upDocsById[docId];\n                    forkStateById[docId] = fullDocData;\n                    const docData: WithDeleted<RxDocType> = writeDocToDocState(fullDocData, state.hasAttachments, !!state.input.keepMeta);\n                    const assumedMasterDoc = assumedMasterState[docId];\n\n                    /**\n                     * If the master state is equal to the\n                     * fork state, we can assume that the document state is already\n                     * replicated.\n                     */\n                    if (\n                        (\n                            assumedMasterDoc &&\n                            // if the isResolvedConflict is correct, we do not have to compare the documents.\n                            assumedMasterDoc.metaDocument.isResolvedConflict !== fullDocData._rev\n                            &&\n                            (await state.input.conflictHandler({\n                                realMasterState: assumedMasterDoc.docData,\n                                newDocumentState: docData\n                            }, 'upstream-check-if-equal')).isEqual\n                        )\n                        ||\n                        /**\n                         * If the master works with _rev fields,\n                         * we use that to check if our current doc state\n                         * is different from the assumedMasterDoc.\n                         */\n                        (\n                            assumedMasterDoc &&\n                            (assumedMasterDoc.docData as any)._rev &&\n                            getHeightOfRevision(fullDocData._rev) === fullDocData._meta[state.input.identifier]\n                        )\n                    ) {\n                        return;\n                    }\n\n                    writeRowsToMasterIds.push(docId);\n\n                    writeRowsToMaster[docId] = {\n                        assumedMasterState: assumedMasterDoc ? assumedMasterDoc.docData : undefined,\n                        newDocumentState: docData\n                    };\n                    writeRowsToMeta[docId] = await getMetaWriteRow(\n                        state,\n                        docData,\n                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined\n                    );\n                })\n            );\n\n            if (writeRowsToMasterIds.length === 0) {\n                return false;\n            }\n\n\n            const writeRowsArray = Object.values(writeRowsToMaster);\n            const conflictIds: Set<string> = new Set();\n            const conflictsById: ById<WithDeleted<RxDocType>> = {};\n\n            /**\n             * To always respect the push.batchSize,\n             * we have to split the write rows into batches\n             * to ensure that replicationHandler.masterWrite() is never\n             * called with more documents than what the batchSize limits.\n             */\n            const writeBatches = batchArray(writeRowsArray, state.input.pushBatchSize);\n            await Promise.all(\n                writeBatches.map(async (writeBatch) => {\n\n                    // enhance docs with attachments\n                    if (state.hasAttachments) {\n                        await Promise.all(\n                            writeBatch.map(async (row) => {\n                                row.newDocumentState = await fillWriteDataForAttachmentsChange(\n                                    state.primaryPath,\n                                    state.input.forkInstance,\n                                    clone(row.newDocumentState),\n                                    row.assumedMasterState\n                                );\n                            })\n                        );\n                    }\n                    const masterWriteResult = await replicationHandler.masterWrite(writeBatch);\n                    masterWriteResult.forEach(conflictDoc => {\n                        const id = (conflictDoc as any)[state.primaryPath];\n                        conflictIds.add(id);\n                        conflictsById[id] = conflictDoc;\n                    });\n                })\n            );\n\n            const useWriteRowsToMeta: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n\n            writeRowsToMasterIds.forEach(docId => {\n                if (!conflictIds.has(docId)) {\n                    state.events.processed.up.next(writeRowsToMaster[docId]);\n                    useWriteRowsToMeta.push(writeRowsToMeta[docId]);\n                }\n            });\n\n            if (state.events.canceled.getValue()) {\n                return false;\n            }\n\n            if (useWriteRowsToMeta.length > 0) {\n                await state.input.metaInstance.bulkWrite(\n                    stripAttachmentsDataFromMetaWriteRows(state, useWriteRowsToMeta),\n                    'replication-up-write-meta'\n                );\n                // TODO what happens when we have conflicts here?\n            }\n\n            /**\n             * Resolve conflicts by writing a new document\n             * state to the fork instance and the 'real' master state\n             * to the meta instance.\n             * Non-409 errors will be detected by resolveConflictError()\n             */\n            let hadConflictWrites = false;\n            if (conflictIds.size > 0) {\n                state.stats.up.persistToMasterHadConflicts = state.stats.up.persistToMasterHadConflicts + 1;\n                const conflictWriteFork: BulkWriteRow<RxDocType>[] = [];\n                const conflictWriteMeta: BulkWriteRowById<RxStorageReplicationMeta<RxDocType, any>> = {};\n                await Promise.all(\n                    Object\n                        .entries(conflictsById)\n                        .map(([docId, realMasterState]) => {\n                            const writeToMasterRow = writeRowsToMaster[docId];\n                            const input = {\n                                newDocumentState: writeToMasterRow.newDocumentState,\n                                assumedMasterState: writeToMasterRow.assumedMasterState,\n                                realMasterState\n                            };\n                            return resolveConflictError(\n                                state,\n                                input,\n                                forkStateById[docId]\n                            ).then(async (resolved) => {\n                                if (resolved) {\n                                    state.events.resolvedConflicts.next({\n                                        input,\n                                        output: resolved.output\n                                    });\n                                    conflictWriteFork.push({\n                                        previous: forkStateById[docId],\n                                        document: resolved.resolvedDoc\n                                    });\n                                    const assumedMasterDoc = assumedMasterState[docId];\n                                    conflictWriteMeta[docId] = await getMetaWriteRow(\n                                        state,\n                                        ensureNotFalsy(realMasterState),\n                                        assumedMasterDoc ? assumedMasterDoc.metaDocument : undefined,\n                                        resolved.resolvedDoc._rev\n                                    );\n                                }\n                            });\n                        })\n                );\n\n                if (conflictWriteFork.length > 0) {\n                    hadConflictWrites = true;\n\n                    state.stats.up.persistToMasterConflictWrites = state.stats.up.persistToMasterConflictWrites + 1;\n                    const forkWriteResult = await state.input.forkInstance.bulkWrite(\n                        conflictWriteFork,\n                        'replication-up-write-conflict'\n                    );\n                    /**\n                     * Errors in the forkWriteResult must not be handled\n                     * because they have been caused by a write to the forkInstance\n                     * in between which will anyway trigger a new upstream cycle\n                     * that will then resolved the conflict again.\n                     */\n                    const useMetaWrites: BulkWriteRow<RxStorageReplicationMeta<RxDocType, any>>[] = [];\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\n                        state.primaryPath,\n                        conflictWriteFork,\n                        forkWriteResult\n                    );\n                    success\n                        .forEach(docData => {\n                            const docId = (docData as any)[state.primaryPath];\n                            useMetaWrites.push(\n                                conflictWriteMeta[docId]\n                            );\n                        });\n                    if (useMetaWrites.length > 0) {\n                        await state.input.metaInstance.bulkWrite(\n                            stripAttachmentsDataFromMetaWriteRows(state, useMetaWrites),\n                            'replication-up-write-conflict-meta'\n                        );\n                    }\n                    // TODO what to do with conflicts while writing to the metaInstance?\n                }\n            }\n\n            /**\n             * For better performance we do not await checkpoint writes,\n             * but to ensure order on parallel checkpoint writes,\n             * we have to use a queue.\n             */\n            setCheckpoint(\n                state,\n                'up',\n                useCheckpoint\n            );\n\n            return hadConflictWrites;\n        }).catch(unhandledError => {\n            state.events.error.next(unhandledError);\n            return false;\n        });\n\n        return persistenceQueue;\n    }\n}\n", "/**\n * These files contain the replication protocol.\n * It can be used to replicated RxStorageInstances or RxCollections\n * or even to do a client(s)-server replication.\n */\n\n\nimport {\n    BehaviorSubject,\n    combineLatest,\n    filter,\n    firstValueFrom,\n    mergeMap,\n    Subject\n} from 'rxjs';\nimport {\n    getPrimaryFieldOfPrimaryKey\n} from '../rx-schema-helper.ts';\nimport type {\n    BulkWriteRow,\n    ById,\n    DocumentsWithCheckpoint,\n    RxConflictHandler,\n    RxDocumentData,\n    RxReplicationHandler,\n    RxReplicationWriteToMasterRow,\n    RxStorageInstance,\n    RxStorageInstanceReplicationInput,\n    RxStorageInstanceReplicationState,\n    WithDeleted\n} from '../types/index.d.ts';\nimport {\n    clone,\n    ensureNotFalsy,\n    flatClone,\n    PROMISE_RESOLVE_VOID\n} from '../plugins/utils/index.ts';\nimport {\n    getCheckpointKey\n} from './checkpoint.ts';\nimport { startReplicationDownstream } from './downstream.ts';\nimport { docStateToWriteDoc, getUnderlyingPersistentStorage, writeDocToDocState } from './helper.ts';\nimport { startReplicationUpstream } from './upstream.ts';\nimport { fillWriteDataForAttachmentsChange } from '../plugins/attachments/index.ts';\nimport { getChangedDocumentsSince } from '../rx-storage-helper.ts';\n\n\nexport * from './checkpoint.ts';\nexport * from './downstream.ts';\nexport * from './upstream.ts';\nexport * from './meta-instance.ts';\nexport * from './conflicts.ts';\nexport * from './helper.ts';\n\n\nexport function replicateRxStorageInstance<RxDocType>(\n    input: RxStorageInstanceReplicationInput<RxDocType>\n): RxStorageInstanceReplicationState<RxDocType> {\n    input = flatClone(input);\n    input.forkInstance = getUnderlyingPersistentStorage(input.forkInstance);\n    input.metaInstance = getUnderlyingPersistentStorage(input.metaInstance);\n    const checkpointKeyPromise = getCheckpointKey(input);\n    const state: RxStorageInstanceReplicationState<RxDocType> = {\n        primaryPath: getPrimaryFieldOfPrimaryKey(input.forkInstance.schema.primaryKey),\n        hasAttachments: !!input.forkInstance.schema.attachments,\n        input,\n        checkpointKey: checkpointKeyPromise,\n        downstreamBulkWriteFlag: checkpointKeyPromise.then(checkpointKey => 'replication-downstream-' + checkpointKey),\n        events: {\n            canceled: new BehaviorSubject<boolean>(false),\n            active: {\n                down: new BehaviorSubject<boolean>(true),\n                up: new BehaviorSubject<boolean>(true)\n            },\n            processed: {\n                down: new Subject(),\n                up: new Subject()\n            },\n            resolvedConflicts: new Subject(),\n            error: new Subject()\n        },\n        stats: {\n            down: {\n                addNewTask: 0,\n                downstreamProcessChanges: 0,\n                downstreamResyncOnce: 0,\n                masterChangeStreamEmit: 0,\n                persistFromMaster: 0\n            },\n            up: {\n                forkChangeStreamEmit: 0,\n                persistToMaster: 0,\n                persistToMasterConflictWrites: 0,\n                persistToMasterHadConflicts: 0,\n                processTasks: 0,\n                upstreamInitialSync: 0\n            }\n        },\n        firstSyncDone: {\n            down: new BehaviorSubject<boolean>(false),\n            up: new BehaviorSubject<boolean>(false)\n        },\n        streamQueue: {\n            down: PROMISE_RESOLVE_VOID,\n            up: PROMISE_RESOLVE_VOID\n        },\n        checkpointQueue: PROMISE_RESOLVE_VOID,\n        lastCheckpointDoc: {}\n    };\n\n    startReplicationDownstream(state);\n    startReplicationUpstream(state);\n    return state;\n}\n\nexport function awaitRxStorageReplicationFirstInSync(\n    state: RxStorageInstanceReplicationState<any>\n): Promise<void> {\n    return firstValueFrom(\n        combineLatest([\n            state.firstSyncDone.down.pipe(\n                filter(v => !!v)\n            ),\n            state.firstSyncDone.up.pipe(\n                filter(v => !!v)\n            )\n        ])\n    ).then(() => { });\n}\n\nexport function awaitRxStorageReplicationInSync(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    return Promise.all([\n        replicationState.streamQueue.up,\n        replicationState.streamQueue.down,\n        replicationState.checkpointQueue\n    ]);\n}\n\n\nexport async function awaitRxStorageReplicationIdle(\n    state: RxStorageInstanceReplicationState<any>\n) {\n    await awaitRxStorageReplicationFirstInSync(state);\n    while (true) {\n        const { down, up } = state.streamQueue;\n        await Promise.all([\n            up,\n            down\n        ]);\n        /**\n         * If the Promises have not been reassigned\n         * after awaiting them, we know that the replication\n         * is in idle state at this point in time.\n         */\n        if (\n            down === state.streamQueue.down &&\n            up === state.streamQueue.up\n        ) {\n            return;\n        }\n    }\n}\n\n\nexport function rxStorageInstanceToReplicationHandler<RxDocType, MasterCheckpointType>(\n    instance: RxStorageInstance<RxDocType, any, any, MasterCheckpointType>,\n    conflictHandler: RxConflictHandler<RxDocType>,\n    databaseInstanceToken: string,\n    /**\n     * If set to true,\n     * the _meta.lwt from the pushed documents is kept.\n     * (Used in the migration to ensure checkpoints are still valid)\n     */\n    keepMeta: boolean = false\n): RxReplicationHandler<RxDocType, MasterCheckpointType> {\n    instance = getUnderlyingPersistentStorage(instance);\n\n    const hasAttachments = !!instance.schema.attachments;\n    const primaryPath = getPrimaryFieldOfPrimaryKey(instance.schema.primaryKey);\n    const replicationHandler: RxReplicationHandler<RxDocType, MasterCheckpointType> = {\n        masterChangeStream$: instance.changeStream().pipe(\n            mergeMap(async (eventBulk) => {\n                const ret: DocumentsWithCheckpoint<RxDocType, MasterCheckpointType> = {\n                    checkpoint: eventBulk.checkpoint,\n                    documents: await Promise.all(\n                        eventBulk.events.map(async (event) => {\n                            let docData = writeDocToDocState(event.documentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice that the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n\n                            return docData;\n                        })\n                    )\n                };\n                return ret;\n            })\n        ),\n        masterChangesSince(\n            checkpoint,\n            batchSize\n        ) {\n            return getChangedDocumentsSince(\n                instance,\n                batchSize,\n                checkpoint\n            ).then(async (result) => {\n                return {\n                    checkpoint: result.documents.length > 0 ? result.checkpoint : checkpoint,\n                    documents: await Promise.all(\n                        result.documents.map(async (plainDocumentData) => {\n                            let docData = writeDocToDocState(plainDocumentData, hasAttachments, keepMeta);\n                            if (hasAttachments) {\n                                docData = await fillWriteDataForAttachmentsChange(\n                                    primaryPath,\n                                    instance,\n                                    clone(docData),\n                                    /**\n                                     * Notice the the master never knows\n                                     * the client state of the document.\n                                     * Therefore we always send all attachments data.\n                                     */\n                                    undefined\n                                );\n                            }\n                            return docData;\n                        })\n                    )\n                };\n            });\n        },\n        async masterWrite(\n            rows\n        ) {\n            const rowById: ById<RxReplicationWriteToMasterRow<RxDocType>> = {};\n            rows.forEach(row => {\n                const docId: string = (row.newDocumentState as any)[primaryPath];\n                rowById[docId] = row;\n            });\n            const ids = Object.keys(rowById);\n\n            const masterDocsStateList = await instance.findDocumentsById(\n                ids,\n                true\n            );\n            const masterDocsState = new Map<string, RxDocumentData<RxDocType>>();\n            masterDocsStateList.forEach(doc => masterDocsState.set((doc as any)[primaryPath], doc));\n            const conflicts: WithDeleted<RxDocType>[] = [];\n            const writeRows: BulkWriteRow<RxDocType>[] = [];\n            await Promise.all(\n                Object.entries(rowById)\n                    .map(async ([id, row]) => {\n                        const masterState = masterDocsState.get(id);\n                        if (!masterState) {\n                            writeRows.push({\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState)\n                            });\n                        } else if (\n                            masterState &&\n                            !row.assumedMasterState\n                        ) {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        } else if (\n                            (await conflictHandler({\n                                realMasterState: writeDocToDocState(masterState, hasAttachments, keepMeta),\n                                newDocumentState: ensureNotFalsy(row.assumedMasterState)\n                            }, 'rxStorageInstanceToReplicationHandler-masterWrite')).isEqual === true\n                        ) {\n                            writeRows.push({\n                                previous: masterState,\n                                document: docStateToWriteDoc(databaseInstanceToken, hasAttachments, keepMeta, row.newDocumentState, masterState)\n                            });\n                        } else {\n                            conflicts.push(writeDocToDocState(masterState, hasAttachments, keepMeta));\n                        }\n                    })\n            );\n\n            if (writeRows.length > 0) {\n                const result = await instance.bulkWrite(\n                    writeRows,\n                    'replication-master-write'\n                );\n\n                result.error.forEach(err => {\n                    if (err.status !== 409) {\n                        throw new Error('non conflict error');\n                    } else {\n                        conflicts.push(\n                            writeDocToDocState(ensureNotFalsy(err.documentInDb), hasAttachments, keepMeta)\n                        );\n                    }\n                });\n            }\n            return conflicts;\n        }\n    };\n\n    return replicationHandler;\n}\n\n\nexport async function cancelRxStorageReplication(\n    replicationState: RxStorageInstanceReplicationState<any>\n) {\n    replicationState.events.canceled.next(true);\n    replicationState.events.active.up.complete();\n    replicationState.events.active.down.complete();\n    replicationState.events.processed.up.complete();\n    replicationState.events.processed.down.complete();\n    replicationState.events.resolvedConflicts.complete();\n    replicationState.events.canceled.complete();\n    await replicationState.checkpointQueue;\n}\n", "/**\n * a buffer-cache which holds the last X changeEvents of the collection\n */\nimport {\n    Subscription\n} from 'rxjs';\nimport { filter } from 'rxjs/operators';\nimport type {\n    RxChangeEvent,\n    RxCollection\n} from './types/index.d.ts';\nimport {\n    appendToArray,\n    requestIdlePromiseNoQueue\n} from './plugins/utils/index.ts';\n\n/**\n * This buffer rembemers previous change events\n * so that queries can use them on .exec()\n * to calculate the new result set via event-reduce instead\n * of running the query against the storage.\n */\nexport class ChangeEventBuffer<RxDocType> {\n    /**\n     * These properties are private to ensure they cannot\n     * be read without first processing the lazy tasks.\n     */\n    private subs: Subscription[] = [];\n    private counter: number = 0;\n    private eventCounterMap: WeakMap<\n        RxChangeEvent<RxDocType>, number\n    > = new WeakMap();\n    /**\n     * array with changeEvents\n     * starts with oldest known event, ends with newest\n    */\n    private buffer: RxChangeEvent<RxDocType>[] = [];\n\n    public limit: number = 100;\n\n\n\n    private tasks = new Set<Function>();\n\n    constructor(\n        public collection: RxCollection\n    ) {\n        this.subs.push(\n            this.collection.database.eventBulks$.pipe(\n                filter(changeEventBulk => changeEventBulk.collectionName === this.collection.name),\n                filter(bulk => {\n                    const first = bulk.events[0];\n                    return !first.isLocal;\n                })\n            ).subscribe(eventBulk => {\n                this.tasks.add(() => this._handleChangeEvents(eventBulk.events));\n                if (this.tasks.size <= 1) {\n                    requestIdlePromiseNoQueue().then(() => {\n                        this.processTasks();\n                    });\n                }\n            })\n        );\n    }\n\n    private processTasks() {\n        if (this.tasks.size === 0) {\n            return;\n        }\n        const tasks = Array.from(this.tasks);\n        tasks.forEach(task => task());\n        this.tasks.clear();\n    }\n\n    private _handleChangeEvents(events: RxChangeEvent<RxDocType>[]) {\n        const counterBefore = this.counter;\n        this.counter = this.counter + events.length;\n        if (events.length > this.limit) {\n            this.buffer = events.slice(events.length * -1);\n        } else {\n            appendToArray(this.buffer, events);\n            this.buffer = this.buffer.slice(this.limit * -1);\n        }\n        const counterBase = counterBefore + 1;\n        const eventCounterMap = this.eventCounterMap;\n        for (let index = 0; index < events.length; index++) {\n            const event = events[index];\n            eventCounterMap.set(event, counterBase + index);\n        }\n    }\n\n    getCounter() {\n        this.processTasks();\n        return this.counter;\n    }\n    getBuffer() {\n        this.processTasks();\n        return this.buffer;\n    }\n\n    /**\n     * gets the array-index for the given pointer\n     * @return arrayIndex which can be used to iterate from there. If null, pointer is out of lower bound\n     */\n    getArrayIndexByPointer(pointer: number): number | null {\n        this.processTasks();\n        const oldestEvent = this.buffer[0];\n        const oldestCounter = this.eventCounterMap.get(\n            oldestEvent\n        ) as number;\n\n        if (pointer < oldestCounter)\n            return null; // out of bounds\n\n        const rest = pointer - oldestCounter;\n        return rest;\n    }\n\n    /**\n     * get all changeEvents which came in later than the pointer-event\n     * @return array with change-events. If null, pointer out of bounds\n     */\n    getFrom(pointer: number): RxChangeEvent<RxDocType>[] | null {\n        this.processTasks();\n        const ret = [];\n        let currentIndex = this.getArrayIndexByPointer(pointer);\n        if (currentIndex === null) // out of bounds\n            return null;\n\n        while (true) {\n            const nextEvent = this.buffer[currentIndex];\n            currentIndex++;\n            if (!nextEvent) {\n                return ret;\n            } else {\n                ret.push(nextEvent);\n            }\n        }\n    }\n\n    runFrom(pointer: number, fn: Function) {\n        this.processTasks();\n        const ret = this.getFrom(pointer);\n        if (ret === null) {\n            throw new Error('out of bounds');\n        } else {\n            ret.forEach(cE => fn(cE));\n        }\n    }\n\n    /**\n     * no matter how many operations are done on one document,\n     * only the last operation has to be checked to calculate the new state\n     * this function reduces the events to the last ChangeEvent of each doc\n     */\n    reduceByLastOfDoc(changeEvents: RxChangeEvent<RxDocType>[]): RxChangeEvent<RxDocType>[] {\n        this.processTasks();\n        return changeEvents.slice(0);\n        // TODO the old implementation was wrong\n        // because it did not correctly reassigned the previousData of the changeevents\n        // this should be added to the event-reduce library and not be done in RxDB\n        const docEventMap: any = {};\n        changeEvents.forEach(changeEvent => {\n            docEventMap[changeEvent.documentId] = changeEvent;\n        });\n        return Object.values(docEventMap);\n    }\n\n    destroy() {\n        this.tasks.clear();\n        this.subs.forEach(sub => sub.unsubscribe());\n    }\n}\n\nexport function createChangeEventBuffer<RxdocType>(\n    collection: RxCollection<RxdocType, any>\n) {\n    return new ChangeEventBuffer<RxdocType>(collection);\n}\n", "import {\n    filter,\n    map,\n    mergeMap\n} from 'rxjs';\n\nimport {\n    ucfirst,\n    flatClone,\n    promiseSeries,\n    pluginMissing,\n    ensureNotFalsy,\n    getFromMapOrThrow,\n    PROMISE_RESOLVE_FALSE,\n    PROMISE_RESOLVE_VOID\n} from './plugins/utils/index.ts';\nimport {\n    fillObjectDataBeforeInsert,\n    createRxCollectionStorageInstance,\n    removeCollectionStorages,\n    ensureRxCollectionIsNotDestroyed\n} from './rx-collection-helper.ts';\nimport {\n    createRxQuery,\n    _getDefaultQuery\n} from './rx-query.ts';\nimport {\n    newRxError,\n    newRxTypeError\n} from './rx-error.ts';\nimport type {\n    RxMigrationState\n} from './plugins/migration-schema/index.ts';\nimport {\n    DocumentCache,\n    mapDocumentsDataToCacheDocs\n} from './doc-cache.ts';\nimport {\n    QueryCache,\n    createQueryCache,\n    defaultCacheReplacementPolicy\n} from './query-cache.ts';\nimport {\n    ChangeEventBuffer,\n    createChangeEventBuffer\n} from './change-event-buffer.ts';\nimport {\n    runAsyncPluginHooks,\n    runPluginHooks\n} from './hooks.ts';\n\nimport {\n    Subscription,\n    Observable\n} from 'rxjs';\n\nimport type {\n    KeyFunctionMap,\n    RxCollection,\n    RxDatabase,\n    RxQuery,\n    RxDocument,\n    RxDumpCollection,\n    RxDumpCollectionAny,\n    MangoQuery,\n    MangoQueryNoLimit,\n    RxCacheReplacementPolicy,\n    RxStorageWriteError,\n    RxDocumentData,\n    RxStorageInstanceCreationParams,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxChangeEventInsert,\n    RxChangeEventUpdate,\n    RxChangeEventDelete,\n    RxStorageInstance,\n    CollectionsOfDatabase,\n    RxChangeEventBulk,\n    RxLocalDocumentData,\n    RxDocumentBase,\n    RxConflictHandler,\n    MaybePromise,\n    CRDTEntry,\n    MangoQuerySelectorAndIndex,\n    MigrationStrategies\n} from './types/index.d.ts';\n\nimport {\n    RxSchema\n} from './rx-schema.ts';\n\nimport {\n    createNewRxDocument,\n    getRxDocumentConstructor\n} from './rx-document-prototype-merge.ts';\nimport {\n    getWrappedStorageInstance,\n    getWrittenDocumentsFromBulkWriteResponse,\n    throwIfIsStorageWriteError,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport { defaultConflictHandler } from './replication-protocol/index.ts';\nimport { IncrementalWriteQueue } from './incremental-write.ts';\nimport { beforeDocumentUpdateWrite } from './rx-document.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxPipeline, RxPipelineOptions } from './plugins/pipeline/index.ts';\n\nconst HOOKS_WHEN = ['pre', 'post'] as const;\ntype HookWhenType = typeof HOOKS_WHEN[number];\nconst HOOKS_KEYS = ['insert', 'save', 'remove', 'create'] as const;\ntype HookKeyType = typeof HOOKS_KEYS[number];\nlet hooksApplied = false;\n\nexport class RxCollectionBase<\n    InstanceCreationOptions,\n    RxDocumentType = { [prop: string]: any; },\n    OrmMethods = {},\n    StaticMethods = { [key: string]: any; },\n    Reactivity = any\n> {\n\n\n    /**\n     * Stores all 'normal' documents\n     */\n    public storageInstance: WrappedRxStorageInstance<RxDocumentType, any, InstanceCreationOptions> = {} as any;\n    public readonly timeouts: Set<ReturnType<typeof setTimeout>> = new Set();\n    public incrementalWriteQueue: IncrementalWriteQueue<RxDocumentType> = {} as any;\n\n\n    /**\n     * Before reads, all these methods are awaited. Used to \"block\" reads\n     * depending on other processes, like when the RxPipeline is running.\n     */\n    public readonly awaitBeforeReads = new Set<() => MaybePromise<any>>();\n\n    constructor(\n        public database: RxDatabase<CollectionsOfDatabase, any, InstanceCreationOptions, Reactivity>,\n        public name: string,\n        public schema: RxSchema<RxDocumentType>,\n        public internalStorageInstance: RxStorageInstance<RxDocumentType, any, InstanceCreationOptions>,\n        public instanceCreationOptions: InstanceCreationOptions = {} as any,\n        public migrationStrategies: MigrationStrategies = {},\n        public methods: KeyFunctionMap = {},\n        public attachments: KeyFunctionMap = {},\n        public options: any = {},\n        public cacheReplacementPolicy: RxCacheReplacementPolicy = defaultCacheReplacementPolicy,\n        public statics: KeyFunctionMap = {},\n        public conflictHandler: RxConflictHandler<RxDocumentType> = defaultConflictHandler\n    ) {\n        _applyHookFunctions(this.asRxCollection);\n    }\n\n    get insert$(): Observable<RxChangeEventInsert<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'INSERT')\n        ) as any;\n    }\n    get update$(): Observable<RxChangeEventUpdate<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'UPDATE')\n        ) as any;\n    }\n    get remove$(): Observable<RxChangeEventDelete<RxDocumentType>> {\n        return this.$.pipe(\n            filter(cE => cE.operation === 'DELETE')\n        ) as any;\n    }\n\n    public _incrementalUpsertQueues: Map<string, Promise<any>> = new Map();\n    // defaults\n    public synced: boolean = false;\n    public hooks: {\n        [key in HookKeyType]: {\n            [when in HookWhenType]: {\n                series: Function[];\n                parallel: Function[];\n            };\n        }\n    } = {} as any;\n    public _subs: Subscription[] = [];\n\n    public _docCache: DocumentCache<RxDocumentType, OrmMethods> = {} as any;\n\n    public _queryCache: QueryCache = createQueryCache();\n    public $: Observable<RxChangeEvent<RxDocumentType>> = {} as any;\n    public checkpoint$: Observable<any> = {} as any;\n    public _changeEventBuffer: ChangeEventBuffer<RxDocumentType> = {} as ChangeEventBuffer<RxDocumentType>;\n\n\n\n    /**\n     * When the collection is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n    */\n    public onDestroy: (() => MaybePromise<any>)[] = [];\n    public destroyed = false;\n\n    public onRemove: (() => MaybePromise<any>)[] = [];\n\n    public async prepare(): Promise<void> {\n        this.storageInstance = getWrappedStorageInstance(\n            this.database,\n            this.internalStorageInstance,\n            this.schema.jsonSchema\n        );\n        this.incrementalWriteQueue = new IncrementalWriteQueue<RxDocumentType>(\n            this.storageInstance,\n            this.schema.primaryPath,\n            (newData, oldData) => beforeDocumentUpdateWrite(this as any, newData, oldData),\n            result => this._runHooks('post', 'save', result)\n        );\n\n        const collectionEventBulks$ = this.database.eventBulks$.pipe(\n            filter(changeEventBulk => changeEventBulk.collectionName === this.name),\n        );\n        this.$ = collectionEventBulks$.pipe(\n            mergeMap(changeEventBulk => changeEventBulk.events),\n        );\n        this.checkpoint$ = collectionEventBulks$.pipe(\n            map(changeEventBulk => changeEventBulk.checkpoint),\n        );\n\n        this._changeEventBuffer = createChangeEventBuffer<RxDocumentType>(this.asRxCollection);\n        let documentConstructor: any;\n        this._docCache = new DocumentCache(\n            this.schema.primaryPath,\n            this.database.eventBulks$.pipe(\n                filter(changeEventBulk => changeEventBulk.collectionName === this.name && !changeEventBulk.events[0].isLocal),\n                map(b => b.events)\n            ),\n            docData => {\n                if (!documentConstructor) {\n                    documentConstructor = getRxDocumentConstructor(this.asRxCollection);\n                }\n                return createNewRxDocument(this.asRxCollection, documentConstructor, docData);\n            }\n        );\n\n\n        const listenToRemoveSub = this.database.internalStore.changeStream().pipe(\n            filter(bulk => {\n                const key = this.name + '-' + this.schema.version;\n                const found = bulk.events.find(event => {\n                    return (\n                        event.documentData.context === 'collection' &&\n                        event.documentData.key === key &&\n                        event.operation === 'DELETE'\n                    );\n                });\n                return !!found;\n            })\n        ).subscribe(async () => {\n            await this.destroy();\n            await Promise.all(this.onRemove.map(fn => fn()));\n        });\n        this._subs.push(listenToRemoveSub);\n\n\n        /**\n         * TODO Instead of resolving the EventBulk array here and spit it into\n         * single events, we should fully work with event bulks internally\n         * to save performance.\n         */\n        const databaseStorageToken = await this.database.storageToken;\n        const subDocs = this.storageInstance.changeStream().subscribe(eventBulk => {\n            const events = new Array(eventBulk.events.length);\n            const rawEvents = eventBulk.events;\n            const collectionName = this.name;\n            const deepFreezeWhenDevMode = overwritable.deepFreezeWhenDevMode;\n            for (let index = 0; index < rawEvents.length; index++) {\n                const event = rawEvents[index];\n                events[index] = {\n                    documentId: event.documentId,\n                    collectionName,\n                    isLocal: false,\n                    operation: event.operation,\n                    documentData: deepFreezeWhenDevMode(event.documentData) as any,\n                    previousDocumentData: deepFreezeWhenDevMode(event.previousDocumentData) as any\n                };\n            }\n            const changeEventBulk: RxChangeEventBulk<RxDocumentType | RxLocalDocumentData> = {\n                id: eventBulk.id,\n                internal: false,\n                collectionName: this.name,\n                storageToken: databaseStorageToken,\n                events,\n                databaseToken: this.database.token,\n                checkpoint: eventBulk.checkpoint,\n                context: eventBulk.context,\n                endTime: eventBulk.endTime,\n                startTime: eventBulk.startTime\n            };\n            this.database.$emit(changeEventBulk);\n        });\n        this._subs.push(subDocs);\n\n        /**\n         * Resolve the conflict tasks\n         * of the RxStorageInstance\n         */\n        this._subs.push(\n            this.storageInstance\n                .conflictResultionTasks()\n                .subscribe(task => {\n                    this\n                        .conflictHandler(task.input, task.context)\n                        .then(output => {\n                            this.storageInstance.resolveConflictResultionTask({\n                                id: task.id,\n                                output\n                            });\n                        });\n                })\n        );\n\n        return PROMISE_RESOLVE_VOID;\n    }\n\n\n    /**\n     * Manually call the cleanup function of the storage.\n     * @link https://rxdb.info/cleanup.html\n     */\n    cleanup(_minimumDeletedTime?: number): Promise<boolean> {\n        ensureRxCollectionIsNotDestroyed(this);\n        throw pluginMissing('cleanup');\n    }\n\n    // overwritten by migration-plugin\n    migrationNeeded(): Promise<boolean> {\n        throw pluginMissing('migration-schema');\n    }\n    getMigrationState(): RxMigrationState {\n        throw pluginMissing('migration-schema');\n    }\n    startMigration(batchSize: number = 10): Promise<void> {\n        ensureRxCollectionIsNotDestroyed(this);\n        return this.getMigrationState().startMigration(batchSize);\n    }\n    migratePromise(batchSize: number = 10): Promise<any> {\n        return this.getMigrationState().migratePromise(batchSize);\n    }\n\n    async insert(\n        json: RxDocumentType | RxDocument\n    ): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotDestroyed(this);\n        const writeResult = await this.bulkInsert([json as any]);\n\n        const isError = writeResult.error[0];\n        throwIfIsStorageWriteError(this as any, (json as any)[this.schema.primaryPath] as any, json, isError);\n        const insertResult = ensureNotFalsy(writeResult.success[0]);\n        return insertResult;\n    }\n\n    async bulkInsert(\n        docsData: RxDocumentType[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotDestroyed(this);\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n        */\n        if (docsData.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const primaryPath = this.schema.primaryPath;\n\n        const ids = new Set<string>();\n\n        /**\n         * This code is a bit redundant for better performance.\n         * Instead of iterating multiple times,\n         * we directly transform the input to a write-row array.\n         */\n        let insertRows: BulkWriteRow<RxDocumentType>[];\n        if (this.hasHooks('pre', 'insert')) {\n            insertRows = await Promise.all(\n                docsData.map(docData => {\n                    const useDocData = fillObjectDataBeforeInsert(this.schema, docData);\n                    return this._runHooks('pre', 'insert', useDocData)\n                        .then(() => {\n                            ids.add((useDocData as any)[primaryPath]);\n                            return { document: useDocData };\n                        });\n                })\n            );\n        } else {\n            insertRows = new Array(docsData.length);\n            const schema = this.schema;\n            for (let index = 0; index < docsData.length; index++) {\n                const docData = docsData[index];\n                const useDocData = fillObjectDataBeforeInsert(schema, docData);\n                ids.add((useDocData as any)[primaryPath]);\n                insertRows[index] = { document: useDocData };\n            }\n        }\n\n\n        if (ids.size !== docsData.length) {\n            throw newRxError('COL22', {\n                collection: this.name,\n                args: {\n                    documents: docsData\n                }\n            });\n        }\n\n        const results = await this.storageInstance.bulkWrite(\n            insertRows,\n            'rx-collection-bulk-insert'\n        );\n\n\n        /**\n         * Often the user does not need to access the RxDocuments of the bulkInsert() call.\n         * So we transform the data to RxDocuments only if needed to use less CPU performance.\n         */\n        let rxDocuments: RxDocument<RxDocumentType, OrmMethods>[];\n        const collection = this;\n        const ret = {\n            get success() {\n                if (!rxDocuments) {\n                    const success = getWrittenDocumentsFromBulkWriteResponse(\n                        collection.schema.primaryPath,\n                        insertRows,\n                        results\n                    );\n                    rxDocuments = mapDocumentsDataToCacheDocs<RxDocumentType, OrmMethods>(collection._docCache, success);\n                }\n                return rxDocuments;\n            },\n            error: results.error\n        };\n\n        if (this.hasHooks('post', 'insert')) {\n            const docsMap: Map<string, RxDocumentType> = new Map();\n            insertRows.forEach(row => {\n                const doc = row.document;\n                docsMap.set((doc as any)[primaryPath] as any, doc);\n            });\n            await Promise.all(\n                ret.success.map(doc => {\n                    return this._runHooks(\n                        'post',\n                        'insert',\n                        docsMap.get(doc.primary),\n                        doc\n                    );\n                })\n            );\n        }\n\n        return ret;\n    }\n\n    async bulkRemove(\n        ids: string[]\n    ): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotDestroyed(this);\n        const primaryPath = this.schema.primaryPath;\n        /**\n         * Optimization shortcut,\n         * do nothing when called with an empty array\n         */\n        if (ids.length === 0) {\n            return {\n                success: [],\n                error: []\n            };\n        }\n\n        const rxDocumentMap = await this.findByIds(ids).exec();\n        const docsData: RxDocumentData<RxDocumentType>[] = [];\n        const docsMap: Map<string, RxDocumentData<RxDocumentType>> = new Map();\n        Array.from(rxDocumentMap.values()).forEach(rxDocument => {\n            const data: RxDocumentData<RxDocumentType> = rxDocument.toMutableJSON(true) as any;\n            docsData.push(data);\n            docsMap.set(rxDocument.primary, data);\n        });\n\n        await Promise.all(\n            docsData.map(doc => {\n                const primary = (doc as any)[this.schema.primaryPath];\n                return this._runHooks('pre', 'remove', doc, rxDocumentMap.get(primary));\n            })\n        );\n        const removeDocs: BulkWriteRow<RxDocumentType>[] = docsData.map(doc => {\n            const writeDoc = flatClone(doc);\n            writeDoc._deleted = true;\n            return {\n                previous: doc,\n                document: writeDoc\n            };\n        });\n        const results = await this.storageInstance.bulkWrite(\n            removeDocs,\n            'rx-collection-bulk-remove'\n        );\n\n\n        const success = getWrittenDocumentsFromBulkWriteResponse(\n            this.schema.primaryPath,\n            removeDocs,\n            results\n        );\n        const successIds: string[] = success.map(d => d[primaryPath] as string);\n\n        // run hooks\n        await Promise.all(\n            successIds.map(id => {\n                return this._runHooks(\n                    'post',\n                    'remove',\n                    docsMap.get(id),\n                    rxDocumentMap.get(id)\n                );\n            })\n        );\n\n        const rxDocuments = successIds.map(id => getFromMapOrThrow(rxDocumentMap, id));\n\n        return {\n            success: rxDocuments,\n            error: results.error\n        };\n    }\n\n    /**\n     * same as bulkInsert but overwrites existing document with same primary\n     */\n    async bulkUpsert(docsData: Partial<RxDocumentType>[]): Promise<{\n        success: RxDocument<RxDocumentType, OrmMethods>[];\n        error: RxStorageWriteError<RxDocumentType>[];\n    }> {\n        ensureRxCollectionIsNotDestroyed(this);\n        const insertData: RxDocumentType[] = [];\n        const useJsonByDocId: Map<string, RxDocumentType> = new Map();\n        docsData.forEach(docData => {\n            const useJson = fillObjectDataBeforeInsert(this.schema, docData);\n            const primary: string = useJson[this.schema.primaryPath] as any;\n            if (!primary) {\n                throw newRxError('COL3', {\n                    primaryPath: this.schema.primaryPath as string,\n                    data: useJson,\n                    schema: this.schema.jsonSchema\n                });\n            }\n            useJsonByDocId.set(primary, useJson);\n            insertData.push(useJson);\n        });\n\n        const insertResult = await this.bulkInsert(insertData);\n        const success = insertResult.success.slice(0);\n        const error: RxStorageWriteError<RxDocumentType>[] = [];\n\n        // update the ones that existed already\n        await Promise.all(\n            insertResult.error.map(async (err) => {\n                if (err.status !== 409) {\n                    error.push(err);\n                } else {\n                    const id = err.documentId;\n                    const writeData = getFromMapOrThrow(useJsonByDocId, id);\n                    const docDataInDb = ensureNotFalsy(err.documentInDb);\n                    const doc = this._docCache.getCachedRxDocuments([docDataInDb])[0];\n                    const newDoc = await doc.incrementalModify(() => writeData);\n                    success.push(newDoc);\n                }\n            })\n        );\n        return {\n            error,\n            success\n        };\n    }\n\n    /**\n     * same as insert but overwrites existing document with same primary\n     */\n    async upsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotDestroyed(this);\n        const bulkResult = await this.bulkUpsert([json]);\n        throwIfIsStorageWriteError<RxDocumentType>(\n            this.asRxCollection,\n            (json as any)[this.schema.primaryPath],\n            json as any,\n            bulkResult.error[0]\n        );\n        return bulkResult.success[0];\n    }\n\n    /**\n     * upserts to a RxDocument, uses incrementalModify if document already exists\n     */\n    incrementalUpsert(json: Partial<RxDocumentType>): Promise<RxDocument<RxDocumentType, OrmMethods>> {\n        ensureRxCollectionIsNotDestroyed(this);\n        const useJson = fillObjectDataBeforeInsert(this.schema, json);\n        const primary: string = useJson[this.schema.primaryPath] as any;\n        if (!primary) {\n            throw newRxError('COL4', {\n                data: json\n            });\n        }\n\n        // ensure that it won't try 2 parallel runs\n        let queue = this._incrementalUpsertQueues.get(primary);\n        if (!queue) {\n            queue = PROMISE_RESOLVE_VOID;\n        }\n        queue = queue\n            .then(() => _incrementalUpsertEnsureRxDocumentExists(this as any, primary as any, useJson))\n            .then((wasInserted) => {\n                if (!wasInserted.inserted) {\n                    return _incrementalUpsertUpdate(wasInserted.doc, useJson);\n                } else {\n                    return wasInserted.doc;\n                }\n            });\n        this._incrementalUpsertQueues.set(primary, queue);\n        return queue;\n    }\n\n    find(queryObj?: MangoQuery<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods>[],\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotDestroyed(this);\n        if (typeof queryObj === 'string') {\n            throw newRxError('COL5', {\n                queryObj\n            });\n        }\n\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n\n        const query = createRxQuery('find', queryObj, this as any);\n        return query as any;\n    }\n\n    findOne(\n        queryObj?: MangoQueryNoLimit<RxDocumentType> | string\n    ): RxQuery<\n        RxDocumentType,\n        RxDocument<RxDocumentType, OrmMethods> | null,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotDestroyed(this);\n\n        // TODO move this check to dev-mode plugin\n        if (\n            typeof queryObj === 'number' ||\n            Array.isArray(queryObj)\n        ) {\n            throw newRxTypeError('COL6', {\n                queryObj\n            });\n        }\n\n        let query;\n\n        if (typeof queryObj === 'string') {\n            query = createRxQuery('findOne', {\n                selector: {\n                    [this.schema.primaryPath]: queryObj\n                },\n                limit: 1\n            }, this as any);\n        } else {\n            if (!queryObj) {\n                queryObj = _getDefaultQuery();\n            }\n\n\n            // cannot have limit on findOne queries because it will be overwritten\n            if ((queryObj as MangoQuery).limit) {\n                throw newRxError('QU6');\n            }\n\n            queryObj = flatClone(queryObj);\n            (queryObj as any).limit = 1;\n            query = createRxQuery<RxDocumentType>('findOne', queryObj, this as any);\n        }\n\n\n        return query as any;\n    }\n\n    count(queryObj?: MangoQuerySelectorAndIndex<RxDocumentType>): RxQuery<\n        RxDocumentType,\n        number,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotDestroyed(this);\n        if (!queryObj) {\n            queryObj = _getDefaultQuery();\n        }\n        const query = createRxQuery('count', queryObj, this as any);\n        return query as any;\n    }\n\n    /**\n     * find a list documents by their primary key\n     * has way better performance then running multiple findOne() or a find() with a complex $or-selected\n     */\n    findByIds(\n        ids: string[]\n    ): RxQuery<\n        RxDocumentType,\n        Map<string, RxDocument<RxDocumentType, OrmMethods>>,\n        OrmMethods,\n        Reactivity\n    > {\n        ensureRxCollectionIsNotDestroyed(this);\n        const mangoQuery: MangoQuery<RxDocumentType> = {\n            selector: {\n                [this.schema.primaryPath]: {\n                    $in: ids.slice(0)\n                }\n            } as any\n        };\n        const query = createRxQuery('findByIds', mangoQuery, this as any);\n        return query as any;\n    }\n\n    /**\n     * Export collection to a JSON friendly format.\n     */\n    exportJSON(): Promise<RxDumpCollection<RxDocumentType>>;\n    exportJSON(): Promise<RxDumpCollectionAny<RxDocumentType>>;\n    exportJSON(): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<collection>.exportJSON()` method.\n     */\n    importJSON(_exportedJSON: RxDumpCollectionAny<RxDocumentType>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    insertCRDT(_updateObj: CRDTEntry<any> | CRDTEntry<any>[]): RxDocument<RxDocumentType, OrmMethods> {\n        throw pluginMissing('crdt');\n    }\n\n\n    addPipeline(_options: RxPipelineOptions<RxDocumentType>): Promise<RxPipeline<RxDocumentType>> {\n        throw pluginMissing('pipeline');\n    }\n\n    /**\n     * HOOKS\n     */\n    addHook(when: HookWhenType, key: HookKeyType, fun: any, parallel = false) {\n        if (typeof fun !== 'function') {\n            throw newRxTypeError('COL7', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_WHEN.includes(when)) {\n            throw newRxTypeError('COL8', {\n                key,\n                when\n            });\n        }\n\n        if (!HOOKS_KEYS.includes(key)) {\n            throw newRxError('COL9', {\n                key\n            });\n        }\n\n        if (when === 'post' && key === 'create' && parallel === true) {\n            throw newRxError('COL10', {\n                when,\n                key,\n                parallel\n            });\n        }\n\n        // bind this-scope to hook-function\n        const boundFun = fun.bind(this);\n\n        const runName = parallel ? 'parallel' : 'series';\n\n        this.hooks[key] = this.hooks[key] || {};\n        this.hooks[key][when] = this.hooks[key][when] || {\n            series: [],\n            parallel: []\n        };\n        this.hooks[key][when][runName].push(boundFun);\n    }\n\n    getHooks(when: HookWhenType, key: HookKeyType) {\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return {\n                series: [],\n                parallel: []\n            };\n        }\n        return this.hooks[key][when];\n    }\n\n    hasHooks(when: HookWhenType, key: HookKeyType) {\n        /**\n         * Performance shortcut\n         * so that we not have to build the empty object.\n         */\n        if (\n            !this.hooks[key] ||\n            !this.hooks[key][when]\n        ) {\n            return false;\n        }\n\n        const hooks = this.getHooks(when, key);\n        if (!hooks) {\n            return false;\n        }\n        return hooks.series.length > 0 || hooks.parallel.length > 0;\n    }\n\n    _runHooks(when: HookWhenType, key: HookKeyType, data: any, instance?: any): Promise<any> {\n        const hooks = this.getHooks(when, key);\n\n        if (!hooks) {\n            return PROMISE_RESOLVE_VOID;\n        }\n\n        // run parallel: false\n        const tasks = hooks.series.map((hook: any) => () => hook(data, instance));\n        return promiseSeries(tasks)\n            // run parallel: true\n            .then(() => Promise.all(\n                hooks.parallel\n                    .map((hook: any) => hook(data, instance))\n            ));\n    }\n\n    /**\n     * does the same as ._runHooks() but with non-async-functions\n     */\n    _runHooksSync(when: HookWhenType, key: HookKeyType, data: any, instance: any) {\n        if (!this.hasHooks(when, key)) {\n            return;\n        }\n        const hooks = this.getHooks(when, key);\n        if (!hooks) return;\n        hooks.series.forEach((hook: any) => hook(data, instance));\n    }\n\n    /**\n     * Returns a promise that resolves after the given time.\n     * Ensures that is properly cleans up when the collection is destroyed\n     * so that no running timeouts prevent the exit of the JavaScript process.\n     */\n    promiseWait(time: number): Promise<void> {\n        const ret = new Promise<void>(res => {\n            const timeout = setTimeout(() => {\n                this.timeouts.delete(timeout);\n                res();\n            }, time);\n            this.timeouts.add(timeout);\n        });\n        return ret;\n    }\n\n    async destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n\n        await Promise.all(this.onDestroy.map(fn => fn()));\n\n        /**\n         * Settings destroyed = true\n         * must be the first thing to do,\n         * so for example the replication can directly stop\n         * instead of sending requests to a closed storage.\n         */\n        this.destroyed = true;\n\n\n        Array.from(this.timeouts).forEach(timeout => clearTimeout(timeout));\n        if (this._changeEventBuffer) {\n            this._changeEventBuffer.destroy();\n        }\n        /**\n         * First wait until the whole database is idle.\n         * This ensures that the storage does not get closed\n         * while some operation is running.\n         * It is important that we do not intercept a running call\n         * because it might lead to undefined behavior like when a doc is written\n         * but the change is not added to the changes collection.\n         */\n        return this.database.requestIdlePromise()\n            .then(() => this.storageInstance.close())\n            .then(() => {\n                /**\n                 * Unsubscribing must be done AFTER the storageInstance.close()\n                 * Because the conflict handling is part of the subscriptions and\n                 * otherwise there might be open conflicts to be resolved which\n                 * will then stuck and never resolve.\n                 */\n                this._subs.forEach(sub => sub.unsubscribe());\n\n                delete this.database.collections[this.name];\n                return runAsyncPluginHooks('postDestroyRxCollection', this).then(() => true);\n            });\n    }\n\n    /**\n     * remove all data of the collection\n     */\n    async remove(): Promise<any> {\n        await this.destroy();\n        await Promise.all(this.onRemove.map(fn => fn()));\n        /**\n         * TODO here we should pass the already existing\n         * storage instances instead of creating new ones.\n         */\n        await removeCollectionStorages(\n            this.database.storage,\n            this.database.internalStore,\n            this.database.token,\n            this.database.name,\n            this.name,\n            this.database.password,\n            this.database.hashFunction\n        );\n    }\n\n    get asRxCollection(): RxCollection<RxDocumentType, OrmMethods, StaticMethods, any, Reactivity> {\n        return this as any;\n    }\n}\n\n/**\n * adds the hook-functions to the collections prototype\n * this runs only once\n */\nfunction _applyHookFunctions(\n    collection: RxCollection<any, any>\n) {\n    if (hooksApplied) return; // already run\n    hooksApplied = true;\n    const colProto = Object.getPrototypeOf(collection);\n    HOOKS_KEYS.forEach(key => {\n        HOOKS_WHEN.map(when => {\n            const fnName = when + ucfirst(key);\n            colProto[fnName] = function (fun: string, parallel: boolean) {\n                return this.addHook(when, key, fun, parallel);\n            };\n        });\n    });\n}\n\nfunction _incrementalUpsertUpdate<RxDocType>(\n    doc: RxDocumentBase<RxDocType>,\n    json: RxDocumentData<RxDocType>\n): Promise<RxDocumentBase<RxDocType>> {\n    return doc.incrementalModify((_innerDoc) => {\n        return json;\n    });\n}\n\n/**\n * ensures that the given document exists\n * @return promise that resolves with new doc and flag if inserted\n */\nfunction _incrementalUpsertEnsureRxDocumentExists<RxDocType>(\n    rxCollection: RxCollection<RxDocType>,\n    primary: string,\n    json: any\n): Promise<\n    {\n        doc: RxDocument<RxDocType>;\n        inserted: boolean;\n    }\n> {\n    /**\n     * Optimisation shortcut,\n     * first try to find the document in the doc-cache\n     */\n    const docDataFromCache = rxCollection._docCache.getLatestDocumentDataIfExists(primary);\n    if (docDataFromCache) {\n        return Promise.resolve({\n            doc: rxCollection._docCache.getCachedRxDocuments([docDataFromCache])[0],\n            inserted: false\n        });\n    }\n    return rxCollection.findOne(primary).exec()\n        .then(doc => {\n            if (!doc) {\n                return rxCollection.insert(json).then(newDoc => ({\n                    doc: newDoc,\n                    inserted: true\n                }));\n            } else {\n                return {\n                    doc,\n                    inserted: false\n                };\n            }\n        });\n}\n\n/**\n * creates and prepares a new collection\n */\nexport function createRxCollection(\n    {\n        database,\n        name,\n        schema,\n        instanceCreationOptions = {},\n        migrationStrategies = {},\n        autoMigrate = true,\n        statics = {},\n        methods = {},\n        attachments = {},\n        options = {},\n        localDocuments = false,\n        cacheReplacementPolicy = defaultCacheReplacementPolicy,\n        conflictHandler = defaultConflictHandler\n    }: any\n): Promise<RxCollection> {\n    const storageInstanceCreationParams: RxStorageInstanceCreationParams<any, any> = {\n        databaseInstanceToken: database.token,\n        databaseName: database.name,\n        collectionName: name,\n        schema: schema.jsonSchema,\n        options: instanceCreationOptions,\n        multiInstance: database.multiInstance,\n        password: database.password,\n        devMode: overwritable.isDevMode()\n    };\n\n    runPluginHooks(\n        'preCreateRxStorageInstance',\n        storageInstanceCreationParams\n    );\n\n    return createRxCollectionStorageInstance(\n        database,\n        storageInstanceCreationParams\n    ).then(storageInstance => {\n        const collection = new RxCollectionBase(\n            database,\n            name,\n            schema,\n            storageInstance,\n            instanceCreationOptions,\n            migrationStrategies,\n            methods,\n            attachments,\n            options,\n            cacheReplacementPolicy,\n            statics,\n            conflictHandler\n        );\n\n        return collection\n            .prepare()\n            .then(() => {\n                // ORM add statics\n                Object\n                    .entries(statics)\n                    .forEach(([funName, fun]) => {\n                        Object.defineProperty(collection, funName, {\n                            get: () => (fun as any).bind(collection)\n                        });\n                    });\n\n                let ret = PROMISE_RESOLVE_VOID;\n                if (autoMigrate && collection.schema.version !== 0) {\n                    ret = collection.migratePromise();\n                }\n                return ret;\n            })\n            .then(() => {\n                runPluginHooks('createRxCollection', {\n                    collection,\n                    creator: {\n                        name,\n                        schema,\n                        storageInstance,\n                        instanceCreationOptions,\n                        migrationStrategies,\n                        methods,\n                        attachments,\n                        options,\n                        cacheReplacementPolicy,\n                        localDocuments,\n                        statics\n                    }\n                });\n                return collection as any;\n            })\n            /**\n             * If the collection creation fails,\n             * we yet have to close the storage instances.\n             */\n            .catch(err => {\n                return storageInstance.close()\n                    .then(() => Promise.reject(err as Error));\n            });\n    });\n}\n\nexport function isRxCollection(obj: any): boolean {\n    return obj instanceof RxCollectionBase;\n}\n", "import {\n    overwriteGetterForCaching,\n    isMaybeReadonlyArray,\n    deepEqual\n} from './plugins/utils/index.ts';\nimport {\n    newRxError,\n} from './rx-error.ts';\nimport {\n    runPluginHooks\n} from './hooks.ts';\n\nimport type {\n    DeepMutable,\n    DeepReadonly,\n    HashFunction,\n    MaybeReadonly,\n    RxDocument,\n    RxDocumentData,\n    RxJsonSchema,\n    StringKeys\n} from './types/index.d.ts';\nimport {\n    fillWithDefaultSettings,\n    getComposedPrimaryKeyOfDocumentData,\n    getFinalFields,\n    getPrimaryFieldOfPrimaryKey,\n    getSchemaByObjectPath,\n    normalizeRxJsonSchema\n} from './rx-schema-helper.ts';\nimport { overwritable } from './overwritable.ts';\n\nexport class RxSchema<RxDocType = any> {\n    public indexes: MaybeReadonly<string[]>[];\n    public readonly primaryPath: StringKeys<RxDocumentData<RxDocType>>;\n    public finalFields: string[];\n\n    constructor(\n        public readonly jsonSchema: RxJsonSchema<RxDocumentData<RxDocType>>,\n        public readonly hashFunction: HashFunction\n    ) {\n        this.indexes = getIndexes(this.jsonSchema);\n\n        // primary is always required\n        this.primaryPath = getPrimaryFieldOfPrimaryKey(this.jsonSchema.primaryKey);\n\n        this.finalFields = getFinalFields(this.jsonSchema);\n    }\n\n    public get version(): number {\n        return this.jsonSchema.version;\n    }\n\n    public get defaultValues(): { [P in keyof RxDocType]: RxDocType[P] } {\n        const values = {} as { [P in keyof RxDocType]: RxDocType[P] };\n        Object\n            .entries(this.jsonSchema.properties)\n            .filter(([, v]) => Object.prototype.hasOwnProperty.call(v, 'default'))\n            .forEach(([k, v]) => (values as any)[k] = (v as any).default);\n        return overwriteGetterForCaching(\n            this,\n            'defaultValues',\n            values\n        );\n    }\n\n    /**\n     * @overrides itself on the first call\n     *\n     * TODO this should be a pure function that\n     * caches the hash in a WeakMap.\n     */\n    public get hash(): Promise<string> {\n        return overwriteGetterForCaching(\n            this,\n            'hash',\n            this.hashFunction(JSON.stringify(this.jsonSchema))\n        );\n    }\n\n    /**\n     * checks if a given change on a document is allowed\n     * Ensures that:\n     * - final fields are not modified\n     * @throws {Error} if not valid\n     */\n    validateChange(dataBefore: any, dataAfter: any): void {\n        this.finalFields.forEach(fieldName => {\n            if (!deepEqual(dataBefore[fieldName], dataAfter[fieldName])) {\n                throw newRxError('DOC9', {\n                    dataBefore,\n                    dataAfter,\n                    fieldName,\n                    schema: this.jsonSchema\n                });\n            }\n        });\n    }\n\n    /**\n     * creates the schema-based document-prototype,\n     * see RxCollection.getDocumentPrototype()\n     */\n    public getDocumentPrototype(): any {\n        const proto: any = {};\n\n        /**\n         * On the top level, we know all keys\n         * and therefore do not have to create a new Proxy object\n         * for each document. Instead we define the getter in the prototype once.\n         */\n        const pathProperties = getSchemaByObjectPath(\n            this.jsonSchema,\n            ''\n        );\n        Object.keys(pathProperties)\n            .forEach(key => {\n                const fullPath = key;\n\n                // getter - value\n                proto.__defineGetter__(\n                    key,\n                    function (this: RxDocument) {\n                        if (!this.get || typeof this.get !== 'function') {\n                            /**\n                             * When an object gets added to the state of a vuejs-component,\n                             * it happens that this getter is called with another scope.\n                             * To prevent errors, we have to return undefined in this case\n                             */\n                            return undefined;\n                        }\n                        const ret = this.get(fullPath);\n                        return ret;\n                    }\n                );\n                // getter - observable$\n                Object.defineProperty(proto, key + '$', {\n                    get: function () {\n                        return this.get$(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n                // getter - reactivity$$\n                Object.defineProperty(proto, key + '$$', {\n                    get: function () {\n                        return this.get$$(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n                // getter - populate_\n                Object.defineProperty(proto, key + '_', {\n                    get: function () {\n                        return this.populate(fullPath);\n                    },\n                    enumerable: false,\n                    configurable: false\n                });\n            });\n\n        overwriteGetterForCaching(\n            this,\n            'getDocumentPrototype',\n            () => proto\n        );\n        return proto;\n    }\n\n\n    getPrimaryOfDocumentData(\n        documentData: Partial<RxDocType>\n    ): string {\n        return getComposedPrimaryKeyOfDocumentData(\n            this.jsonSchema,\n            documentData\n        );\n    }\n}\n\nexport function getIndexes<RxDocType = any>(\n    jsonSchema: RxJsonSchema<RxDocType>\n): MaybeReadonly<string[]>[] {\n    return (jsonSchema.indexes || []).map(index => isMaybeReadonlyArray(index) ? index : [index]);\n}\n\n/**\n * array with previous version-numbers\n */\nexport function getPreviousVersions(schema: RxJsonSchema<any>): number[] {\n    const version = schema.version ? schema.version : 0;\n    let c = 0;\n    return new Array(version)\n        .fill(0)\n        .map(() => c++);\n}\n\nexport function createRxSchema<T>(\n    jsonSchema: RxJsonSchema<T>,\n    hashFunction: HashFunction,\n    runPreCreateHooks = true\n): RxSchema<T> {\n    if (runPreCreateHooks) {\n        runPluginHooks('preCreateRxSchema', jsonSchema);\n    }\n\n    let useJsonSchema = fillWithDefaultSettings(jsonSchema);\n    useJsonSchema = normalizeRxJsonSchema(useJsonSchema);\n    overwritable.deepFreezeWhenDevMode(useJsonSchema);\n\n    const schema = new RxSchema(useJsonSchema, hashFunction);\n    runPluginHooks('createRxSchema', schema);\n    return schema;\n}\n\nexport function isRxSchema(obj: any): boolean {\n    return obj instanceof RxSchema;\n}\n\n/**\n * Used as helper function the generate the document type out of the schema via typescript.\n * @link https://github.com/pubkey/rxdb/discussions/3467\n */\nexport function toTypedRxJsonSchema<T extends DeepReadonly<RxJsonSchema<any>>>(schema: T): DeepMutable<T> {\n    return schema as any;\n}\n", "/**\n * Creates a new Idle-Queue\n * @constructor\n * @param {number} [parallels=1] amount of parrallel runs of the limited-ressource\n */\nexport var IdleQueue = function IdleQueue() {\n  var parallels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n  this._parallels = parallels || 1;\n  /**\n   * _queueCounter\n   * each lock() increased this number\n   * each unlock() decreases this number\n   * If _qC==0, the state is in idle\n   * @type {Number}\n   */\n\n  this._qC = 0;\n  /**\n   * _idleCalls\n   * contains all promises that where added via requestIdlePromise()\n   * and not have been resolved\n   * @type {Set<Promise>} _iC with oldest promise first\n   */\n\n  this._iC = new Set();\n  /**\n   * _lastHandleNumber\n   * @type {Number}\n   */\n\n  this._lHN = 0;\n  /**\n   * _handlePromiseMap\n   * Contains the handleNumber on the left\n   * And the assigned promise on the right.\n   * This is stored so you can use cancelIdleCallback(handleNumber)\n   * to stop executing the callback.\n   * @type {Map<Number><Promise>}\n   */\n\n  this._hPM = new Map();\n  this._pHM = new Map(); // _promiseHandleMap\n};\nIdleQueue.prototype = {\n  isIdle: function isIdle() {\n    return this._qC < this._parallels;\n  },\n\n  /**\n   * creates a lock in the queue\n   * and returns an unlock-function to remove the lock from the queue\n   * @return {function} unlock function than must be called afterwards\n   */\n  lock: function lock() {\n    this._qC++;\n  },\n  unlock: function unlock() {\n    this._qC--;\n\n    _tryIdleCall(this);\n  },\n\n  /**\n   * wraps a function with lock/unlock and runs it\n   * @param  {function}  fun\n   * @return {Promise<any>}\n   */\n  wrapCall: function wrapCall(fun) {\n    var _this = this;\n\n    this.lock();\n    var maybePromise;\n\n    try {\n      maybePromise = fun();\n    } catch (err) {\n      this.unlock();\n      throw err;\n    }\n\n    if (!maybePromise.then || typeof maybePromise.then !== 'function') {\n      // no promise\n      this.unlock();\n      return maybePromise;\n    } else {\n      // promise\n      return maybePromise.then(function (ret) {\n        // sucessfull -> unlock before return\n        _this.unlock();\n\n        return ret;\n      })[\"catch\"](function (err) {\n        // not sucessfull -> unlock before throwing\n        _this.unlock();\n\n        throw err;\n      });\n    }\n  },\n\n  /**\n   * does the same as requestIdleCallback() but uses promises instead of the callback\n   * @param {{timeout?: number}} options like timeout\n   * @return {Promise<void>} promise that resolves when the database is in idle-mode\n   */\n  requestIdlePromise: function requestIdlePromise(options) {\n    var _this2 = this;\n\n    options = options || {};\n    var resolve;\n    var prom = new Promise(function (res) {\n      return resolve = res;\n    });\n\n    var resolveFromOutside = function resolveFromOutside() {\n      _removeIdlePromise(_this2, prom);\n\n      resolve();\n    };\n\n    prom._manRes = resolveFromOutside;\n\n    if (options.timeout) {\n      // if timeout has passed, resolve promise even if not idle\n      var timeoutObj = setTimeout(function () {\n        prom._manRes();\n      }, options.timeout);\n      prom._timeoutObj = timeoutObj;\n    }\n\n    this._iC.add(prom);\n\n    _tryIdleCall(this);\n\n    return prom;\n  },\n\n  /**\n   * remove the promise so it will never be resolved\n   * @param  {Promise} promise from requestIdlePromise()\n   * @return {void}\n   */\n  cancelIdlePromise: function cancelIdlePromise(promise) {\n    _removeIdlePromise(this, promise);\n  },\n\n  /**\n   * api equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/requestIdleCallback\n   * @param  {Function} callback\n   * @param  {options}   options  [description]\n   * @return {number} handle which can be used with cancelIdleCallback()\n   */\n  requestIdleCallback: function requestIdleCallback(callback, options) {\n    var handle = this._lHN++;\n    var promise = this.requestIdlePromise(options);\n\n    this._hPM.set(handle, promise);\n\n    this._pHM.set(promise, handle);\n\n    promise.then(function () {\n      return callback();\n    });\n    return handle;\n  },\n\n  /**\n   * API equal to\n   * @link https://developer.mozilla.org/en-US/docs/Web/API/Window/cancelIdleCallback\n   * @param  {number} handle returned from requestIdleCallback()\n   * @return {void}\n   */\n  cancelIdleCallback: function cancelIdleCallback(handle) {\n    var promise = this._hPM.get(handle);\n\n    this.cancelIdlePromise(promise);\n  },\n\n  /**\n   * clears and resets everything\n   * @return {void}\n   */\n  clear: function clear() {\n    var _this3 = this;\n\n    // remove all non-cleared\n    this._iC.forEach(function (promise) {\n      return _removeIdlePromise(_this3, promise);\n    });\n\n    this._qC = 0;\n\n    this._iC.clear();\n\n    this._hPM = new Map();\n    this._pHM = new Map();\n  }\n};\n/**\n * processes the oldest call of the idleCalls-queue\n * @return {Promise<void>}\n */\n\nfunction _resolveOneIdleCall(idleQueue) {\n  if (idleQueue._iC.size === 0) return;\n\n  var iterator = idleQueue._iC.values();\n\n  var oldestPromise = iterator.next().value;\n\n  oldestPromise._manRes(); // try to call the next tick\n\n\n  setTimeout(function () {\n    return _tryIdleCall(idleQueue);\n  }, 0);\n}\n/**\n * removes the promise from the queue and maps and also its corresponding handle-number\n * @param  {Promise} promise from requestIdlePromise()\n * @return {void}\n */\n\n\nfunction _removeIdlePromise(idleQueue, promise) {\n  if (!promise) return; // remove timeout if exists\n\n  if (promise._timeoutObj) clearTimeout(promise._timeoutObj); // remove handle-nr if exists\n\n  if (idleQueue._pHM.has(promise)) {\n    var handle = idleQueue._pHM.get(promise);\n\n    idleQueue._hPM[\"delete\"](handle);\n\n    idleQueue._pHM[\"delete\"](promise);\n  } // remove from queue\n\n\n  idleQueue._iC[\"delete\"](promise);\n}\n/**\n * resolves the last entry of this._iC\n * but only if the queue is empty\n * @return {Promise}\n */\n\n\nfunction _tryIdleCall(idleQueue) {\n  // ensure this does not run in parallel\n  if (idleQueue._tryIR || idleQueue._iC.size === 0) return;\n  idleQueue._tryIR = true; // w8 one tick\n\n  setTimeout(function () {\n    // check if queue empty\n    if (!idleQueue.isIdle()) {\n      idleQueue._tryIR = false;\n      return;\n    }\n    /**\n     * wait 1 tick here\n     * because many functions do IO->CPU->IO\n     * which means the queue is empty for a short time\n     * but the ressource is not idle\n     */\n\n\n    setTimeout(function () {\n      // check if queue still empty\n      if (!idleQueue.isIdle()) {\n        idleQueue._tryIR = false;\n        return;\n      } // ressource is idle\n\n\n      _resolveOneIdleCall(idleQueue);\n\n      idleQueue._tryIR = false;\n    }, 0);\n  }, 0);\n}", "import { IdleQueue } from 'custom-idle-queue';\nimport type {\n    LeaderElector\n} from 'broadcast-channel';\nimport type {\n    CollectionsOfDatabase,\n    RxDatabase,\n    RxCollectionCreator,\n    RxJsonSchema,\n    RxCollection,\n    RxDumpDatabase,\n    RxDumpDatabaseAny,\n    BackupOptions,\n    RxStorage,\n    RxStorageInstance,\n    BulkWriteRow,\n    RxChangeEvent,\n    RxDatabaseCreator,\n    RxChangeEventBulk,\n    RxDocumentData,\n    RxCleanupPolicy,\n    InternalStoreDocType,\n    InternalStoreStorageTokenDocType,\n    InternalStoreCollectionDocType,\n    RxTypeError,\n    RxError,\n    HashFunction,\n    MaybePromise,\n    RxState\n} from './types/index.d.ts';\n\nimport {\n    pluginMissing,\n    flatClone,\n    PROMISE_RESOLVE_FALSE,\n    randomCouchString,\n    ensureNotFalsy,\n    getDefaultRevision,\n    getDefaultRxDocumentMeta,\n    defaultHashSha256,\n    RXDB_VERSION\n} from './plugins/utils/index.ts';\nimport {\n    newRxError\n} from './rx-error.ts';\nimport {\n    createRxSchema,\n    RxSchema\n} from './rx-schema.ts';\nimport {\n    runPluginHooks,\n    runAsyncPluginHooks\n} from './hooks.ts';\nimport {\n    Subject,\n    Subscription,\n    Observable\n} from 'rxjs';\nimport {\n    mergeMap\n} from 'rxjs/operators';\nimport {\n    createRxCollection\n} from './rx-collection.ts';\nimport {\n    flatCloneDocWithMeta,\n    getSingleDocument,\n    getWrappedStorageInstance,\n    INTERNAL_STORAGE_NAME,\n    WrappedRxStorageInstance\n} from './rx-storage-helper.ts';\nimport type { RxBackupState } from './plugins/backup/index.ts';\nimport { ObliviousSet } from 'oblivious-set';\nimport {\n    ensureStorageTokenDocumentExists,\n    getAllCollectionDocuments,\n    getPrimaryKeyOfInternalDocument,\n    INTERNAL_CONTEXT_COLLECTION,\n    INTERNAL_STORE_SCHEMA,\n    _collectionNamePrimary\n} from './rx-database-internal-store.ts';\nimport { removeCollectionStorages } from './rx-collection-helper.ts';\nimport { overwritable } from './overwritable.ts';\nimport type { RxMigrationState } from './plugins/migration-schema/index.ts';\nimport type { RxReactivityFactory } from './types/plugins/reactivity.d.ts';\n\n/**\n * stores the used database names+storage names\n * so we can throw when the same database is created more then once.\n */\nconst USED_DATABASE_NAMES: Set<string> = new Set();\n\nlet DB_COUNT = 0;\n\nexport class RxDatabaseBase<\n    Internals,\n    InstanceCreationOptions,\n    Collections = CollectionsOfDatabase,\n    Reactivity = unknown\n> {\n\n    public readonly idleQueue: IdleQueue = new IdleQueue();\n    public readonly rxdbVersion = RXDB_VERSION;\n\n    /**\n     * Contains all known non-closed storage instances\n     * that belong to this database.\n     * Used in plugins and unit tests.\n     */\n    public readonly storageInstances = new Set<WrappedRxStorageInstance<any, Internals, InstanceCreationOptions>>();\n\n    constructor(\n        public readonly name: string,\n        /**\n         * Uniquely identifies the instance\n         * of this RxDatabase.\n         */\n        public readonly token: string,\n        public readonly storage: RxStorage<Internals, InstanceCreationOptions>,\n        public readonly instanceCreationOptions: InstanceCreationOptions,\n        public readonly password: any,\n        public readonly multiInstance: boolean,\n        public readonly eventReduce: boolean = false,\n        public options: any = {},\n        /**\n         * Stores information documents about the collections of the database\n         */\n        public readonly internalStore: RxStorageInstance<InternalStoreDocType, Internals, InstanceCreationOptions>,\n        public readonly hashFunction: HashFunction,\n        public readonly cleanupPolicy?: Partial<RxCleanupPolicy>,\n        public readonly allowSlowCount?: boolean,\n        public readonly reactivity?: RxReactivityFactory<any>\n    ) {\n        DB_COUNT++;\n\n        /**\n         * In the dev-mode, we create a pseudoInstance\n         * to get all properties of RxDatabase and ensure they do not\n         * conflict with the collection names etc.\n         * So only if it is not pseudoInstance,\n         * we have all values to prepare a real RxDatabase.\n         *\n         * TODO this is ugly, we should use a different way in the dev-mode\n         * so that all non-dev-mode code can be cleaner.\n         */\n        if (this.name !== 'pseudoInstance') {\n            /**\n             * Wrap the internal store\n             * to ensure that calls to it also end up in\n             * calculation of the idle state and the hooks.\n             */\n            this.internalStore = getWrappedStorageInstance(\n                this.asRxDatabase,\n                internalStore,\n                INTERNAL_STORE_SCHEMA\n            );\n\n            /**\n             * Start writing the storage token.\n             * Do not await the creation because it would run\n             * in a critical path that increases startup time.\n             *\n             * Writing the token takes about 20 milliseconds\n             * even on a fast adapter, so this is worth it.\n             */\n            this.storageTokenDocument = ensureStorageTokenDocumentExists(this.asRxDatabase)\n                .catch(err => this.startupErrors.push(err) as any);\n            this.storageToken = this.storageTokenDocument\n                .then(doc => doc.data.token)\n                .catch(err => this.startupErrors.push(err) as any);\n        }\n    }\n\n    get $(): Observable<RxChangeEvent<any>> {\n        return this.observable$;\n    }\n\n    public getReactivityFactory(): RxReactivityFactory<Reactivity> {\n        if (!this.reactivity) {\n            throw newRxError('DB14', { database: this.name });\n        }\n        return this.reactivity;\n    }\n\n    public _subs: Subscription[] = [];\n\n    /**\n     * Because having unhandled exceptions would fail,\n     * we have to store the async errors of the constructor here\n     * so we can throw them later.\n     */\n    public startupErrors: (RxError | RxTypeError)[] = [];\n\n    /**\n     * When the database is destroyed,\n     * these functions will be called an awaited.\n     * Used to automatically clean up stuff that\n     * belongs to this collection.\n     */\n    public onDestroy: (() => MaybePromise<any>)[] = [];\n    public destroyed: boolean = false;\n    public collections: Collections = {} as any;\n    public states: { [name: string]: RxState<any, Reactivity>; } = {};\n    public readonly eventBulks$: Subject<RxChangeEventBulk<any>> = new Subject();\n    private observable$: Observable<RxChangeEvent<any>> = this.eventBulks$\n        .pipe(\n            mergeMap(changeEventBulk => changeEventBulk.events)\n        );\n\n    /**\n     * Unique token that is stored with the data.\n     * Used to detect if the dataset has been deleted\n     * and if two RxDatabase instances work on the same dataset or not.\n     *\n     * Because reading and writing the storageToken runs in the hot path\n     * of database creation, we do not await the storageWrites but instead\n     * work with the promise when we need the value.\n     */\n    public storageToken: Promise<string> = PROMISE_RESOLVE_FALSE as any;\n    /**\n     * Stores the whole state of the internal storage token document.\n     * We need this in some plugins.\n     */\n    public storageTokenDocument: Promise<RxDocumentData<InternalStoreStorageTokenDocType>> = PROMISE_RESOLVE_FALSE as any;\n\n    /**\n     * Contains the ids of all event bulks that have been emitted\n     * by the database.\n     * Used to detect duplicates that come in again via BroadcastChannel\n     * or other streams.\n     * TODO instead of having this here, we should add a test to ensure each RxStorage\n     * behaves equal and does never emit duplicate eventBulks.\n     */\n    public emittedEventBulkIds: ObliviousSet<string> = new ObliviousSet(60 * 1000);\n\n    /**\n     * This is the main handle-point for all change events\n     * ChangeEvents created by this instance go:\n     * RxDocument -> RxCollection -> RxDatabase.$emit -> MultiInstance\n     * ChangeEvents created by other instances go:\n     * MultiInstance -> RxDatabase.$emit -> RxCollection -> RxDatabase\n     */\n    $emit(changeEventBulk: RxChangeEventBulk<any>) {\n        if (this.emittedEventBulkIds.has(changeEventBulk.id)) {\n            return;\n        }\n        this.emittedEventBulkIds.add(changeEventBulk.id);\n\n        // emit into own stream\n        this.eventBulks$.next(changeEventBulk);\n    }\n\n    /**\n     * removes the collection-doc from the internalStore\n     */\n    async removeCollectionDoc(name: string, schema: any): Promise<void> {\n        const doc = await getSingleDocument(\n            this.internalStore,\n            getPrimaryKeyOfInternalDocument(\n                _collectionNamePrimary(name, schema),\n                INTERNAL_CONTEXT_COLLECTION\n            )\n        );\n        if (!doc) {\n            throw newRxError('SNH', { name, schema });\n        }\n        const writeDoc = flatCloneDocWithMeta(doc);\n        writeDoc._deleted = true;\n\n        await this.internalStore.bulkWrite([{\n            document: writeDoc,\n            previous: doc\n        }], 'rx-database-remove-collection');\n    }\n\n    /**\n     * creates multiple RxCollections at once\n     * to be much faster by saving db txs and doing stuff in bulk-operations\n     * This function is not called often, but mostly in the critical path at the initial page load\n     * So it must be as fast as possible.\n     */\n    async addCollections<CreatedCollections = Partial<Collections>>(collectionCreators: {\n        [key in keyof CreatedCollections]: RxCollectionCreator<any>\n    }): Promise<{ [key in keyof CreatedCollections]: RxCollection<any, {}, {}, {}, Reactivity> }> {\n        const jsonSchemas: { [key in keyof CreatedCollections]: RxJsonSchema<any> } = {} as any;\n        const schemas: { [key in keyof CreatedCollections]: RxSchema<any> } = {} as any;\n        const bulkPutDocs: BulkWriteRow<InternalStoreCollectionDocType>[] = [];\n        const useArgsByCollectionName: any = {};\n\n        await Promise.all(\n            Object.entries(collectionCreators).map(async ([name, args]) => {\n                const collectionName: keyof CreatedCollections = name as any;\n                const rxJsonSchema = (args as RxCollectionCreator<any>).schema;\n                jsonSchemas[collectionName] = rxJsonSchema;\n                const schema = createRxSchema(rxJsonSchema, this.hashFunction);\n                schemas[collectionName] = schema;\n\n                // collection already exists\n                if ((this.collections as any)[name]) {\n                    throw newRxError('DB3', {\n                        name\n                    });\n                }\n\n                const collectionNameWithVersion = _collectionNamePrimary(name, rxJsonSchema);\n                const collectionDocData: RxDocumentData<InternalStoreCollectionDocType> = {\n                    id: getPrimaryKeyOfInternalDocument(\n                        collectionNameWithVersion,\n                        INTERNAL_CONTEXT_COLLECTION\n                    ),\n                    key: collectionNameWithVersion,\n                    context: INTERNAL_CONTEXT_COLLECTION,\n                    data: {\n                        name: collectionName as any,\n                        schemaHash: await schema.hash,\n                        schema: schema.jsonSchema,\n                        version: schema.version,\n                        connectedStorages: []\n                    },\n                    _deleted: false,\n                    _meta: getDefaultRxDocumentMeta(),\n                    _rev: getDefaultRevision(),\n                    _attachments: {}\n                };\n                bulkPutDocs.push({\n                    document: collectionDocData\n                });\n\n                const useArgs: any = Object.assign(\n                    {},\n                    args,\n                    {\n                        name: collectionName,\n                        schema,\n                        database: this\n                    }\n                );\n\n                // run hooks\n                const hookData: RxCollectionCreator<any> & { name: string; } = flatClone(args) as any;\n                (hookData as any).database = this;\n                hookData.name = name;\n                runPluginHooks('preCreateRxCollection', hookData);\n                useArgs.conflictHandler = hookData.conflictHandler;\n\n                useArgsByCollectionName[collectionName] = useArgs;\n            })\n        );\n\n\n        const putDocsResult = await this.internalStore.bulkWrite(\n            bulkPutDocs,\n            'rx-database-add-collection'\n        );\n\n        await ensureNoStartupErrors(this);\n\n        await Promise.all(\n            putDocsResult.error.map(async (error) => {\n                if (error.status !== 409) {\n                    throw newRxError('DB12', {\n                        database: this.name,\n                        writeError: error\n                    });\n                }\n                const docInDb: RxDocumentData<InternalStoreCollectionDocType> = ensureNotFalsy(error.documentInDb);\n                const collectionName = docInDb.data.name;\n                const schema = (schemas as any)[collectionName];\n                // collection already exists but has different schema\n                if (docInDb.data.schemaHash !== await schema.hash) {\n                    throw newRxError('DB6', {\n                        database: this.name,\n                        collection: collectionName,\n                        previousSchemaHash: docInDb.data.schemaHash,\n                        schemaHash: await schema.hash,\n                        previousSchema: docInDb.data.schema,\n                        schema: ensureNotFalsy((jsonSchemas as any)[collectionName])\n                    });\n                }\n            })\n        );\n\n        const ret: { [key in keyof CreatedCollections]: RxCollection<any, {}, {}, {}, Reactivity> } = {} as any;\n        await Promise.all(\n            Object.keys(collectionCreators).map(async (collectionName) => {\n                const useArgs = useArgsByCollectionName[collectionName];\n                const collection = await createRxCollection(useArgs);\n                (ret as any)[collectionName] = collection;\n\n                // set as getter to the database\n                (this.collections as any)[collectionName] = collection;\n                if (!(this as any)[collectionName]) {\n                    Object.defineProperty(this, collectionName, {\n                        get: () => (this.collections as any)[collectionName]\n                    });\n                }\n            })\n        );\n\n        return ret;\n    }\n\n    /**\n     * runs the given function between idleQueue-locking\n     */\n    lockedRun<T>(fn: (...args: any[]) => T): T extends Promise<any> ? T : Promise<T> {\n        return this.idleQueue.wrapCall(fn) as any;\n    }\n\n    requestIdlePromise() {\n        return this.idleQueue.requestIdlePromise();\n    }\n\n    /**\n     * Export database to a JSON friendly format.\n     */\n    exportJSON(_collections?: string[]): Promise<RxDumpDatabase<Collections>>;\n    exportJSON(_collections?: string[]): Promise<RxDumpDatabaseAny<Collections>>;\n    exportJSON(_collections?: string[]): Promise<any> {\n        throw pluginMissing('json-dump');\n    }\n\n    addState<T = any>(_name?: string): Promise<RxState<T, Reactivity>> {\n        throw pluginMissing('state');\n    }\n\n    /**\n     * Import the parsed JSON export into the collection.\n     * @param _exportedJSON The previously exported data from the `<db>.exportJSON()` method.\n     * @note When an interface is loaded in this collection all base properties of the type are typed as `any`\n     * since data could be encrypted.\n     */\n    importJSON(_exportedJSON: RxDumpDatabaseAny<Collections>): Promise<void> {\n        throw pluginMissing('json-dump');\n    }\n\n    backup(_options: BackupOptions): RxBackupState {\n        throw pluginMissing('backup');\n    }\n\n    public leaderElector(): LeaderElector {\n        throw pluginMissing('leader-election');\n    }\n\n    public isLeader(): boolean {\n        throw pluginMissing('leader-election');\n    }\n    /**\n     * returns a promise which resolves when the instance becomes leader\n     */\n    public waitForLeadership(): Promise<boolean> {\n        throw pluginMissing('leader-election');\n    }\n\n    public migrationStates(): Observable<RxMigrationState[]> {\n        throw pluginMissing('migration-schema');\n    }\n\n    /**\n     * destroys the database-instance and all collections\n     */\n    public async destroy(): Promise<boolean> {\n        if (this.destroyed) {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        // settings destroyed = true must be the first thing to do.\n        this.destroyed = true;\n\n        await runAsyncPluginHooks('preDestroyRxDatabase', this);\n        /**\n         * Complete the event stream\n         * to stop all subscribers who forgot to unsubscribe.\n         */\n        this.eventBulks$.complete();\n\n        DB_COUNT--;\n        this._subs.map(sub => sub.unsubscribe());\n\n        /**\n         * Destroying the pseudo instance will throw\n         * because stuff is missing\n         * TODO we should not need the pseudo instance on runtime.\n         * we should generate the property list on build time.\n         */\n        if (this.name === 'pseudoInstance') {\n            return PROMISE_RESOLVE_FALSE;\n        }\n\n        /**\n         * First wait until the database is idle\n         */\n        return this.requestIdlePromise()\n            .then(() => Promise.all(this.onDestroy.map(fn => fn())))\n            // destroy all collections\n            .then(() => Promise.all(\n                Object.keys(this.collections as any)\n                    .map(key => (this.collections as any)[key])\n                    .map(col => col.destroy())\n            ))\n            // destroy internal storage instances\n            .then(() => this.internalStore.close())\n            // remove combination from USED_COMBINATIONS-map\n            .then(() => USED_DATABASE_NAMES.delete(this.storage.name + '|' + this.name))\n            .then(() => true);\n    }\n\n    /**\n     * deletes the database and its stored data.\n     * Returns the names of all removed collections.\n     */\n    remove(): Promise<string[]> {\n        return this\n            .destroy()\n            .then(() => removeRxDatabase(this.name, this.storage, this.password));\n    }\n\n    get asRxDatabase(): RxDatabase<\n        {},\n        Internals,\n        InstanceCreationOptions,\n        Reactivity\n    > {\n        return this as any;\n    }\n}\n\n/**\n * checks if an instance with same name and storage already exists\n * @throws {RxError} if used\n */\nfunction throwIfDatabaseNameUsed(\n    name: string,\n    storage: RxStorage<any, any>\n) {\n    const key = storage.name + '|' + name;\n    if (!USED_DATABASE_NAMES.has(key)) {\n        return;\n    } else {\n        throw newRxError('DB8', {\n            name,\n            storage: storage.name,\n            link: 'https://rxdb.info/rx-database.html#ignoreduplicate'\n        });\n    }\n}\n\n/**\n * Creates the storage instances that are used internally in the database\n * to store schemas and other configuration stuff.\n */\nexport async function createRxDatabaseStorageInstance<Internals, InstanceCreationOptions>(\n    databaseInstanceToken: string,\n    storage: RxStorage<Internals, InstanceCreationOptions>,\n    databaseName: string,\n    options: InstanceCreationOptions,\n    multiInstance: boolean,\n    password?: string\n): Promise<RxStorageInstance<InternalStoreDocType, Internals, InstanceCreationOptions>> {\n    const internalStore = await storage.createStorageInstance<InternalStoreDocType>(\n        {\n            databaseInstanceToken,\n            databaseName,\n            collectionName: INTERNAL_STORAGE_NAME,\n            schema: INTERNAL_STORE_SCHEMA,\n            options,\n            multiInstance,\n            password,\n            devMode: overwritable.isDevMode()\n        }\n    );\n    return internalStore;\n}\n\nexport function createRxDatabase<\n    Collections = { [key: string]: RxCollection; },\n    Internals = any,\n    InstanceCreationOptions = any,\n    Reactivity = unknown\n>(\n    {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance = true,\n        eventReduce = true,\n        ignoreDuplicate = false,\n        options = {},\n        cleanupPolicy,\n        allowSlowCount = false,\n        localDocuments = false,\n        hashFunction = defaultHashSha256,\n        reactivity\n    }: RxDatabaseCreator<Internals, InstanceCreationOptions, Reactivity>\n): Promise<\n    RxDatabase<Collections, Internals, InstanceCreationOptions, Reactivity>\n> {\n    runPluginHooks('preCreateRxDatabase', {\n        storage,\n        instanceCreationOptions,\n        name,\n        password,\n        multiInstance,\n        eventReduce,\n        ignoreDuplicate,\n        options,\n        localDocuments\n    });\n    // check if combination already used\n    if (!ignoreDuplicate) {\n        throwIfDatabaseNameUsed(name, storage);\n    }\n    USED_DATABASE_NAMES.add(storage.name + '|' + name);\n\n    const databaseInstanceToken = randomCouchString(10);\n\n    return createRxDatabaseStorageInstance<\n        Internals,\n        InstanceCreationOptions\n    >(\n        databaseInstanceToken,\n        storage,\n        name,\n        instanceCreationOptions as any,\n        multiInstance,\n        password\n    )\n        /**\n         * Creating the internal store might fail\n         * if some RxStorage wrapper is used that does some checks\n         * and then throw.\n         * In that case we have to properly clean up the database.\n         */\n        .catch(err => {\n            USED_DATABASE_NAMES.delete(storage.name + '|' + name);\n            throw err;\n        })\n        .then(storageInstance => {\n            const rxDatabase: RxDatabase<Collections> = new RxDatabaseBase(\n                name,\n                databaseInstanceToken,\n                storage,\n                instanceCreationOptions,\n                password,\n                multiInstance,\n                eventReduce,\n                options,\n                storageInstance,\n                hashFunction,\n                cleanupPolicy,\n                allowSlowCount,\n                reactivity\n            ) as any;\n\n            return runAsyncPluginHooks('createRxDatabase', {\n                database: rxDatabase,\n                creator: {\n                    storage,\n                    instanceCreationOptions,\n                    name,\n                    password,\n                    multiInstance,\n                    eventReduce,\n                    ignoreDuplicate,\n                    options,\n                    localDocuments\n                }\n            }).then(() => rxDatabase);\n        });\n}\n\n/**\n * Removes the database and all its known data\n * with all known collections and all internal meta data.\n *\n * Returns the names of the removed collections.\n */\nexport async function removeRxDatabase(\n    databaseName: string,\n    storage: RxStorage<any, any>,\n    password?: string\n): Promise<string[]> {\n    const databaseInstanceToken = randomCouchString(10);\n    const dbInternalsStorageInstance = await createRxDatabaseStorageInstance(\n        databaseInstanceToken,\n        storage,\n        databaseName,\n        {},\n        false,\n        password\n    );\n    const collectionDocs = await getAllCollectionDocuments(dbInternalsStorageInstance);\n    const collectionNames = new Set<string>();\n    collectionDocs.forEach(doc => collectionNames.add(doc.data.name));\n    const removedCollectionNames: string[] = Array.from(collectionNames);\n\n    await Promise.all(\n        removedCollectionNames.map(collectionName => removeCollectionStorages(\n            storage,\n            dbInternalsStorageInstance,\n            databaseInstanceToken,\n            databaseName,\n            collectionName,\n            password\n        ))\n    );\n\n    await runAsyncPluginHooks('postRemoveRxDatabase', {\n        databaseName,\n        storage\n    });\n\n    await dbInternalsStorageInstance.remove();\n    return removedCollectionNames;\n}\n\nexport function isRxDatabase(obj: any) {\n    return obj instanceof RxDatabaseBase;\n}\n\nexport function dbCount(): number {\n    return DB_COUNT;\n}\n\n\n/**\n * Returns true if the given RxDatabase was the first\n * instance that was created on the storage with this name.\n *\n * Can be used for some optimizations because on the first instantiation,\n * we can assume that no data was written before.\n */\nexport async function isRxDatabaseFirstTimeInstantiated(\n    database: RxDatabase\n): Promise<boolean> {\n    const tokenDoc = await database.storageTokenDocument;\n    return tokenDoc.data.instanceToken === database.token;\n}\n\n\n/**\n * For better performance some tasks run async\n * and are awaited later.\n * But we still have to ensure that there have been no errors\n * on database creation.\n */\nexport async function ensureNoStartupErrors(\n    rxDatabase: RxDatabaseBase<any, any, any, any>\n) {\n    await rxDatabase.storageToken;\n    if (rxDatabase.startupErrors[0]) {\n        throw rxDatabase.startupErrors[0];\n    }\n}\n"],
  "mappings": "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",
  "names": ["INTERNAL_CONTEXT_COLLECTION", "INTERNAL_CONTEXT_STORAGE_TOKEN", "INTERNAL_CONTEXT_MIGRATION_STATUS", "INTERNAL_STORE_SCHEMA_TITLE", "INTERNAL_STORE_SCHEMA", "fillWithDefaultSettings", "version", "title", "primaryKey", "key", "fields", "separator", "type", "properties", "id", "maxLength", "context", "enum", "data", "additionalProperties", "indexes", "required", "sharding", "shards", "mode", "getPrimaryKeyOfInternalDocument", "getComposedPrimaryKeyOfDocumentData", "getAllCollectionDocuments", "storageInstance", "getAllQueryPrepared", "prepareQuery", "schema", "selector", "_deleted", "$eq", "sort", "skip", "queryResult", "query", "allDocs", "documents", "STORAGE_TOKEN_DOCUMENT_KEY", "STORAGE_TOKEN_DOCUMENT_ID", "ensureStorageTokenDocumentExists", "rxDatabase", "storageToken", "randomCouchString", "passwordHash", "password", "hashFunction", "JSON", "stringify", "undefined", "docData", "rxdbVersion", "token", "instanceToken", "_meta", "getDefaultRxDocumentMeta", "_rev", "getDefaultRevision", "_attachments", "writeRows", "document", "writeResult", "internalStore", "bulkWrite", "error", "getWrittenDocumentsFromBulkWriteResponse", "ensureNotFalsy", "isError", "isBulkWriteConflictError", "conflictError", "isDatabaseStateVersionCompatibleWithDatabaseCode", "documentInDb", "newRxError", "args", "database", "name", "databaseStateVersion", "codeVersion", "existingPasswordHash", "storageTokenDocInDb", "includes", "stateMajor", "split", "codeMajor", "addConnectedStorageToCollection", "collection", "storageCollectionName", "collectionNameWithVersion", "_collectionNamePrimary", "jsonSchema", "collectionDocId", "collectionDoc", "getSingleDocument", "saveData", "clone", "alreadyThere", "connectedStorages", "find", "row", "collectionName", "push", "writeSingle", "previous", "err", "removeConnectedStorageFromCollection", "isThere", "filter", "item", "fillObjectDataBeforeInsert", "schema", "data", "flatClone", "fillObjectWithDefaults", "jsonSchema", "primaryKey", "fillPrimaryKey", "primaryPath", "_meta", "getDefaultRxDocumentMeta", "Object", "prototype", "hasOwnProperty", "call", "_deleted", "_attachments", "_rev", "getDefaultRevision", "createRxCollectionStorageInstance", "rxDatabase", "storageInstanceCreationParams", "multiInstance", "storageInstance", "storage", "createStorageInstance", "removeCollectionStorages", "databaseInternalStorage", "databaseInstanceToken", "databaseName", "collectionName", "password", "hashFunction", "allCollectionMetaDocs", "getAllCollectionDocuments", "relevantCollectionMetaDocs", "filter", "metaDoc", "name", "removeStorages", "forEach", "push", "isCollection", "connectedStorages", "row", "alreadyAdded", "Set", "key", "version", "has", "add", "Promise", "all", "map", "options", "devMode", "overwritable", "isDevMode", "remove", "runAsyncPluginHooks", "writeRows", "doc", "writeDoc", "flatCloneDocWithMeta", "lwt", "now", "createRevision", "previous", "document", "bulkWrite", "ensureRxCollectionIsNotDestroyed", "collection", "destroyed", "newRxError", "IncrementalWriteQueue", "storageInstance", "primaryPath", "preWrite", "postWrite", "queueByDocId", "Map", "isRunning", "_proto", "prototype", "addWrite", "lastKnownDocumentState", "modifier", "docId", "ar", "getFromMapOrCreate", "ret", "Promise", "resolve", "reject", "item", "ensureNotFalsy", "push", "triggerRun", "size", "writeRows", "itemsById", "all", "Array", "from", "entries", "map", "_docId", "items", "oldData", "findNewestOfDocumentStates", "i", "newData", "clone", "err", "forEach", "previous", "document", "writeResult", "length", "bulkWrite", "error", "getWrittenDocumentsFromBulkWriteResponse", "result", "getFromMapOrThrow", "documentId", "isConflict", "isBulkWriteConflictError", "reverse", "documentInDb", "unshift", "rxError", "rxStorageWriteErrorToRxError", "modifierFromPublicToInternal", "publicModifier", "docData", "withoutMeta", "stripMetaDataFromDocument", "_deleted", "modified", "reattachedMeta", "Object", "assign", "_meta", "_attachments", "_rev", "docs", "newest", "newestRevisionHeight", "getHeightOfRevision", "doc", "height", "basePrototype", "primaryPath", "_this", "isInstanceOfRxDocument", "undefined", "collection", "schema", "primary", "_data", "revision", "_rev", "deleted$", "$", "pipe", "map", "d", "_deleted", "deleted$$", "reactivity", "database", "getReactivityFactory", "fromObservable", "getLatest", "deleted", "latestDocData", "_docCache", "getLatestDocumentData", "getCachedRxDocument", "filter", "changeEvent", "isLocal", "documentId", "getDocumentDataOfRxChangeEvent", "startWith", "distinctUntilChanged", "prev", "curr", "docData", "shareReplay", "RXJS_SHARE_REPLAY_DEFAULTS", "$$", "get$", "path", "overwritable", "isDevMode", "includes", "newRxError", "finalFields", "schemaObj", "getSchemaByObjectPath", "jsonSchema", "data", "getProperty", "get$$", "obs", "get", "populate", "value", "PROMISE_RESOLVE_NULL", "ref", "refCollection", "collections", "type", "findByIds", "exec", "then", "res", "valuesIterator", "values", "Array", "from", "findOne", "objPath", "getDocumentProperty", "toJSON", "withMetaFields", "flatClone", "_attachments", "_meta", "deepFreezeWhenDevMode", "toMutableJSON", "clone", "update", "_updateObj", "pluginMissing", "incrementalUpdate", "updateCRDT", "putAttachment", "getAttachment", "allAttachments", "allAttachments$", "modify", "mutationFunction", "_context", "oldData", "newData", "modifierFromPublicToInternal", "_saveData", "incrementalModify", "incrementalWriteQueue", "addWrite", "result", "patch", "Object", "entries", "forEach", "k", "v", "incrementalPatch", "id", "document", "beforeDocumentUpdateWrite", "writeRows", "previous", "writeResult", "storageInstance", "bulkWrite", "isError", "error", "throwIfIsStorageWriteError", "_runHooks", "getWrittenDocumentsFromBulkWriteResponse", "remove", "Promise", "reject", "deletedData", "removedDocData", "removed", "incrementalRemove", "newDoc", "destroy", "createRxDocumentConstructor", "proto", "constructor", "RxDocumentConstructor", "_propertyCache", "Map", "prototype", "createWithConstructor", "jsonData", "doc", "runPluginHooks", "isRxDocument", "obj", "assign", "validateChange", "getFromMapOrCreate", "valueObj", "isArray", "proxy", "Proxy", "target", "property", "lastChar", "charAt", "length", "endsWith", "key", "slice", "trimDots", "plainValue", "constructorForCollection", "WeakMap", "getDocumentPrototype", "rxCollection", "schemaProto", "schema", "ormProto", "getDocumentOrmPrototype", "baseProto", "basePrototype", "proto", "forEach", "obj", "props", "Object", "getOwnPropertyNames", "key", "desc", "getOwnPropertyDescriptor", "enumerable", "startsWith", "endsWith", "value", "defineProperty", "get", "bind", "configurable", "writable", "getRxDocumentConstructor", "getFromMapOrCreate", "createRxDocumentConstructor", "createNewRxDocument", "documentConstructor", "docData", "doc", "createRxDocumentWithConstructor", "overwritable", "deepFreezeWhenDevMode", "_runHooksSync", "runPluginHooks", "entries", "methods", "k", "v", "getLastCheckpointDoc", "state", "direction", "checkpointDocId", "getComposedPrimaryKeyOfDocumentData", "input", "metaInstance", "schema", "isCheckpoint", "itemId", "checkpointResult", "findDocumentsById", "checkpointDoc", "lastCheckpointDoc", "checkpointData", "undefined", "setCheckpoint", "checkpoint", "checkpointQueue", "then", "previousCheckpointDoc", "events", "canceled", "getValue", "JSON", "stringify", "newDoc", "id", "_deleted", "_attachments", "_meta", "getDefaultRxDocumentMeta", "_rev", "getDefaultRevision", "stackCheckpoints", "lwt", "now", "createRevision", "checkpointKey", "writeRows", "previous", "document", "result", "bulkWrite", "successDoc", "getWrittenDocumentsFromBulkWriteResponse", "primaryPath", "error", "status", "ensureNotFalsy", "documentInDb", "getCheckpointKey", "hash", "hashFunction", "identifier", "forkInstance", "databaseName", "collectionName", "join", "docStateToWriteDoc", "databaseInstanceToken", "hasAttachments", "keepMeta", "docState", "previous", "docData", "Object", "assign", "_attachments", "_meta", "lwt", "now", "_rev", "getDefaultRevision", "createRevision", "writeDocToDocState", "writeDoc", "keepAttachments", "ret", "flatClone", "stripAttachmentsDataFromMetaWriteRows", "state", "rows", "map", "row", "document", "clone", "stripAttachmentsDataFromDocument", "getUnderlyingPersistentStorage", "instance", "underlyingPersistentStorage", "META_INSTANCE_SCHEMA_TITLE", "getRxReplicationMetaInstanceSchema", "replicatedDocumentsSchema", "encrypted", "parentPrimaryKeyLength", "getLengthOfPrimaryKey", "baseSchema", "title", "primaryKey", "key", "fields", "separator", "type", "version", "additionalProperties", "properties", "id", "minLength", "maxLength", "isCheckpoint", "enum", "itemId", "checkpointData", "docData", "isResolvedConflict", "keyCompression", "required", "metaInstanceSchema", "fillWithDefaultSettings", "getAssumedMasterState", "state", "docIds", "input", "metaInstance", "findDocumentsById", "map", "docId", "useId", "getComposedPrimaryKeyOfDocumentData", "schema", "then", "metaDocs", "ret", "Object", "values", "forEach", "metaDoc", "metaDocument", "getMetaWriteRow", "newMasterDocState", "previous", "primaryPath", "newMeta", "flatCloneDocWithMeta", "_attachments", "_deleted", "_rev", "getDefaultRevision", "_meta", "lwt", "now", "createRevision", "checkpointKey", "document", "startReplicationDownstream", "state", "input", "initialCheckpoint", "downstream", "checkpointDoc", "getLastCheckpointDoc", "setCheckpoint", "identifierHash", "hashFunction", "identifier", "replicationHandler", "timer", "openTasks", "addNewTask", "task", "stats", "down", "taskWithTime", "time", "push", "streamQueue", "then", "useTasks", "length", "events", "active", "next", "innerTaskWithTime", "ensureNotFalsy", "shift", "lastTimeMasterChangesRequested", "downstreamResyncOnce", "downstreamProcessChanges", "firstSyncDone", "getValue", "canceled", "sub", "masterChangeStream$", "pipe", "mergeMap", "ev", "firstValueFrom", "up", "filter", "s", "subscribe", "masterChangeStreamEmit", "unsubscribe", "checkpointQueue", "lastCheckpoint", "promises", "downResult", "masterChangesSince", "pullBatchSize", "documents", "stackCheckpoints", "checkpoint", "persistFromMaster", "Promise", "all", "tasks", "docsOfAllTasks", "forEach", "Error", "appendToArray", "persistenceQueue", "PROMISE_RESOLVE_VOID", "nonPersistedFromMaster", "docs", "primaryPath", "docData", "docId", "downDocsById", "useCheckpoint", "docIds", "Object", "keys", "writeRowsToFork", "writeRowsToForkById", "writeRowsToMeta", "useMetaWriteRows", "forkInstance", "findDocumentsById", "getAssumedMasterState", "currentForkStateList", "assumedMasterState", "currentForkState", "Map", "doc", "set", "map", "forkStateFullDoc", "get", "forkStateDocData", "writeDocToDocState", "hasAttachments", "undefined", "masterState", "assumedMaster", "metaDocument", "isResolvedConflict", "_rev", "isAssumedMasterEqualToForkState", "conflictHandler", "realMasterState", "newDocumentState", "r", "isEqual", "_meta", "getHeightOfRevision", "areStatesExactlyEqual", "getMetaWriteRow", "newForkState", "assign", "flatClone", "_attachments", "getDefaultRevision", "lwt", "now", "nextRevisionHeight", "keepMeta", "forkWriteRow", "previous", "document", "createRevision", "bulkWrite", "downstreamBulkWriteFlag", "forkWriteResult", "success", "getWrittenDocumentsFromBulkWriteResponse", "processed", "error", "status", "newRxError", "writeError", "metaInstance", "stripAttachmentsDataFromMetaWriteRows", "metaWriteResult", "id", "documentId", "catch", "unhandledError", "defaultConflictHandler", "i", "_context", "newDocumentState", "stripAttachmentsDataFromDocument", "realMasterState", "deepEqual", "Promise", "resolve", "isEqual", "documentData", "resolveConflictError", "state", "input", "forkState", "conflictHandler", "conflictHandlerOutput", "undefined", "resolvedDoc", "Object", "assign", "_meta", "flatClone", "_rev", "getDefaultRevision", "_attachments", "lwt", "now", "createRevision", "checkpointKey", "output", "assignMethodsToAttachment", "attachment", "Object", "entries", "doc", "collection", "attachments", "forEach", "funName", "fun", "defineProperty", "get", "bind", "fillWriteDataForAttachmentsChange", "primaryPath", "storageInstance", "newDocument", "originalDocument", "_attachments", "Error", "docId", "originalAttachmentsIds", "Set", "keys", "Promise", "all", "map", "key", "value", "has", "ensureNotFalsy", "digest", "data", "attachmentDataString", "getAttachmentData", "RxAttachment", "doc", "id", "type", "length", "digest", "assignMethodsToAttachment", "_proto", "prototype", "remove", "collection", "incrementalWriteQueue", "addWrite", "_data", "docWriteData", "_attachments", "then", "getData", "plainDataBase64", "storageInstance", "getAttachmentData", "primary", "ret", "createBlobFromBase64", "getStringData", "data", "asString", "blobToString", "startReplicationUpstream", "state", "input", "initialCheckpoint", "upstream", "checkpointDoc", "getLastCheckpointDoc", "setCheckpoint", "replicationHandler", "streamQueue", "up", "then", "upstreamInitialSync", "processTasks", "timer", "initialSyncStartTime", "openTasks", "persistenceQueue", "PROMISE_RESOLVE_FALSE", "nonPersistedFromMaster", "docs", "sub", "forkInstance", "changeStream", "subscribe", "eventBulk", "context", "downstreamBulkWriteFlag", "stats", "forkChangeStreamEmit", "push", "task", "time", "events", "active", "getValue", "next", "waitBeforePersist", "firstValueFrom", "canceled", "pipe", "filter", "unsubscribe", "checkpointQueue", "lastCheckpoint", "promises", "Set", "_loop", "size", "Promise", "race", "Array", "from", "upResult", "getChangedDocumentsSince", "pushBatchSize", "documents", "length", "stackCheckpoints", "checkpoint", "promise", "persistToMaster", "ensureNotFalsy", "add", "catch", "delete", "resolvedPromises", "all", "hadConflicts", "find", "r", "firstSyncDone", "taskWithTime", "shift", "appendToArray", "map", "documentData", "forEach", "docData", "docId", "primaryPath", "upDocsById", "useCheckpoint", "docIds", "Object", "keys", "assumedMasterState", "getAssumedMasterState", "writeRowsToMaster", "writeRowsToMasterIds", "writeRowsToMeta", "forkStateById", "fullDocData", "writeDocToDocState", "hasAttachments", "keepMeta", "assumedMasterDoc", "metaDocument", "isResolvedConflict", "_rev", "conflictHandler", "realMasterState", "newDocumentState", "isEqual", "getHeightOfRevision", "_meta", "identifier", "undefined", "getMetaWriteRow", "writeRowsArray", "values", "conflictIds", "conflictsById", "writeBatches", "batchArray", "writeBatch", "row", "fillWriteDataForAttachmentsChange", "clone", "masterWriteResult", "masterWrite", "conflictDoc", "id", "useWriteRowsToMeta", "has", "processed", "metaInstance", "bulkWrite", "stripAttachmentsDataFromMetaWriteRows", "hadConflictWrites", "persistToMasterHadConflicts", "conflictWriteFork", "conflictWriteMeta", "entries", "writeToMasterRow", "resolveConflictError", "resolved", "resolvedConflicts", "output", "previous", "document", "resolvedDoc", "persistToMasterConflictWrites", "forkWriteResult", "useMetaWrites", "success", "getWrittenDocumentsFromBulkWriteResponse", "unhandledError", "error", "replicateRxStorageInstance", "input", "flatClone", "forkInstance", "getUnderlyingPersistentStorage", "metaInstance", "checkpointKeyPromise", "getCheckpointKey", "state", "primaryPath", "getPrimaryFieldOfPrimaryKey", "schema", "primaryKey", "hasAttachments", "attachments", "checkpointKey", "downstreamBulkWriteFlag", "then", "events", "canceled", "BehaviorSubject", "active", "down", "up", "processed", "Subject", "resolvedConflicts", "error", "stats", "addNewTask", "downstreamProcessChanges", "downstreamResyncOnce", "masterChangeStreamEmit", "persistFromMaster", "forkChangeStreamEmit", "persistToMaster", "persistToMasterConflictWrites", "persistToMasterHadConflicts", "processTasks", "upstreamInitialSync", "firstSyncDone", "streamQueue", "PROMISE_RESOLVE_VOID", "checkpointQueue", "lastCheckpointDoc", "startReplicationDownstream", "startReplicationUpstream", "awaitRxStorageReplicationFirstInSync", "firstValueFrom", "combineLatest", "pipe", "filter", "v", "awaitRxStorageReplicationInSync", "replicationState", "Promise", "all", "awaitRxStorageReplicationIdle", "rxStorageInstanceToReplicationHandler", "instance", "conflictHandler", "databaseInstanceToken", "keepMeta", "replicationHandler", "masterChangeStream$", "changeStream", "mergeMap", "eventBulk", "ret", "checkpoint", "documents", "map", "event", "docData", "writeDocToDocState", "documentData", "fillWriteDataForAttachmentsChange", "clone", "undefined", "masterChangesSince", "batchSize", "getChangedDocumentsSince", "result", "length", "plainDocumentData", "masterWrite", "rows", "rowById", "forEach", "row", "docId", "newDocumentState", "ids", "Object", "keys", "masterDocsStateList", "findDocumentsById", "masterDocsState", "Map", "doc", "set", "conflicts", "writeRows", "entries", "id", "masterState", "get", "push", "document", "docStateToWriteDoc", "assumedMasterState", "realMasterState", "ensureNotFalsy", "isEqual", "previous", "bulkWrite", "err", "status", "Error", "documentInDb", "cancelRxStorageReplication", "next", "complete", "ChangeEventBuffer", "collection", "subs", "counter", "eventCounterMap", "WeakMap", "buffer", "limit", "tasks", "Set", "push", "database", "eventBulks$", "pipe", "filter", "changeEventBulk", "collectionName", "name", "bulk", "first", "events", "isLocal", "subscribe", "eventBulk", "add", "_handleChangeEvents", "size", "requestIdlePromiseNoQueue", "then", "processTasks", "_proto", "prototype", "Array", "from", "forEach", "task", "clear", "counterBefore", "length", "slice", "appendToArray", "counterBase", "index", "event", "set", "getCounter", "getBuffer", "getArrayIndexByPointer", "pointer", "oldestEvent", "oldestCounter", "get", "rest", "getFrom", "ret", "currentIndex", "nextEvent", "runFrom", "fn", "Error", "cE", "reduceByLastOfDoc", "changeEvents", "docEventMap", "changeEvent", "documentId", "Object", "values", "destroy", "sub", "unsubscribe", "createChangeEventBuffer", "HOOKS_WHEN", "HOOKS_KEYS", "hooksApplied", "RxCollectionBase", "database", "name", "schema", "internalStorageInstance", "instanceCreationOptions", "migrationStrategies", "methods", "attachments", "options", "cacheReplacementPolicy", "defaultCacheReplacementPolicy", "statics", "conflictHandler", "defaultConflictHandler", "storageInstance", "timeouts", "Set", "incrementalWriteQueue", "awaitBeforeReads", "_incrementalUpsertQueues", "Map", "synced", "hooks", "_subs", "_docCache", "_queryCache", "createQueryCache", "$", "checkpoint$", "_changeEventBuffer", "onDestroy", "destroyed", "onRemove", "_applyHookFunctions", "asRxCollection", "_proto", "prototype", "prepare", "getWrappedStorageInstance", "jsonSchema", "IncrementalWriteQueue", "primaryPath", "newData", "oldData", "beforeDocumentUpdateWrite", "result", "_runHooks", "collectionEventBulks$", "eventBulks$", "pipe", "filter", "changeEventBulk", "collectionName", "mergeMap", "events", "map", "checkpoint", "createChangeEventBuffer", "documentConstructor", "DocumentCache", "isLocal", "b", "docData", "getRxDocumentConstructor", "createNewRxDocument", "listenToRemoveSub", "internalStore", "changeStream", "bulk", "key", "version", "found", "find", "event", "documentData", "context", "operation", "subscribe", "destroy", "Promise", "all", "fn", "push", "databaseStorageToken", "storageToken", "subDocs", "eventBulk", "Array", "length", "rawEvents", "deepFreezeWhenDevMode", "overwritable", "index", "documentId", "previousDocumentData", "id", "internal", "databaseToken", "token", "endTime", "startTime", "$emit", "conflictResultionTasks", "task", "input", "then", "output", "resolveConflictResultionTask", "PROMISE_RESOLVE_VOID", "cleanup", "_minimumDeletedTime", "ensureRxCollectionIsNotDestroyed", "pluginMissing", "migrationNeeded", "getMigrationState", "startMigration", "batchSize", "migratePromise", "insert", "json", "writeResult", "bulkInsert", "isError", "error", "throwIfIsStorageWriteError", "insertResult", "ensureNotFalsy", "success", "docsData", "ids", "insertRows", "hasHooks", "useDocData", "fillObjectDataBeforeInsert", "add", "document", "size", "newRxError", "collection", "args", "documents", "results", "bulkWrite", "rxDocuments", "ret", "getWrittenDocumentsFromBulkWriteResponse", "mapDocumentsDataToCacheDocs", "docsMap", "forEach", "row", "doc", "set", "get", "primary", "bulkRemove", "rxDocumentMap", "findByIds", "exec", "from", "values", "rxDocument", "data", "toMutableJSON", "removeDocs", "writeDoc", "flatClone", "_deleted", "previous", "successIds", "d", "getFromMapOrThrow", "bulkUpsert", "insertData", "useJsonByDocId", "useJson", "slice", "err", "status", "writeData", "docDataInDb", "documentInDb", "getCachedRxDocuments", "newDoc", "incrementalModify", "upsert", "bulkResult", "incrementalUpsert", "queue", "_incrementalUpsertEnsureRxDocumentExists", "wasInserted", "inserted", "_incrementalUpsertUpdate", "queryObj", "_getDefaultQuery", "query", "createRxQuery", "findOne", "isArray", "newRxTypeError", "selector", "limit", "count", "mangoQuery", "$in", "exportJSON", "importJSON", "_exportedJSON", "insertCRDT", "_updateObj", "addPipeline", "_options", "addHook", "when", "fun", "parallel", "includes", "boundFun", "bind", "runName", "series", "getHooks", "instance", "tasks", "hook", "promiseSeries", "_runHooksSync", "promiseWait", "time", "res", "timeout", "setTimeout", "delete", "PROMISE_RESOLVE_FALSE", "clearTimeout", "requestIdlePromise", "close", "sub", "unsubscribe", "collections", "runAsyncPluginHooks", "remove", "removeCollectionStorages", "storage", "password", "hashFunction", "_createClass", "cE", "colProto", "Object", "getPrototypeOf", "fnName", "ucfirst", "_innerDoc", "rxCollection", "docDataFromCache", "getLatestDocumentDataIfExists", "resolve", "createRxCollection", "autoMigrate", "localDocuments", "storageInstanceCreationParams", "databaseInstanceToken", "databaseName", "multiInstance", "devMode", "isDevMode", "runPluginHooks", "createRxCollectionStorageInstance", "entries", "funName", "defineProperty", "creator", "catch", "reject", "isRxCollection", "obj", "RxSchema", "jsonSchema", "hashFunction", "indexes", "getIndexes", "primaryPath", "getPrimaryFieldOfPrimaryKey", "primaryKey", "finalFields", "getFinalFields", "_proto", "prototype", "validateChange", "dataBefore", "dataAfter", "forEach", "fieldName", "deepEqual", "newRxError", "schema", "getDocumentPrototype", "proto", "pathProperties", "getSchemaByObjectPath", "Object", "keys", "key", "fullPath", "__defineGetter__", "get", "undefined", "ret", "defineProperty", "get$", "enumerable", "configurable", "get$$", "populate", "overwriteGetterForCaching", "getPrimaryOfDocumentData", "documentData", "getComposedPrimaryKeyOfDocumentData", "_createClass", "version", "values", "entries", "properties", "filter", "v", "hasOwnProperty", "call", "k", "default", "JSON", "stringify", "map", "index", "isMaybeReadonlyArray", "getPreviousVersions", "c", "Array", "fill", "createRxSchema", "runPreCreateHooks", "runPluginHooks", "useJsonSchema", "fillWithDefaultSettings", "normalizeRxJsonSchema", "overwritable", "deepFreezeWhenDevMode", "isRxSchema", "obj", "toTypedRxJsonSchema", "IdleQueue", "resolveFromOutside", "USED_DATABASE_NAMES", "Set", "DB_COUNT", "RxDatabaseBase", "name", "token", "storage", "instanceCreationOptions", "password", "multiInstance", "eventReduce", "options", "internalStore", "hashFunction", "cleanupPolicy", "allowSlowCount", "reactivity", "idleQueue", "IdleQueue", "rxdbVersion", "RXDB_VERSION", "storageInstances", "_subs", "startupErrors", "onDestroy", "destroyed", "collections", "states", "eventBulks$", "Subject", "observable$", "pipe", "mergeMap", "changeEventBulk", "events", "storageToken", "PROMISE_RESOLVE_FALSE", "storageTokenDocument", "emittedEventBulkIds", "ObliviousSet", "getWrappedStorageInstance", "asRxDatabase", "INTERNAL_STORE_SCHEMA", "ensureStorageTokenDocumentExists", "catch", "err", "push", "then", "doc", "data", "_proto", "prototype", "getReactivityFactory", "newRxError", "database", "$emit", "has", "id", "add", "next", "removeCollectionDoc", "schema", "getSingleDocument", "getPrimaryKeyOfInternalDocument", "_collectionNamePrimary", "INTERNAL_CONTEXT_COLLECTION", "writeDoc", "flatCloneDocWithMeta", "_deleted", "bulkWrite", "document", "previous", "addCollections", "collectionCreators", "jsonSchemas", "schemas", "bulkPutDocs", "useArgsByCollectionName", "Promise", "all", "Object", "entries", "map", "args", "collectionName", "rxJsonSchema", "createRxSchema", "collectionNameWithVersion", "collectionDocData", "key", "context", "schemaHash", "hash", "jsonSchema", "version", "connectedStorages", "_meta", "getDefaultRxDocumentMeta", "_rev", "getDefaultRevision", "_attachments", "useArgs", "assign", "hookData", "flatClone", "runPluginHooks", "conflictHandler", "putDocsResult", "ensureNoStartupErrors", "error", "status", "writeError", "docInDb", "ensureNotFalsy", "documentInDb", "collection", "previousSchemaHash", "previousSchema", "ret", "keys", "createRxCollection", "defineProperty", "get", "lockedRun", "fn", "wrapCall", "requestIdlePromise", "exportJSON", "_collections", "pluginMissing", "addState", "_name", "importJSON", "_exportedJSON", "backup", "_options", "leaderElector", "isLeader", "waitForLeadership", "migrationStates", "destroy", "runAsyncPluginHooks", "complete", "sub", "unsubscribe", "col", "close", "delete", "remove", "removeRxDatabase", "_createClass", "throwIfDatabaseNameUsed", "link", "createRxDatabaseStorageInstance", "databaseInstanceToken", "databaseName", "createStorageInstance", "INTERNAL_STORAGE_NAME", "devMode", "overwritable", "isDevMode", "createRxDatabase", "ignoreDuplicate", "localDocuments", "defaultHashSha256", "randomCouchString", "storageInstance", "rxDatabase", "creator", "dbInternalsStorageInstance", "collectionDocs", "getAllCollectionDocuments", "collectionNames", "forEach", "removedCollectionNames", "Array", "from", "removeCollectionStorages", "isRxDatabase", "obj", "dbCount", "isRxDatabaseFirstTimeInstantiated", "tokenDoc", "instanceToken"]
}
