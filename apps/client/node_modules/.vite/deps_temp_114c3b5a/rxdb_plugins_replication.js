import {
  addRxPlugin
} from "./chunk-6W7TEHXS.js";
import {
  createLeaderElection,
  getBroadcastChannelReference,
  removeBroadcastChannelReference
} from "./chunk-3TMRMTAB.js";
import {
  addConnectedStorageToCollection,
  awaitRxStorageReplicationFirstInSync,
  awaitRxStorageReplicationInSync,
  cancelRxStorageReplication,
  getRxReplicationMetaInstanceSchema,
  removeConnectedStorageFromCollection,
  replicateRxStorageInstance
} from "./chunk-XKXA2XFJ.js";
import {
  BehaviorSubject,
  PROMISE_RESOLVE_FALSE,
  PROMISE_RESOLVE_TRUE,
  Subject,
  arrayFilterNotEmpty,
  combineLatest,
  ensureNotFalsy,
  errorToPlainJson,
  filter,
  flatClone,
  getComposedPrimaryKeyOfDocumentData,
  getFromMapOrCreate,
  hasEncryption,
  mergeMap,
  newRxError,
  overwritable,
  runAsyncPluginHooks,
  toArray,
  toPromise
} from "./chunk-3XX7LFDR.js";
import "./chunk-EQCVQC35.js";

// ../../node_modules/rxdb/dist/esm/plugins/leader-election/index.js
var LEADER_ELECTORS_OF_DB = /* @__PURE__ */ new WeakMap();
var LEADER_ELECTOR_BY_BROADCAST_CHANNEL = /* @__PURE__ */ new WeakMap();
function getLeaderElectorByBroadcastChannel(broadcastChannel) {
  return getFromMapOrCreate(LEADER_ELECTOR_BY_BROADCAST_CHANNEL, broadcastChannel, () => createLeaderElection(broadcastChannel));
}
function getForDatabase() {
  var broadcastChannel = getBroadcastChannelReference(this.storage.name, this.token, this.name, this);
  var oldDestroy = this.destroy.bind(this);
  this.destroy = function() {
    removeBroadcastChannelReference(this.token, this);
    return oldDestroy();
  };
  var elector = getLeaderElectorByBroadcastChannel(broadcastChannel);
  if (!elector) {
    elector = getLeaderElectorByBroadcastChannel(broadcastChannel);
    LEADER_ELECTORS_OF_DB.set(this, elector);
  }
  this.leaderElector = () => elector;
  return elector;
}
function isLeader() {
  if (!this.multiInstance) {
    return true;
  }
  return this.leaderElector().isLeader;
}
function waitForLeadership() {
  if (!this.multiInstance) {
    return PROMISE_RESOLVE_TRUE;
  } else {
    return this.leaderElector().awaitLeadership().then(() => true);
  }
}
function onDestroy(db) {
  var has = LEADER_ELECTORS_OF_DB.get(db);
  if (has) {
    has.die();
  }
}
var rxdb = true;
var prototypes = {
  RxDatabase: (proto) => {
    proto.leaderElector = getForDatabase;
    proto.isLeader = isLeader;
    proto.waitForLeadership = waitForLeadership;
  }
};
var RxDBLeaderElectionPlugin = {
  name: "leader-election",
  rxdb,
  prototypes,
  hooks: {
    preDestroyRxDatabase: {
      after: onDestroy
    }
  }
};

// ../../node_modules/rxdb/dist/esm/plugins/replication/replication-helper.js
var DEFAULT_MODIFIER = (d) => Promise.resolve(d);
function swapDefaultDeletedTodeletedField(deletedField, doc) {
  if (deletedField === "_deleted") {
    return doc;
  } else {
    doc = flatClone(doc);
    var isDeleted = !!doc._deleted;
    doc[deletedField] = isDeleted;
    delete doc._deleted;
    return doc;
  }
}
function handlePulledDocuments(collection, deletedField, docs) {
  return docs.map((doc) => {
    var useDoc = flatClone(doc);
    if (deletedField !== "_deleted") {
      var isDeleted = !!useDoc[deletedField];
      useDoc._deleted = isDeleted;
      delete useDoc[deletedField];
    } else {
      useDoc._deleted = !!useDoc._deleted;
    }
    var primaryPath = collection.schema.primaryPath;
    useDoc[primaryPath] = getComposedPrimaryKeyOfDocumentData(collection.schema.jsonSchema, useDoc);
    return useDoc;
  });
}
function awaitRetry(collection, retryTime) {
  if (typeof window === "undefined" || typeof window !== "object" || typeof window.addEventListener === "undefined" || navigator.onLine) {
    return collection.promiseWait(retryTime);
  }
  var listener;
  var onlineAgain = new Promise((res) => {
    listener = () => {
      window.removeEventListener("online", listener);
      res();
    };
    window.addEventListener("online", listener);
  });
  return Promise.race([onlineAgain, collection.promiseWait(retryTime)]).then(() => {
    window.removeEventListener("online", listener);
  });
}

// ../../node_modules/rxdb/dist/esm/plugins/replication/index.js
var REPLICATION_STATE_BY_COLLECTION = /* @__PURE__ */ new WeakMap();
var RxReplicationState = function() {
  function RxReplicationState2(replicationIdentifier, collection, deletedField, pull, push, live, retryTime, autoStart) {
    this.subs = [];
    this.subjects = {
      received: new Subject(),
      // all documents that are received from the endpoint
      sent: new Subject(),
      // all documents that are send to the endpoint
      error: new Subject(),
      // all errors that are received from the endpoint, emits new Error() objects
      canceled: new BehaviorSubject(false),
      // true when the replication was canceled
      active: new BehaviorSubject(false)
      // true when something is running, false when not
    };
    this.received$ = this.subjects.received.asObservable();
    this.sent$ = this.subjects.sent.asObservable();
    this.error$ = this.subjects.error.asObservable();
    this.canceled$ = this.subjects.canceled.asObservable();
    this.active$ = this.subjects.active.asObservable();
    this.onCancel = [];
    this.callOnStart = void 0;
    this.remoteEvents$ = new Subject();
    this.replicationIdentifier = replicationIdentifier;
    this.collection = collection;
    this.deletedField = deletedField;
    this.pull = pull;
    this.push = push;
    this.live = live;
    this.retryTime = retryTime;
    this.autoStart = autoStart;
    this.metaInfoPromise = (async () => {
      var metaInstanceCollectionName = "rx-replication-meta-" + await collection.database.hashFunction([this.collection.name, this.replicationIdentifier].join("-"));
      var metaInstanceSchema = getRxReplicationMetaInstanceSchema(this.collection.schema.jsonSchema, hasEncryption(this.collection.schema.jsonSchema));
      return {
        collectionName: metaInstanceCollectionName,
        schema: metaInstanceSchema
      };
    })();
    var replicationStates = getFromMapOrCreate(REPLICATION_STATE_BY_COLLECTION, collection, () => []);
    replicationStates.push(this);
    this.collection.onDestroy.push(() => this.cancel());
    Object.keys(this.subjects).forEach((key) => {
      Object.defineProperty(this, key + "$", {
        get: function() {
          return this.subjects[key].asObservable();
        }
      });
    });
    var startPromise = new Promise((res) => {
      this.callOnStart = res;
    });
    this.startPromise = startPromise;
  }
  var _proto = RxReplicationState2.prototype;
  _proto.start = async function start() {
    if (this.isStopped()) {
      return;
    }
    var pullModifier = this.pull && this.pull.modifier ? this.pull.modifier : DEFAULT_MODIFIER;
    var pushModifier = this.push && this.push.modifier ? this.push.modifier : DEFAULT_MODIFIER;
    var database = this.collection.database;
    var metaInfo = await this.metaInfoPromise;
    var [metaInstance] = await Promise.all([this.collection.database.storage.createStorageInstance({
      databaseName: database.name,
      collectionName: metaInfo.collectionName,
      databaseInstanceToken: database.token,
      multiInstance: database.multiInstance,
      // TODO is this always false?
      options: {},
      schema: metaInfo.schema,
      password: database.password,
      devMode: overwritable.isDevMode()
    }), addConnectedStorageToCollection(this.collection, metaInfo.collectionName, metaInfo.schema)]);
    this.metaInstance = metaInstance;
    this.internalReplicationState = replicateRxStorageInstance({
      pushBatchSize: this.push && this.push.batchSize ? this.push.batchSize : 100,
      pullBatchSize: this.pull && this.pull.batchSize ? this.pull.batchSize : 100,
      initialCheckpoint: {
        upstream: this.push ? this.push.initialCheckpoint : void 0,
        downstream: this.pull ? this.pull.initialCheckpoint : void 0
      },
      forkInstance: this.collection.storageInstance,
      metaInstance: this.metaInstance,
      hashFunction: database.hashFunction,
      identifier: "rxdbreplication" + this.replicationIdentifier,
      conflictHandler: this.collection.conflictHandler,
      replicationHandler: {
        masterChangeStream$: this.remoteEvents$.asObservable().pipe(filter((_v) => !!this.pull), mergeMap(async (ev) => {
          if (ev === "RESYNC") {
            return ev;
          }
          var useEv = flatClone(ev);
          useEv.documents = handlePulledDocuments(this.collection, this.deletedField, useEv.documents);
          useEv.documents = await Promise.all(useEv.documents.map((d) => pullModifier(d)));
          return useEv;
        })),
        masterChangesSince: async (checkpoint, batchSize) => {
          if (!this.pull) {
            return {
              checkpoint: null,
              documents: []
            };
          }
          var done = false;
          var result = {};
          while (!done && !this.isStopped()) {
            try {
              result = await this.pull.handler(checkpoint, batchSize);
              done = true;
            } catch (err) {
              var emitError = newRxError("RC_PULL", {
                checkpoint,
                errors: toArray(err).map((er) => errorToPlainJson(er)),
                direction: "pull"
              });
              this.subjects.error.next(emitError);
              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));
            }
          }
          if (this.isStopped()) {
            return {
              checkpoint: null,
              documents: []
            };
          }
          var useResult = flatClone(result);
          useResult.documents = handlePulledDocuments(this.collection, this.deletedField, useResult.documents);
          useResult.documents = await Promise.all(useResult.documents.map((d) => pullModifier(d)));
          return useResult;
        },
        masterWrite: async (rows) => {
          if (!this.push) {
            return [];
          }
          var done = false;
          await runAsyncPluginHooks("preReplicationMasterWrite", {
            rows,
            collection: this.collection
          });
          var useRowsOrNull = await Promise.all(rows.map(async (row) => {
            row.newDocumentState = await pushModifier(row.newDocumentState);
            if (row.newDocumentState === null) {
              return null;
            }
            if (row.assumedMasterState) {
              row.assumedMasterState = await pushModifier(row.assumedMasterState);
            }
            if (this.deletedField !== "_deleted") {
              row.newDocumentState = swapDefaultDeletedTodeletedField(this.deletedField, row.newDocumentState);
              if (row.assumedMasterState) {
                row.assumedMasterState = swapDefaultDeletedTodeletedField(this.deletedField, row.assumedMasterState);
              }
            }
            return row;
          }));
          var useRows = useRowsOrNull.filter(arrayFilterNotEmpty);
          var result = null;
          if (useRows.length === 0) {
            done = true;
            result = [];
          }
          while (!done && !this.isStopped()) {
            try {
              result = await this.push.handler(useRows);
              if (!Array.isArray(result)) {
                throw newRxError("RC_PUSH_NO_AR", {
                  pushRows: rows,
                  direction: "push",
                  args: {
                    result
                  }
                });
              }
              done = true;
            } catch (err) {
              var emitError = err.rxdb ? err : newRxError("RC_PUSH", {
                pushRows: rows,
                errors: toArray(err).map((er) => errorToPlainJson(er)),
                direction: "push"
              });
              this.subjects.error.next(emitError);
              await awaitRetry(this.collection, ensureNotFalsy(this.retryTime));
            }
          }
          if (this.isStopped()) {
            return [];
          }
          await runAsyncPluginHooks("preReplicationMasterWriteDocumentsHandle", {
            result,
            collection: this.collection
          });
          var conflicts = handlePulledDocuments(this.collection, this.deletedField, ensureNotFalsy(result));
          return conflicts;
        }
      }
    });
    this.subs.push(this.internalReplicationState.events.error.subscribe((err) => {
      this.subjects.error.next(err);
    }), this.internalReplicationState.events.processed.down.subscribe((row) => this.subjects.received.next(row.document)), this.internalReplicationState.events.processed.up.subscribe((writeToMasterRow) => {
      this.subjects.sent.next(writeToMasterRow.newDocumentState);
    }), combineLatest([this.internalReplicationState.events.active.down, this.internalReplicationState.events.active.up]).subscribe(([down, up]) => {
      var isActive = down || up;
      this.subjects.active.next(isActive);
    }));
    if (this.pull && this.pull.stream$ && this.live) {
      this.subs.push(this.pull.stream$.subscribe({
        next: (ev) => {
          this.remoteEvents$.next(ev);
        },
        error: (err) => {
          this.subjects.error.next(err);
        }
      }));
    }
    if (!this.live) {
      await awaitRxStorageReplicationFirstInSync(this.internalReplicationState);
      await awaitRxStorageReplicationInSync(this.internalReplicationState);
      await this.cancel();
    }
    this.callOnStart();
  };
  _proto.isStopped = function isStopped() {
    if (this.subjects.canceled.getValue()) {
      return true;
    }
    return false;
  };
  _proto.awaitInitialReplication = async function awaitInitialReplication() {
    await this.startPromise;
    return awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));
  };
  _proto.awaitInSync = async function awaitInSync() {
    await this.startPromise;
    await awaitRxStorageReplicationFirstInSync(ensureNotFalsy(this.internalReplicationState));
    var t = 2;
    while (t > 0) {
      t--;
      await this.collection.database.requestIdlePromise();
      await awaitRxStorageReplicationInSync(ensureNotFalsy(this.internalReplicationState));
    }
    return true;
  };
  _proto.reSync = function reSync() {
    this.remoteEvents$.next("RESYNC");
  };
  _proto.emitEvent = function emitEvent(ev) {
    this.remoteEvents$.next(ev);
  };
  _proto.cancel = async function cancel() {
    if (this.isStopped()) {
      return PROMISE_RESOLVE_FALSE;
    }
    var promises = this.onCancel.map((fn) => toPromise(fn()));
    if (this.internalReplicationState) {
      await cancelRxStorageReplication(this.internalReplicationState);
    }
    if (this.metaInstance) {
      promises.push(ensureNotFalsy(this.internalReplicationState).checkpointQueue.then(() => ensureNotFalsy(this.metaInstance).close()));
    }
    this.subs.forEach((sub) => sub.unsubscribe());
    this.subjects.canceled.next(true);
    this.subjects.active.complete();
    this.subjects.canceled.complete();
    this.subjects.error.complete();
    this.subjects.received.complete();
    this.subjects.sent.complete();
    return Promise.all(promises);
  };
  _proto.remove = async function remove() {
    await ensureNotFalsy(this.metaInstance).remove();
    var metaInfo = await this.metaInfoPromise;
    await this.cancel();
    await removeConnectedStorageFromCollection(this.collection, metaInfo.collectionName, metaInfo.schema);
  };
  return RxReplicationState2;
}();
function replicateRxCollection({
  replicationIdentifier,
  collection,
  deletedField = "_deleted",
  pull,
  push,
  live = true,
  retryTime = 1e3 * 5,
  waitForLeadership: waitForLeadership2 = true,
  autoStart = true
}) {
  addRxPlugin(RxDBLeaderElectionPlugin);
  if (!pull && !push) {
    throw newRxError("UT3", {
      collection: collection.name,
      args: {
        replicationIdentifier
      }
    });
  }
  var replicationState = new RxReplicationState(replicationIdentifier, collection, deletedField, pull, push, live, retryTime, autoStart);
  startReplicationOnLeaderShip(waitForLeadership2, replicationState);
  return replicationState;
}
function startReplicationOnLeaderShip(waitForLeadership2, replicationState) {
  var mustWaitForLeadership = waitForLeadership2 && replicationState.collection.database.multiInstance;
  var waitTillRun = mustWaitForLeadership ? replicationState.collection.database.waitForLeadership() : PROMISE_RESOLVE_TRUE;
  return waitTillRun.then(() => {
    if (replicationState.isStopped()) {
      return;
    }
    if (replicationState.autoStart) {
      replicationState.start();
    }
  });
}
export {
  REPLICATION_STATE_BY_COLLECTION,
  RxReplicationState,
  replicateRxCollection,
  startReplicationOnLeaderShip
};
//# sourceMappingURL=rxdb_plugins_replication.js.map
